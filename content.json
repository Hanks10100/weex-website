{"meta":{"title":"Weex","subtitle":null,"description":null,"author":"Jinjiang","url":"http://alibaba.github.io","root":"/weex-website/"},"pages":[{"title":"","path":"download.html","permalink":"http://alibaba.github.io/download.html","text":"","type":"download"},{"title":"","path":"index.html","permalink":"http://alibaba.github.io/index.html","text":"","type":"index"},{"title":"","path":"playground.html","permalink":"http://alibaba.github.io/playground.html","text":"","type":"playground"},{"title":"FAQ","path":"faq.html","permalink":"http://alibaba.github.io/faq.html","text":"FAQCommand errors in WindowsPlease install Git for Windows first, see For Windows for more information. Gradle errors in Android StudioDownloading license-gradle-plugin.jar may trigger errors, like Connection reset or peer not authenticated.Maybe a network problem, try a proxy or VPN. Use local imageWeex’s native runtime support load image file from device’s disk, all you have to do set the file url like file:///sdcard/image_new0.png. As to load image file in your project, Weex is not support yet. Error（The header content contains invalid characters) in windowsThis’s is caused by weex-toolkit’s dependency ‘http-server’, whose old version is not working well in chinese windows environment. We have fixed that, you should upgrade weex-toolkit before use that. Playground app display nothing (white screen) after scanBest way to find out what’s happening is read debug log, you can follow this document to firgure out how to do that. About ECMAScript VersionWeex uses JSCore in iOS and uses v8 in Android. So they both support ECMAScript 5 spec. Additionally, we do some polyfills in native environment: Promise in iOS/Android Timer APIs (setTimeout / clearTimeout / setInterval / clearInterval) in iOS/Android console in iOS/Android In Browser we contains a polyfill of Promise temporarily. In the future developers can choose whether to import a polyfill by configurations. You can also write ES6 syntax by babel with webpack. The loader will convert ES6 syntax into ES5 automatically. If you want more ES6 polyfills you can import them into the JS Bundle as you like. Dependencies in frontendIn Weex you may have some ways to import/require a component or a JS module. Take ES5 syntax for example: require(&#39;xxx.js&#39;): depends on a JS file require(&#39;npm-module-name&#39;): depends on a NPM module require(&#39;xxx.we&#39;): include a we file to register a Weex custom component require(&#39;@weex-module/xxx&#39;): depends on a Weex native module. Notice that it is supported only in *.we file not *.js file. If you want to use Weex native module in a *.js file, temporarily you may write like this: // use this piece of code below to get Weex native module \"modal\"var modal__weex_define__('@weex-temp/x', function (__weex_require__) &#123; modal = __weex_require__('@weex-module/modal')&#125;)// use APIs in \"modal\" modulemodal.toast(&#123;message: 'hello'&#125;) We will bring a better syntax design in the future. iOS text line-height style is abnormalline-height style in text component is different from h5 and Android, text value will be placed at bottom of line box because of iOS native api. We are trying to optimize it. Android only support overflow:hiddenThe overflow style in android is hidden and cannot be changed. This is the result of Android View framework. This only happens on Android, iOS will work as expected. Android do not support emojiAs Android NDK only supports Modified UTF-8, emoji is not support yet. Any attemp to use emoji may cause crash in case of lower than Android 6.0, and unexpected behavior when it is higher than 6.0. Only use Modified UTF-8, do not use emoji. How to get rid of 750 adaption and calculate width/height in real pixels？The deviceHeight and deviceWidth got in this.$getConfig() is the real device width/height in pixels, not the ones with 750-adapted. So you can use them to calculate width/height in real pixels. Suppose you need to display a navigation bar of fixed 88 pixels, the bar’s height will be: var height = 88 * 750 / env.deviceWidth How to detect an native module/component supported in JavaScript?Detect native modulevar xxx = require('@weex-module/xxx')if (xxx) &#123; // todo: use this module&#125;else &#123; // todo: handle the exception&#125; Detect native component&lt;template&gt; &lt;component is=\"&#123;&#123;type&#125;&#125;\"&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt; var type = 'xxx' var xxx = require('@weex-component/xxx') if (!xxx) &#123; type = 'div' // downgrade to &lt;div&gt; &#125; module.exports = &#123; data: function () &#123; return &#123; type: type &#125; &#125; &#125;&lt;/script&gt; How to transfer data between pagesIf you have 2 pages, A and B. A -&gt; B, use getConfig api or storage module to transfer data B -&gt; A, use storage module to transfer data How to use repeat in Parent-Child componentsIf you want, You can make a repeat operation between Parent-Child components. But you must be strictly in accordance with the document syntax to write code. If there is no child component defined data, or there is no specify props that need to be passed down. It will lead to the page does not render properly. A correct example: &lt;element name=\"child\"&gt; &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size:100\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: null &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;child repeat=\"item in lists\" title=\"&#123;&#123; item.title &#125;&#125;\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; lists: [ &#123; title: 'A' &#125;, &#123; title: 'B' &#125;, &#123; title: 'C' &#125; ] &#125;, ready: function () &#123; this.lists.splice(0, 1) &#125; &#125;&lt;/script&gt; A wrong example： &lt;element name=\"child\"&gt; &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size:100\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;child repeat=\"item in lists\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; lists: [ &#123; title: 'A' &#125;, &#123; title: 'B' &#125;, &#123; title: 'C' &#125; ] &#125;, ready: function () &#123; this.lists.splice(0, 1) &#125; &#125;&lt;/script&gt;","type":"faq"},{"title":"Extend to Android","path":"advanced/extend-to-android.html","permalink":"http://alibaba.github.io/advanced/extend-to-android.html","text":"Extend to AndroidModule extendweex sdk support Module extend,Weex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module Follow the steps below. Step to customize a module Customize module must extend WXModule @WXModuleAnno annotation must be added, as it is the only the way to recognized by Weex The access levels of mehtod must be public The module class also can not be an inner class Customize can not be obfuscated by tools like ProGuard Module methods will be invoked in UI thread, do not put time consuming operation there Weex params can be int, double, float, String, Map, List Refer to the following example: public class WXEventModule extends WXModule&#123;22private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\";222@WXModuleAnno22public void openURL(String url)&#123;222//implement your module logic here22&#125;&#125; Register the mouldeWXSDKEngine.registerModule(\"event\", WXEventModule.class); Use this module in weex DSLNow event moudle is avaiable in weex, use the module like this: var event = require('@weex-module/event');event.openURL(\"http://www.github.com\"); Javascript callbackIf the module need implement a callback to javascript, you just add JSCallback argument to the method you want expose to javascript: @WXModuleAnnopublic void openURL(String url,JSCallback callback)&#123;2//implement your module logic here2Map&lt;String,Object&gt; resp = new HashMap();2resp.put(\"result\",\"ok\");2callback.invoke(resp);&#125; At the javascript side, call the module with javascript function to receive callback data: event.openURL(\"http://www.github.com\",function(resp)&#123; console.log(resp.result); &#125;); Component extendThere are label, image, div, scroll, ect. components in weex, you can also customize your own components. Step to customize a component Customize components must extend WXComponent or WXContainer @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK. The access levels of mehtod must be public The component class can not be an inner class Customize can not be obfuscated by tools like ProGuard Component methods will be invoked in UI thread, do not put time consuming operation there. Weex params can be int, double, float, String, Map, List, Array Refer to the following example public class MyViewComponent extends WXComponent&#123; 2public MyViewComponent(WXSDKInstance instance, WXDomObject dom,2 WXVContainer parent, String instanceId, boolean isLazy) 2 &#123; 2 public MyViewComponent(WXSDKInstance instance, WXDomObject dom,2 WXVContainer parent, String instanceId, boolean isLazy) &#123;2 super(instance, dom, parent, instanceId, isLazy);2 &#125;2 2 @Override2 protected void initView() &#123;2 mHost = new TextView(mContext);2 &#125;2 @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE)2 public void setMyViewValue(String value) &#123;2 ((TextView)mHost).setText(value);2 &#125;&#125; Register the ComponentWXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); Adapter extendImagedownloadAdapterWeex SDK has no image download capability, you need to implement IWXImgLoaderAdapter. Refer to the following examples. public class ImageAdapter implements IWXImgLoaderAdapter &#123;2private Activity mContext;2public ImageAdapter(Activity activity) &#123;22mContext = activity;2&#125;2@Override2public void setImage(final String url, final ImageView view,222WXImageQuality quality, WXImageStrategy strategy) &#123;22mContext.runOnUiThread(new Runnable() &#123;222222@Override222public void run() &#123;2222if (TextUtils.isEmpty(url)) &#123;22222view.setImageBitmap(null);22222return;2222&#125;2222String temp = url;2222if (url.startsWith(\"//\"))&#123;22222temp = \"http:\" + url;2222&#125;2222if (view.getLayoutParams().width&lt;=0 || view.getLayoutParams().height&lt;=0) &#123;22222return;2222&#125;2222Picasso.with(WXEnvironment.getApplication())222222.load(temp)222222.resize(view.getLayoutParams().width,22222222view.getLayoutParams().height).into(view);222&#125;22&#125;);2&#125;&#125;","type":"advanced"},{"title":"Extend to web","path":"advanced/extend-to-html5.html","permalink":"http://alibaba.github.io/advanced/extend-to-html5.html","text":"Extend Weex HTML5IntroWeex is a extendable cross-platform solution for dynamic programming and publishing projects. You can build your own components on web platform or native platform by extending the components system. Also you can extend weex by adding new methods for one module, new moudles or new bundle loaders. Follow the steps bellow you can dive into the journy of creating multiple builtin components, APIs and loaders. First of all, components, APIs and loaders are extensions to weex, so you can create your extensions without requiring the weex package, that means your extensions can be totally standalone. Second, you should always implement a extension for all the three platforms (android, ios and web), except that you only use it on one specific platform. After all weex is a cross platform framework and the equality of user expierence in all platforms is very important. Although you can create components separately on one platform by another, or welcome other developers on other platforms to join your work (You can always find coders who want the same feature with you in the commity). Here are docs about how to create native extensions on ios and android. You should publish your extensions somewhere weex developers can easily find, somewhere popular, independent and easy to search and use, such as, npm. Npm is what we strongly recommended. The most important thing is, you’d better name your extension appropriately: it should begin with a weex- if it is a weex extension, and it should end up with a -&lt;platform&gt; as a platform mark. If your package is wrapped up with all the three platforms you can ignore it through. Here is a demonstrating component &lt;weex-hello-web&gt; to show how to define your own component. Create a new componentSteps: Extend Weex.Component, override methods of component class. Use Weex.registerComponent to register your customized component in the init method of the installation module. export the init method for the installation (Every weex-html5 extension has to have a init method in the export object, which is for another weex project to install.) Here’s a example to create a weex component for web platform (weex-html5): const attr = &#123; // ...&#125;const style = &#123; // ...&#125;const event = &#123; // ...&#125;// every extension file should have a init method.function init (Weex) &#123; const Component = Weex.Component const extend = Weex.utils.extend // the component's constructor function Hello (data) &#123; Component.call(this, data) &#125; // extend the prototype Hello.prototype = Object.create(Component.prototype) extend(Hello.prototype, proto) // config the attributes, styles and events. extend(Hello.prototype, &#123; attr &#125;) extend(Hello.prototype, &#123; style: extend(Object.create(Component.prototype.style), style) &#125;) extend(Hello.prototype, &#123; event &#125;) Weex.registerComponent('weex-hello', Hello)&#125;// export the init method.export default &#123; init &#125; The code above is extracted from weex-hello-web/src/index.js. This demo has overrided the create method of the base class Component. You can also override other methods to customize your component’s behavior. The typical methods of class Component you may override are: create: to create the node of the component, and return it. createChildren to create the children’s nodes. insertBefore to insert a child before another child. appendChild to append a child in the children list. removeChild to remove a child in the children list. Advanced: Need more code demonstrations about overriding the component’s methods ? Just take a look at the weex repo’s code. Basically the most of the built-in components are defined this way. Important! To register your component in the init method, use Weex.registerComponent. Here’s the demo code: Weex.registerComponent('weex-hello', Hello) The code above is from weex-hello-web/src/index.js Install the component using Weex.install. // import the original weex-html5.import weex from 'weex-html5'import hello from 'weex-hello-web'// install the component.weex.install(hello) The code above is from weex_extend_demo/src/main.js use the component in your .we file: &lt;template&gt; &lt;div&gt; &lt;weex-hello class=\"hello\" style=\"txt-color:#fff;bg-color:green\" value=\"WEEX\" onclick=\"handleClick\"&gt; &lt;/weex-hello&gt; &lt;/div&gt;&lt;/template&gt; The code above is from weex_extend_demo/demo/index.we Add a new APIYou can add new API modules, or just add a new API for any existing API modules. For example, you can add a new module user with APIs like ‘login’, ‘logout’ etc. The developer can invoke the API by using require(&#39;@weex-module/moduleName)[methodName](arg1, arg2, ...) (Module APIs). Steps: Implement your API modules. Use Weex.registerAPIModules to register your API modules in the init method of your installation module. Here is a example for register a new API module First create a file named user.js for a new module, then define login/logout methods. const user = &#123; // for user to login. login (callbackId) &#123; login.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;, // for user to logout. logout (callbackId) &#123; logout.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;&#125;// add meta info to user module.const meta = &#123; user: [&#123; name: 'login', args: ['function'] &#125;, &#123; name: 'logout', args: ['function'] &#125;]&#125;export default &#123; init (Weex) &#123; // Register your new module. The last parameter is your // new API module's meta info. Weex.registerApiModule('user', user, meta) &#125;&#125; After above coding work, you can publish this user helper API to npm now, for example, with the name of weex-user-helper. Install the component using Weex.install in your new weex project. import Weex from 'weex-html5'import user from 'weex-user-helper'Weex.install(user) Use the user helper API in your dsl code (xxx.we): &lt;template&gt; &lt;div&gt; &lt;div class=\"btn\" onclick=\"handleClick\"&gt; &lt;text&gt;LOGIN&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var userHelper = require('@weex-module/user') module.exports = &#123; methods: &#123; handleClick: function () &#123; userHelper.login(function () &#123; // ... do sth. in callback. &#125;) &#125; &#125; &#125;&lt;/script&gt; Add a new loaderLoader is only a type of extension for weex-html5 (web platform), native platform is not needing this. Weex’s builtin loaders to load a weex bundle are xhr, jsonp and source. The default loader is xhr. You can register your own loader by using weex.registerLoader. For example, you got a service method named myServe.getWeexBundle, which can load a weex bundle file through some magical tunnel: function loadByMyServe(pageId, callback) &#123; myServe.getWeexBundle(pageId).then(function (bundle) &#123; callback(bundle) &#125;).catch(function(err) &#123; callback(err) &#125;)&#125;// export the init method to enable weex install this loader.export default &#123; init (Weex) &#123; Weex.registerLoader('myserve', loadByMyServe) &#125;&#125; install and use your loader in your project’s entry file: import Weex from 'weex-html5'// or import from './myserve.js', no matter where you can import your loader file.import loader from 'myLoader'Weex.install(loader)// use your loader in the init function:(function () &#123; function getUrlParam (key) &#123; const reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') const match = location.search.match(reg) return match &amp;&amp; match[1] &#125; const page = getUrlParam('page') || 'examples/build/index.js' Weex.init(&#123; appId: location.href, loader: 'myserve', // use the loader type you defined. source: page, rootId: 'weex' &#125;)&#125;)(); That’s the major extension feature weex brought to you. The deep details can be found in the weex’s repo and the weex’s community.","type":"advanced"},{"title":"Extend to iOS","path":"advanced/extend-to-ios.html","permalink":"http://alibaba.github.io/advanced/extend-to-ios.html","text":"Extend to iOSModule extendWeex SDK provides only rendering capabilities, rather than have other capabilities, such as network, picture, and URL redirection. If you want these features, you need to implement it. For example: If you want to implement an address jumping function, you can achieve a Module following the steps below. Step to customize a module Module customized must implement WXModuleProtocol A macro named WX_EXPORT_METHOD must be added, as it is the only way to be recognized by Weex. It takes arguments that specifies the method in module called by JavaScript code. The weexInstance should be synthesized. Each module object is bind to a specific instance. Module methods will be invoked in UI thread, so do not put time consuming operation there. If you want to execute the whole module methods in other thread, please implement the method - (NSThread *)targetExecuteThread in protocol. In the way, tasks distributed to this module will be executed in targetExecuteThread. Weex params can be String or Map. Module supports to return results to Javascript in callback. This callback is type of WXModuleCallback, the params of which can be String or Map. @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end Register the moduleYou can register the customized module by calling the method registerModule:withClass in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; Handler extendWeex SDK doesn’t have capabilitis, such as image download 、navigator operation，please implement these protocols by yourself. WXImgLoaderProtocolWeex SDK has no image download capability, you need to implement WXImgLoaderProtocol. Refer to the following examples. WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished. */ -(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock; @end Implement above protocol as follows. @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end Register the handlerYou can register the handler which implements the protocol by calling registerHandler:withProtocol in WXSDKEngine. WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol; [WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; Custom Native Components for iOSComponent extendThere are a lot of native components ready to be used in the Weex SDK, but users always have their own use cases. You might have written an awesome native UI widget in your previous work and just want to wrap up it and export to Weex. So we provide a way to enable developers to create their own custom fully-native components. This guide will use the implementation of existing component image to show you how to build a native component. It will also assume that you are familiar with iOS programming. RegistrationDefining a custom native component is simple. Just call [WXSDKEngine registerComponent:withClass:] with the component’s tag name as first argument. [WXSDKEngine registerComponent:@&quot;image&quot; withClass:[WXImageComponent class]]; Then you can create a WXImageComponent class to represent the implementation of image component. Now you can use &lt;image&gt; wherever you want in the template. &lt;image&gt;&lt;/image&gt; Adding PropertiesThe next thing we can do is to extend some native properties to make the component more powerful. As an image, let’s say we should have a src attribute as image’s remote source and a resize attribute as image’s resize mode(contain/cover/stretch). @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end All of the styles, attributes and events will be passed to the component’s initialization method, so here you can store the properties which you are interested in. @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; &#125; return self;&#125;@end The properties getted in the attributes are of id type, so we have to convert them to the type we want using a conversion function. Basic conversion functions can be found in the WXConvert file, or you can just add your own conversion function. Hooking Render Life CycleA Native Component has a life cycle managed by Weex. Weex creates it, layout it, renders it and destroys it. Weex offers component life cycle hooks that give you visibility into these key moments and the ability to act when they occur. method description initWithRef:type:… Initializes a new component using the specified properties. layoutDidFinish Called when the component has just laid out. loadView Creates the view that the component manages. viewWillLoad Called before the load of component’s view . viewDidLoad Called after the component’s view is loaded and set. viewWillUnload Called just before releasing the component’s view. viewDidUnload Called when the component’s view is released. updateStyles: Called when component’s style are updated. updateAttributes: Called when component’s attributes are updated. addEvent: Called when adding an event to the component. removeEvent: Called when removing an event frome the component. As in the image component example, if we need to use our own image view, we can override the loadView method. - (UIView *)loadView&#123; return [[WXImageView alloc] init];&#125; Now Weex will use WXImageView to render the image component. As an image component, we will need to fetch the remote image and set it to the image view. This can be done in viewDidLoad method when the view is created and loaded. viewDidLoad is also the best time to perform additional initialization for your view， such as content mode changing. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; If image’s remote source can be changed, you can also hook the updateAttributes: method to perform your attributes changing logic. Component’s view always has been loaded while updateAttributes: or updateStyles: is called. - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; Maybe there is even more life cycle hooks you might need to consider, such as layoutDidFinish while layout computing is finished. If you want to go deeper, check out the WXComponent.h file in the source code. Now you can use &lt;image&gt; and its attributes wherever you want in the template. &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt;","type":"advanced"},{"title":"How data-binding works","path":"advanced/how-data-binding-works.html","permalink":"http://alibaba.github.io/advanced/how-data-binding-works.html","text":"How data-binding worksWeex JS Framework is a MVVM framework. It observe data and use {{bindedKey}} syntax to bind in views. When data is changed in anyway, the view will automatically be updated due to data-binding. For example, The content of a &lt;text&gt; component is bound with the key notes in data: &lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;notes&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;template&gt;&lt;script&gt; module.exports = &#123; data: &#123; notes: 'Hello' &#125; &#125;&lt;/script&gt; Weex JS Framework first observe the data object to make sure each data change in the future will be observed. And then it will compile the whole &lt;template&gt;. When it finds that the content of the &lt;text&gt; is bound with notes, JS Framework will watch the data.notes changes and set a handler which will update the &lt;text&gt; content with new data.notes. So developer only need to manage the data, the view display could automatically do corresponding changes. Some special data-binding syntax here: will watch the condition value changes. When it changes to true, the &lt;foo&gt; element will be created and attached, otherwise it will be not created or removed. will watch the mutations of a list. At the beginning the &lt;foo&gt; element will be cloned and attached with each item in list. When some items are added, removed or moved, the &lt;foo&gt; element list will be re-generated new content in the right order with minimum alterations. will process repeat first and if the second. In another way, it will walk through each item in list, if the item’s condition value is true, a &lt;foo&gt; element will be cloned and attached with this certain item value. Compared with virtual DOM diff algorithm, we just “diff” the data and only calculate/update the virtual DOM with minimum alterations for each user interaction or data-change operation. So it’s more lightweight and fast especially for small views in mobile devices.","type":"advanced"},{"title":"How it works","path":"advanced/index.html","permalink":"http://alibaba.github.io/advanced/index.html","text":"How it works0.4 OverviewWeex is a extendable cross-platform solution for dynamic programming and publishing projects. In the source code you can write pages or components with &lt;template&gt;, &lt;style&gt; and &lt;script&gt; tags, and then transform them into bundles for deploying. In server-side we can use these JS bundles for client request. When client get a bundle from server, it will be processed by client-side JavaScript engine and manages the native view rendering, the native API invoking and user interactions. Whole WorkflowWeex file --------------frontend(source code)↓ (transform) --------- frontend(build tool)JS bundle ------------- frontend(bundle code)↓ (deploy) ------------ serverJS bundle in server --- server↓ (compile) ----------- client(js-engine)Virtual DOM tree ------ client(weex-jsframework)↓ (render) ------------ client(render-engine)Native view ----------- client(render-engine) According to the workflow above, you need: Transformer: A nodejs tool to transform the source code into the bundle code. JS Framework: A JavaScript framework runing in the client which manage Weex instance. The instance which created from a JS bundle builds virtual DOM tree. Also it sends/receives native calls for native view rendering, native APIs and user interactions. Native Engine: There are many different ports for different platforms: iOS/Android/HTML5. They have the same components design, module APIs design and rendering effect. So they can work with the one and the same JS Framework and JS bundles. TransformerThe transformer transforms a source code into a bundle code. The whole work could be divided into three parts: Transform &lt;template&gt; into a JSON-like tree and transform data-binding attribute into a function prop which return the correct data value. For example: will be transformed into {type: &quot;foo&quot;, attr: {a: function () {return this.x}, b: 1}}. Transform &lt;style&gt; into a JSON tree. For example: .classname {name: value;} will be transformed into {classname: {name: value}}. Join the two above with &lt;script&gt; content. The three parts will be joined together and wrapped into a JavaScript AMD module. A whole example (main.we): &lt;template&gt; &lt;foo a=\"&#123;&#123;x&#125;&#125;\" b=\"1\" class=\"bar\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;style&gt; .bar &#123;width: 200; height: 200&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;x: 100&#125; &#125; &#125;&lt;/script&gt; will transformed into: define(&apos;@weex-component/main&apos;, function () &#123; module.exports = &#123; data: function () &#123; return &#123;x: 100&#125; &#125; &#125; module.template = &#123; type: &quot;foo&quot;, attr: &#123; a: function () &#123;return this.x&#125;, b: 1, classname: [&apos;bar&apos;] &#125; &#125; module.style = &#123; bar: &#123;width: 200, height: 200&#125; &#125;&#125;bootstrap(&apos;@weex-component/main&apos;) Additionally, the transformer could also do more things: combo the bundles, bootstrap with config and external data. For more information, please see the syntax specs. NOTICEMost of Weex utility output JS Bundle after Webpack re-bundle. So the eventual format of Weex JSBundle is webpack packed . JS FrameworkJS Framework will run in native JavaScript engine at the beginning preparation phase. It has define() and bootstrap() functions for each the bunlde code. Once a JS bundle requested from server, the code will be executed. define() will register all modules first, then bootstrap() will start compiling main component into virtual DOM and send rendering calls to native. There are two key methods for the bridge between JS and native: callNative sends commands from JavaScript to native. So it’s called from JavaScript and implemented with native code. All commands are native APIs organized by modules, for example rendering, networking, authorizing, and other client-side features like toast etc. callJS sends commands from native to JavaScript. So it’s called from native and implemented by JS Framework. All commands are user interactions or native callbacks. Native RenderEngineNative RenderEngine will supplies many native components and modules for call. Component is an element in the screen which have a certain view and behavior. It could be configured with some attributes and style properties, and could response user interactions. There are some common components like &lt;div&gt;, &lt;text&gt;, &lt;image&gt; etc. Module is a set of APIs which could be called from JS Framework. Some of them also have to make async callbacks to JS Framework, for example: send HTTP request. During a Weex instance works, Native RenderEngine receives all kinds of module API calls from JS Framework. These calls will create or update components for view and use client-side features like toast. When a user interaction or module API callback happens, It will call callJS() from JS Framework. These jobs could walk through the Weex instance lifecycle till the instance is destroyed. As is shown in the architecture figure, H5 RenderEngine is a special RenderEngine with almost the same functions as native RenderEngines. Weex Architecture call native from javascript[JS Framework]↓ callNativemodule APIs rendering -&gt; components display other features[Native RenderEngine] call javascript from native[Native RenderEngine]module APIs callbacksuser interactions↓ callJS[JS Framework] Render FlowWeex Render Flow Input is virtual dom. Build Tree. Parse JSON data (virtual dom) to a Render Tree (RT). Apply Style. Attach css style to RT nodes. Create View. Create native views for each RT node. Attach Event. Attach events for each view. CSS Layout. Use css-layout to calculate the layout of each view. Update Frame. Update layout parameters of each view. Output is Native or H5 Views. In H5 Render Flow, CSS Layout and Update Frame are implemented by browser engine like webkit.","type":"advanced"},{"title":"Integrate to Android","path":"advanced/integrate-to-android.html","permalink":"http://alibaba.github.io/advanced/integrate-to-android.html","text":"Integrate to AndroidWhen you need to use the new features or to customize specific features, you can rely on the Source SDK for development。 PrerequisitesAssuming you have the Android SDK installed, run android to open the Android SDK Manager. Make sure you have the following installed: Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.2 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) Android NDK (download &amp; extraction instructions here) Point Gradle to your Android SDK: either have $ANDROID_SDK and $ANDROID_NDK defined, or create a local.properties file in the root of your weex checkout with the following contents: sdk.dir=absolute_path_to_android_sdkndk.dir=absolute_path_to_android_ndk Example: sdk.dir=/Users/your_name/android-sdk-macosxndk.dir=/Users/your_name/android-ndk-r10e Building the source1. Clone source from githubFirst, you need to git clone weex from github: git clone https://github.com/alibaba/weex.git 2. Build APK 1) Android studio build APK Step 1: run android studio Step 2: open the file of ~/weex/android/playground/build.gradle Step 3: Run the Project and the Apk will auto install in your android device 2) Gradle build APK Step 1: enter the direction of &quot;/weex/android/playground&quot;Step 2: run the build command: ./gradlew clean assembleStep 3: obtain the payground APK from the direction of weex/android/playground/app/build/outputs/apk/Step 3: then adb install -r weex/android/playground/app/build/outputs/apk/playgroud.apk 3. Adding the :weex_sdk_android projectAdd the :weex_sdk_android project in android/settings.gradle: include ':weex_sdk_android'project(':weex_sdk_android').projectDir = new File( rootProject.projectDir, '../weex_sdk_android') Modify your android/app/build.gradle to use the :weex_sdk_android project instead of the pre-compiled library, e.g. - replace compile &#39;com.taobao.android:weex_sdk:0.4.1 with compile project(&#39;:weex_sdk_android&#39;): dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.0.1' compile project(':weex_sdk_android') ...&#125; 3. Making 3rd-party modules use your projectIf you use 3rd-party weex modules, you need to override their dependencies so that they don’t build the pre-compiled library. Otherwise you’ll get an error while compiling - Error: more than one library with package name &#39;com.taobao.weex&#39;. Modify your android/app/build.gradle and replace compile project(&#39;:weex-custom-module&#39;) with: compile(project(':weex-custom-module')) &#123; exclude group: 'com.taobao.weex', module: 'weex_sdk_android'&#125; 4、How to load local Your Js bundle in the directory of Android assetsBesides load a Js Bundle online, you also can load the js bundle from the directory of Android assets. For Example: String yourbundleStr = WXFileUtils.loadFileContent(&quot;yourBundle.js&quot;, context);WXSDKInstance.render(TAG, yourbundleStr, options, null, width, Height, WXRenderStrategy.APPEND_ASYNC); Building from Android StudioFrom the Welcome screen of Android Studio choose “Import project” and select the playground folder of your app. You should be able to use the Run button to run your app on a device. Tip Since the packet size limit is currently only compiled arm , X86 does not support. Gradle build fails in ndk-build. See the section about local.properties file above. #Quick access Requirements an existing, gradle-based Android app Prepare your appIn your app’s build.gradle file add the WEEX dependency: compile &apos;com.taobao.android:weex_sdk:0.4.1&apos; You can find the latest version of the WEEX library on jcenter. Next, make sure you have the Internet permission in your AndroidManifest.xml: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; Add native codeYou need to add some native code in order to start the Weex runtime and get it to render something. To do this, we’re going to create an Application to init weex, then we we’re going to create an Activity that creates a WeexContainerView, starts a Weex application inside it and sets it as the main content view. public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); WXEnvironment.addCustomOptions(\"appName\",\"TBSample\"); WXSDKEngine.init(this); try &#123; WXSDKEngine.registerComponent(\"wtRichText\", WTRichText.class); ...... WXSDKEngine.registerModule(\"event\", WXEventModule.class); &#125; catch (WXException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Next, //crate Weex instanceWXSDKInstance mInstance = new WXSDKInstance(this);//set image AdaptermInstance.setImgLoaderAdapter(new ImageAdapter(this));//register render listenermInstance.registerRenderListener(new IWXRenderListener() &#123; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; // addview mViewGroup.addView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode,String msg) &#123; &#125;&#125;); //start render weex view mInstance.render(pageName,template, null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); That’s it, your activity is ready to run some JavaScript code. Reference ExampleWeex Examples","type":"advanced"},{"title":"Integrate to web","path":"advanced/integrate-to-html5.html","permalink":"http://alibaba.github.io/advanced/integrate-to-html5.html","text":"Integrate Weex HTML5 to your projectIntroWeex is a extendable cross-platform solution for dynamic programming and publishing projects, which is for developers to write code once and run the code everywhere. The bundle transformed from the source can currently run on android, ios and web platform. Weex HTML5 is a renderer for weex bundle to run on a webview or a modern browser etc. Get Weex HTML5Use npm to install the latest version of Weex HTML5, require it in your code by CommonJS and use it as a npm package. Install from npmMake sure you get the latest version by npm install or npm update. For more information of npm, please visit the npm official site. npm install weex-html5 require weex-html5: const weex = require(&apos;weex-html5&apos;) Initialize and runYou can initialize weex through the API init. This method takes a config object as the first argument to confirm the runtime infomation and environment. Following parameters can be set by this config object: appId: app instance id, can be either a string or a number source: the requested url of weex bundle, or the transformed code it self. loader: the loader type to load the weex bundle, which value is ‘xhr’ or ‘jsonp’ or ‘source’. xhr: load the source (weex bundle url) by XHR jsonp: load the source bundle by JSONP source: the source parameter above should be a weex bundle content (transformed bundle). rootId: the id of the root element. Default value is ‘weex’. Here is a example to do the initialzation: function weexInit() &#123; function getUrlParam (key) &#123; var reg = new RegExp(&apos;[?|&amp;]&apos; + key + &apos;=([^&amp;]+)&apos;) var match = location.search.match(reg) return match &amp;&amp; match[1] &#125; var loader = getUrlParam(&apos;loader&apos;) || &apos;xhr&apos; var page = getUrlParam(&apos;page&apos;) // jsonp callback name should be specified or be the default // value &apos;weexJsonpCallback&apos; if the &apos;jsonp&apos; loader is used. var JSONP_CALLBACK_NAME = &apos;weexJsonpCallback&apos; window.weex.init(&#123; jsonpCallback: JSONP_CALLBACK_NAME, appId: location.href, source: page, loader: loader, rootId: &apos;weex&apos; &#125;)&#125;weexInit()","type":"advanced"},{"title":"","path":"blog/index.html","permalink":"http://alibaba.github.io/blog/index.html","text":"","type":"blog"},{"title":"Integrate to iOS","path":"advanced/integrate-to-ios.html","permalink":"http://alibaba.github.io/advanced/integrate-to-ios.html","text":"import Weex iOS to your projectYou will need to build Weex from source if you want to work on a new feature/bug fix, try out the latest features not released yet, or maintain your own fork with patches that cannot be merged to the core. Assuming you have installed iOS Develop Environment and CocoaPods. 1. Clone source from githubFirst, you need to git clone weex from github: git clone https://github.com/alibaba/weex.git 2. Import WeexSDK to projectCopy the whole folder /ios/sdk to your project directory. Before adding the dependencies, please confirm that the project directory already exists the Podfile. If not, create a new one. Then, edit this file, adding some necessary dependecis for the target. target &apos;YourTarget&apos; do2platform :ios, &apos;7.0&apos;2pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos;end You can get your YourTarget below Run pod install in current directory, for a while, .xcworkspace will be created. At this point, the dependencies have been established. 3. Init Weex EnvironmentWe are used to doing some initial tasks in appDelegate. Of course, there is no exception. You can do this in didFinishLaunchingWithOptions as follows. //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment]; //register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel:WXLogLevelVerbose]; 4. Render Weex InstanceWeex supports two different modes, the full page rendering and part of page rendering.Something you have to do is to render weex view with specific URL, then add it to the parent container, which may be the viewController. #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123;2[super viewDidLoad];22_instance = [[WXSDKInstance alloc] init];2_instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; [_instance renderWithURL:self.url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance is a very imporent class, which provides you with some basic methods and callbacks, such as renderWithURL、onCreate、onFailed and etc. You can understand their usage by reading WXSDKInstance.h. 5. Destroy Weex InstancePlease release weex instance in dealloc stage of viewContoller, or it will lead to memory leak. - (void)dealloc&#123; [_instance destroyInstance];&#125; 6. Build .IPA for WeexWe can also pack all the JS files into the app’s resources. This way you can run your app without development server and submit it to the AppStore. Install weex-toolkit and transform your .we file to JS by running weex index.we -o index.js, index.we is the entry file of your app. Move index.js to your app’s Xcode project and add the file to your target. Replace [_instance renderWithURL:&#39;httpURL&#39;] with: [_instance renderWithURL: [[NSBundle mainBundle] URLForResource:@&quot;index&quot; withExtension:@&quot;js&quot;]] Go to Product -&gt; Archive in Xcode and follow the steps to build your .IPA file and submit it to the AppStore.","type":"advanced"},{"title":"","path":"cn/download.html","permalink":"http://alibaba.github.io/cn/download.html","text":"","type":"download"},{"title":"常见问题","path":"cn/faq.html","permalink":"http://alibaba.github.io/cn/faq.html","text":"常见问题解答Windows 指令错误请先安装 Git for Windows，在 For Windows 中查看更多信息。 Android Studio 中 Gradle 错误下载 license-gradle-plugin.jar 可能引发一些错误，比如 链接被重置（Connection reset） 和 证书无效（peer not authenticated） 。这可能是由于网络问题导致的，请尝试使用代理或VPN。 使用本地图片Weex 的原生运行机制支持从设备中加载图片，你只需要设置文件 url，例如 file:///sdcard/image_new0.png 这样的格式。但是 Weex 暂时还不支持加载你工程中的图片文件。 Windows 错误 The header content contains invalid characters （头中包含非法字符）这是由于 weex-toolkit 的依赖 http-server 导致的，http-server 的老版本在中文 windows 中的支持不是很好。我们已经修复了这个问题，请在使用前升级 weex-toolkit 版本。 Playground 应用在扫面后什么都没有显示（白屏）最好的方法是查看 debug 日志来查找原因，你可以按照 这篇文档 中的说明来查明导致这一问题的原因。 关于 ECMAScript 版本问题Weex 在 iOS 中使用 JSCore ，在 Android 中使用 v8，因此他们都支持 ECMAScript 5。另外，我们还在原生环境中加了一些 polyfills： Promise in iOS/Android Timer APIs (setTimeout/clearTimeout/setInterval/clearInterval`) in iOS/Android console in iOS/Android 在浏览器中我们暂时是包含了一个 Promise 的 polyfill。 在未来，开发者可以选择是否通过 configurations 来导入一个 polyfill。 你也可以通过带有 webpack 的 babel 来写 ES6，这个加载器能够自动将 ES6 转换为 ES5。 如果你还想要更多的 ES6 polyfills，你可以把他们引入到 JS Bundle 中。 前端依赖在 Weex 中你有很多方法来 import/require 一个组件或者一个 JS 模块。以 ES5 为例： require(&#39;xxx.js&#39;) : 依赖一个 JS 文件 require(&#39;npm-module-name&#39;) : 依赖一个 NPM 模块 require(&#39;xxx.we&#39;) : 包含一个 .we 文件来注册一个 Weex 自定义组件 require(&#39;@weex-module/xxx&#39;) : 以来一个 Weex 原生模块。注意这只支持 *.we 文件而不支持 *.js 文件。如果你想要在一个 *.js 文件中使用 Weex 原生模块，暂时你可以这样写： // use this piece of code below to get Weex native module \"modal\"var modal__weex_define__('@weex-temp/x', function (__weex_require__) &#123; modal = __weex_require__('@weex-module/modal')&#125;)// use APIs in \"modal\" modulemodal.toast(&#123;message: 'hello'&#125;) 以后我们会给大家带来一个更好的设计。 iOS 文本 line-height 样式不正常line-height 样式在 &lt;text&gt; 组件中的表现与 H5 和 Android 不同，文本不会在行内居中，而是贴近行底部，因为这里使用的 iOS 原生 API。我们正在努力优化，与其他两端保持一致。 Android 只支持 overflow:hiddenoverflow 样式在 Android 默认为 hiddne 并且无法修改，原因是 Android View framework 限制。这个问题只出现在 Android 端，iOS 端和 H5 正常。 Android 不支持 emoji由于 Android NDK 仅支持 Modified UTF-8，因此不支持 emoji。Android 6.0 以下使用 emoji 可能会导致崩溃，在 Android 6.0 以上则可能出现意外的行为。只能使用 Modified UTF-8，不要使用 emoji。 如何取消 750 像素自适应并以宽高比计算真实像素？this.$getConfig() 方法会返回一个对象，这个对象的 deviceHeight 和 deviceWidth 属性即实际设备宽度/高度（以像素为单位），而不是以 750 适配的。 因此，您可以使用它们来计算实际像素的宽度/高度。 假设您需要显示固定为 88 px 的导航栏，该导航栏的高度将是： var height = 88 * 750 / env.deviceWidth 如何在 JavaScript 中检测是否支持某个原生的 module/component检测原生 modulevar xxx = require('@weex-module/xxx')if (xxx) &#123; // todo: use this module&#125;else &#123; // todo: handle the exception&#125; 检测原生 component&lt;template&gt; &lt;component is=\"&#123;&#123;type&#125;&#125;\"&gt;&lt;/component&gt;&lt;/template&gt;&lt;script&gt; var type = 'xxx' var xxx = require('@weex-component/xxx') if (!xxx) &#123; type = 'div' // downgrade to &lt;div&gt; &#125; module.exports = &#123; data: function () &#123; return &#123; type: type &#125; &#125; &#125;&lt;/script&gt; 如何在 pages 之间传递数据如果你有两个页面，A 页面和 B 页面 A -&gt; B，使用 getConfig api or storage module 传递数据； B -&gt; A，使用 storage module 传递数据。 父子组件之间进行 repeat 操作如果你有需求，在父子组件之间进行 repeat 操作，需要注意，必须严格按照官网文档的语法来书写代码。如果缺少子组件定义 data 数据，或者是没有指定需要向下传递的 props，都会导致页面不正常渲染。 错误示例： &lt;element name=\"child\"&gt; &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size:100\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;child repeat=\"item in lists\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; lists: [ &#123; title: 'A' &#125;, &#123; title: 'B' &#125;, &#123; title: 'C' &#125; ] &#125;, ready: function () &#123; this.lists.splice(0, 1) &#125; &#125;&lt;/script&gt; 以上示例的理想执行情况，应该是页面上第一个元素 A 被删除，剩下 B、C 两个元素。但是，由于错误的写法，导致列表执行 splice 操作之后，出现错误的更新情况：页面最后一个元素 C 被删除。 正确的写法如下： &lt;element name=\"child\"&gt; &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size:100\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: null &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;child repeat=\"item in lists\" title=\"&#123;&#123; item.title &#125;&#125;\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; lists: [ &#123; title: 'A' &#125;, &#123; title: 'B' &#125;, &#123; title: 'C' &#125; ] &#125;, ready: function () &#123; this.lists.splice(0, 1) &#125; &#125;&lt;/script&gt; 在线示例请见： 错误示例","type":"faq"},{"title":"","path":"cn/index.html","permalink":"http://alibaba.github.io/cn/index.html","text":"","type":"index"},{"title":"","path":"cn/playground.html","permalink":"http://alibaba.github.io/cn/playground.html","text":"","type":"playground"},{"title":"Tutorial","path":"guide/index.html","permalink":"http://alibaba.github.io/guide/index.html","text":"TutorialWe will make a simple but realistic list, in which the technologies Weex uses will be shown. This form of list also works for a lot of e-commercial apps and mobile sites. Getting StartedLet’s get started with the list item, which contains one image element and one text right behind. &lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE3AJt\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;JavaScript&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .cell &#123; margin-top: 10; margin-left: 10; flex-direction: row; &#125; .thumb &#123; width: 200; height: 200; &#125; .title &#123; text-align: center; flex: 1; color: grey; font-size: 50; &#125;&lt;/style&gt; You can directly copy and paste the above code into a Weex file named tech_list.we (.we is our recommended filename extension). PreviewOnce created, we want to see the running result of the .we file. But before that, we must make sure the dependencies are installed. We should install Node first, which our Weex CLI program Weex Toolkit depends on. Then install weex-toolkit by running the command: $ npm install -g weex-toolkit When installation completed, you can check if Weex CLI is installed properly by running weex command in the command line. The following text is expected: Usage: weex foo/bar/your_next_best_weex_script_file.we [options]Options: --qr display QR code for native runtime, -o,--output transform weex we file to JS Bundle, output path (single JS bundle file or dir) -s,--server start a http file server, weex .we file will be transforme to JS bundle on the server , specify local root path using the option ...... --help Show help -h, --host [default: &quot;127.0.0.1&quot;] If all work well, navigate to the directory where you saved tech_list.we, then type: $ weex tech_list.we A browser window will be opened automatically to display the running result like below (weex-toolkit version should be greater than 0.1.0, use weex --version to check it): Introduce to Weex SyntaxSo it’s time for introducing the syntax. Given the content of tech_list.we, Weex source code is composed of three parts – template, style, and script, just like html, css, and javascript for the Web. Template is the skeleton that gives Weex structure. It is composed of tags which surround content and apply meaning to it. Tags have attributes, different attribute means different feature, for example, class attribute makes it possible to define the same styles for multiple tags, onclick attribute makes the tag respond to click event. Style describes how Weex tags are to be displayed. We prefer CSS very much. So we try to keep consistent with CSS standard as possible. Weex Style supports a lot of CSS features, like margin, padding, fixed and so on. Better yet, flexbox layout (flex) is well supported in Weex Style. Script adds data &amp; logic to Weex tags, helping you easily access local or remote data and update tags. You can also define some methods for your tag to respond to different events. Weex Script organization learns a lot from CommonJS module style. More information about Weex syntax can be found in our Syntax chapter. Add More ItemsWe can’t call one item an list, so we need to add more items to our tech list. Open tech_list.we in your favorite editor and update it’s content like below: &lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE3AJt\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;JavaScript&lt;/text&gt; &lt;/div&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE3uo9\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Java&lt;/text&gt; &lt;/div&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE31hq\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Objective C&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .cell&#123; margin-top:10 ; margin-left:10 ; flex-direction: row; &#125; .thumb &#123; width: 200; height: 200; &#125; .title &#123; text-align: center ; flex: 1; color: grey; font-size: 50; &#125;&lt;/style&gt; Now we will try to render our tech_list.we with Weex native renderer. Open your terminal and navigate to the directory where you save the tech_list.we again, then type: $ weex tech_list.we --qr -h &#123;ip or hostname&#125; It’s RECOMMENDED to use -h option to specify your local ip address or hostname. An QR code will be displayed in the terminal window like below: The QR code can work together with Weex Playground App. Open it and tap the scan icon at the top-right corner, then scan the Qr code displayed in your terminal. If all work well, a beautiful list will be displayed in your phone. Here, I must stress that the list is rendered by a native view, instead of Webkit, so your app gets faster loading and less memory overhead than common Webview renderer. Now open tech_list.we again and try to change some text, after changes saved the Weex playground App will immediately display these changes. We call that Hot-Reload, which is intended to help you use Weex better. Add Built-in ComponentsInstead of writing basic tags by yourself, Weex provides a lot of built-in components. For example, Slider is common to many apps and mobile websites, so Weex includes a built-in Slider so that you can easily use it in your script. Let’s open tech_list.we and update it’s content like below. &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;slider class=\"slider\" interval=\"&#123;&#123;intervalValue&#125;&#125;\" auto-play=\"&#123;&#123;isAutoPlay&#125;&#125;\" &gt; &lt;div class=\"slider-pages\" repeat=\"&#123;&#123;itemList&#125;&#125;\" onclick=\"goWeexSite\" &gt; &lt;image class=\"thumb\" src=\"&#123;&#123;pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/slider&gt; &lt;div class=\"container\" onclick=\"goWeexSite\" &gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE3AJt\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;JavaScript&lt;/text&gt; &lt;/div&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE3uo9\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Java&lt;/text&gt; &lt;/div&gt; &lt;div class=\"cell\"&gt; &lt;image class=\"thumb\" src=\"http://t.cn/RGE31hq\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;Objective C&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .cell &#123; margin-top:10 ; margin-left:10 ; flex-direction: row; &#125; .thumb &#123; width: 200; height: 200; &#125; .title &#123; text-align: center ; flex: 1; color: grey; font-size: 50; &#125; .slider &#123; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; intervalValue:\"1000\", isShowIndicators:\"true\", isAutoPlay:\"true\", itemList: [ &#123;title: 'Java', pictureUrl: 'http://t.cn/RGE3uo9'&#125;, &#123;title: 'Objective C', pictureUrl: 'http://t.cn/RGE31hq'&#125;, &#123;title: 'JavaScript', pictureUrl: 'http://t.cn/RGE3AJt'&#125; ] &#125;, methods: &#123; goWeexSite: function () &#123; this.$openURL('http://alibaba.github.io/weex/') &#125; &#125;&#125;&lt;/script&gt; Open terminal and run the command again: $ weex tech_list.we You should see a slider prepend to our list. More information about Slider component can be found here. Just as the previous example, the slider can be rendered in native, easily in Weex playground, or in your App. Please refer the document for integrating Weex into your App.","type":"guide"},{"title":"Component APIs","path":"references/api.html","permalink":"http://alibaba.github.io/references/api.html","text":"APIsYou can access these apis through this(Vm) context in script methods. e.g. &lt;script&gt;module.exports = &#123; methods: &#123; somemethod: function() &#123; this.$vm('someId'); &#125; &#125;&#125;&lt;/script&gt; $(id)Deprecated, please use $vm instead. $el(id)Return the element referenced by specific id. Arguments id(string): the unique identifier. Returns (Element): an Element object referenced. Tips id is only guaranteed to be unique within the current (page)components, if you are looking for the parent components or child components, you can make use of the communication mode between components. Further reading: id, Communicate Between Components $vm(id)Return the vm object referenced by specific id. Arguments id(string): the unique identifier. Returns vm(Vm): a Vm object referenced. Tips id is only guaranteed to be unique within the current (page)components, if you are looking for the parent components or child components, you can make use of the communication mode between components. Further reading: id, Communicate Between Components $getConfig()Get the current global environment variables and configuration information. Returns config(object): the object of config. bundleUrl(string): the url of bundle. debug(boolean): if is debug mode. env(object): a object of envrioment. weexVersion(string): a version of weex sdk. appName(string): a name of app. appVersion(string): a version of app. platform(string): the platform, one of iOS, Android and Web. osVersion(string): the version of os. deviceModel(string): the model of device. native only deviceWidth(number): the width of device, in pixels. deviceHeight(number): the height of device, in pixels. $call(module, method, …args)Deprecated, please use require(&#39;@weex-module/module&#39;)[method](...args) instead. See modules for more information","type":"references"},{"title":"","path":"references/cheatsheet.html","permalink":"http://alibaba.github.io/references/cheatsheet.html","text":"Weex Cheat SheetNative Components component attribtues styles events special parent children &lt;div&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;text&gt; value box modelflexpositionbackground-coloropacitycolorfont-sizefont-stylefont-weighttext-decorationtext-aligntext-overflowline-height clickappeardisappear - text only &lt;image&gt; src box modelflexboxpositionbackground-coloropacityresize clickappeardisappear - (none) &lt;scroller&gt; show-scrollbarscroll-direction box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;list&gt; loadmoreoffset box modelflexboxpositionbackground-coloropacity clickappeardisappearloadmorerefreshloading - &lt;cell&gt;&lt;header&gt;&lt;refresh&gt;&lt;loading&gt; &lt;cell&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear &lt;list&gt; (any) &lt;slider&gt; auto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearchange - (any)&lt;indicator&gt; &lt;indicator&gt; - box modelflexboxpositionitem-coloritem-selected-coloritem-size clickappeardisappear &lt;slider&gt; (none) &lt;wxc-navpage&gt; heightbackground-colortitletitle-colorleft-item-titleleft-item-colorright-item-titleright-item-colorleft-item-srcright-item-src box modelflexboxpositionbackground-coloropacity clickappeardisappearnaviBar.leftItem.clicknaviBar.rightItem.click - (any) &lt;wxc-tabbar&gt; tab-items box modelflexboxpositionbackground-coloropacity tabBar.onClick - (none) &lt;embed&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappear - (none) &lt;web&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappearpagestartpagefinisherror - (none) &lt;video&gt; srcplay-statusauto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearstartpausefinishfail - (none) &lt;a&gt; href box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;input&gt; typevalueplaceholderdisabledautofocus box modelflexboxpositionbackground-coloropacityplaceholder-colorcolorfont-sizefont-stylefont-weighttext-align clickappeardisappear - (none) &lt;switch&gt; checkeddisabled box modelflexboxpositionbackground-coloropacity appeardisappearinputchangefocusblur - (none) Native Modules module apis @weex-module/dom scrollToElement(node, { offset }) @weex-module/modal toast({ message, duration })alert({ message, okTitle }, callback)confirm({ message, okTitle, cancelTitle }, callback(result))prompt({ message, okTitle, cancelTitle }, callback(result, data)) @weex-module/stream fetch({ method, url, headers, type, body }, callback({ status, ok, statusText, data, headers }), progressCallback({ readyState, status, length, statusText, headers})) @weex-module/webview goBack(ref)goForward(ref)reload(ref) @weex-module/navigator push({ url, animated }, callback)pop({ animated }, callback) @weex-module/animation transition(node, { styles, duration, timingFunction, delay, transform-origin }, callback) Special Template Syntax &lt;foo x=&quot;abc&quot;&gt; &lt;foo style=&quot;name1: value1; name2: value2&quot;&gt; &lt;foo class=&quot;a b c&quot;&gt; &lt;foo onclick=&quot;methodName&quot;&gt; &lt;foo id=&quot;abc&quot;&gt; &lt;foo if=&quot;expr&quot;&gt; &lt;foo repeat=&quot;item in list&quot;&gt; &lt;foo repeat=&quot;(key,item) in list&quot;&gt; &lt;component type=&quot;foo&quot;&gt; ViewModel APIs this.$vm(el) this.$el(el) this.$getConfig() this.$emit(type, data) this.$dispatch(type, data) this.$broadcast(type, data) ViewModel Options data methods computed init, created, ready events example: module.exports = &#123; data: function () &#123; return &#123; x: 1, y: 2 &#125; &#125; methods: &#123; foo: function () &#123; console.log('foo') &#125; &#125;, computed: &#123; z: function () &#123; return this.x + this.y &#125; &#125;, events: &#123; custom: function (e) &#123; console.log(e) &#125; &#125;, init: function () &#123;&#125;, created: function () &#123;&#125;, ready: function () &#123;&#125;&#125;"},{"title":"List of the names of colors","path":"references/color-names.html","permalink":"http://alibaba.github.io/references/color-names.html","text":"List of the names of colorsBasic color keywords: Color Name Hex rgb black #000000 silver #C0C0C0 gray #808080 white #FFFFFF maroon #800000 red #FF0000 purple #800080 fuchsia #FF00FF green #008000 lime #00FF00 olive #808000 yellow #FFFF00 navy #000080 blue #0000FF teal #008080 aqua #00FFFF Extended color keywords: Color Name Hex rgb aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"Common Attribute","path":"references/common-attrs.html","permalink":"http://alibaba.github.io/references/common-attrs.html","text":"Common AttributeAttributes provide additional information about weex tags. All weex tags can have attributes, attributes are always specified in the start tag and usually come in name/value pairs like: name=”value”. Mustache can be used inside a value.All of weex tags have the following attributes： idSpecifies a unique id for an element in &lt;template&gt; scope. With id attribute you can easily refer a weex tag. &lt;div id=\"logo\"&gt;&lt;/div&gt; &lt;div id=\"item-{{index}}\"&gt;&lt;/div&gt; styleSpecifies an inline style for an element. &lt;div style=\"width: 200; height: 200\"&gt;&lt;/div&gt; &lt;div style=\"padding: {{x}}; margin: 0\"&gt;&lt;/div&gt; classSpecifies one or more classnames for an element (refers to a class in a style sheet). &lt;div class=\"button\"&gt;&lt;/div&gt; &lt;div class=\"button {{btnStatus}}\"&gt;&lt;/div&gt; repeatWe can use the repeat attribute to render a list of items based on an array. The repeat attribute has a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on. &lt;div repeat={{list}}&gt;&lt;/div&gt; &lt;div repeat={{item in list}}&gt;&lt;/div&gt; ifProvide a boolean value to decide whether or not to display current tag. &lt;div if=\"true\"&gt;&lt;/div&gt; &lt;div if=\"{{opened}}\"&gt;&lt;/div&gt; &lt;div if=\"{{direction === 'row'}}\"&gt;&lt;/div&gt; appendBy providing the value of tree or node, it determines the progress of rendering. &lt;div append=\"tree/node\"&gt;&lt;/div&gt; Event Handing (on…)Register event handlers on weex tag. &lt;div onclick=\"openDetail\"&gt;&lt;/div&gt; &lt;div onappear=\"{{loadMore}}\"&gt;&lt;/div&gt; Notes!Weex is basically following HTML attribute naming rule, so please do not use CamelCase in your attribute, kebab-case with “-“ as delimiter is much better.","type":"references"},{"title":"Common Events","path":"references/common-event.html","permalink":"http://alibaba.github.io/references/common-event.html","text":"Common EventsWeex provide the ability to let events trigger action, like starting a JavaScript when a user click on a component. Bellow are the common event attributes that can be added to weex components to define event actions. Click eventThe onclick attribute fires on a click gesture on the element.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : click target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example: &lt;template&gt; &lt;text style=\"font-size: 60px\" onclick=\"{{update}}\"&gt;I am {{name}}&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = { data: { name: 'Tom' }, methods: { update: function () { this.name = this.name === 'Tom' ? 'Jerry' : 'Tom' } } } &lt;/script&gt; Longpress eventIf a longpress event is bound to a component, the event will be triggered when user long press on it.Notes: The input and switch component does not currently support the click event, please use change or input event instead. event object type : longpress target : The target component where the event is triggered timestamp : Timestamp when event is triggered Example: &lt;template&gt; &lt;div style=\"width: 400px; height: 200px; background-color: {{bg}}; justify-content: center; align-items: center;\" onlongpress=\"{{update}}\"&gt; &lt;text style=\"font-size: 60px\"&gt;Press me&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = { data: { bg: '#FF0000' }, methods: { update: function () { this.bg = this.bg === '#FF0000' ? '#00FF00' : '#FF0000' } } } &lt;/script&gt; Appear eventIf a appear event is bound to a component inside a scrollable container, the event will be triggered when the component comes to be visible. event object type : appear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. example Disappear eventIf a disappear event is bound to a component inside a scrollable container, the event will be triggered when the component scrolls out of viewport and disappears from your sight. event object type : disappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered direction : The direction in which the scroller is scrolling. Could be up or down. example Page eventWeex provides you with simple management of page status, such as viewappear and viewdisappear.The viewappear event will be triggered when page is about to show or before any animations are configured for showing. For example, when calling push method in navigator module, this event will be trigged in new page.The viewdisappear event will be triggeded when page is about to dismiss.Different from appear and disappear of component, these two events focus on the status of whole page, so they must be bound to the root component.In addititon, these events also can be bound to body component which is not root actually such as wxc-navpage. event object type : viewappear or viewdisappear target : The target component where the event is triggered timestamp : Timestamp when event is triggered example","type":"references"},{"title":"Common Style","path":"references/common-style.html","permalink":"http://alibaba.github.io/references/common-style.html","text":"Common StyleAll of weex tags share some common style rules Box Model Weex box model based on the CSS box model, all of weex elements can be considered as boxes. The term “box model” is used when talking about design and layout. The box model is essentially a box that wraps around every HTML element. It consists of margins, borders, paddings, and the actual content. you can use the definition below in weex box model. width: length type, default value 0 height: length type, default value 0 padding: length type, default value 0, (space around content, between element content and the element border) padding-left: length type, default value 0 padding-right: length type, default value 0 padding-top: length type, default value 0 padding-bottom: length type, default value 0 margin: length type, default value 0, (space around elements, outside the border) margin-left: length type, default value 0 margin-right: length type, default value 0 margin-top: length type, default value 0 margin-bottom: length type, default value 0 border border-style: values solid | dashed | dotted, default value solid border-left-style: values solid | dashed | dotted, default value solid border-top-style: values solid | dashed | dotted, default value solid border-right-style: values solid | dashed | dotted, default value solid border-bottom-style: values solid | dashed | dotted, default value solid border-width: length type, non-negative, default value 0DO NOT use border-width:1. There is a default viewport &lt;viewport width=&quot;750&quot;&gt;, if the actual width of a device is 720px, then border-width:1 will be border-width:0.96. As weex do not support sub-pixel, this border would not be rendered. border-left-width: length type, non-negative, default value 0 border-top-width: length type, non-negative, default value 0 border-right-width: length type, non-negative, default value 0 border-bottom-width: length type, non-negative, default value 0 border-color: color type, default value #000000 border-left-color: color type, default value #000000 border-top-color: color type, default value #000000 border-right-color: color type, default value #000000 border-bottom-color: color type, default value #000000 border-radius: length type, default value 0, (rounded borders to elements , default value is 0 meaning right angle ) Although the the default overflow style is overflow:hidden in android, a view will not be clipped by its parents’ border-radius. This only happens on Android, it works fine on iOS. border-bottom-left-radius: length type, non-negative, default value 0 border-bottom-right-radius: length type, non-negative, default value 0 border-top-left-radius: length type, non-negative, default value 0 border-top-right-radius: length type, non-negative, default value 0 Notes: The rule of border-radius for a specific corner such as border-top-left-radius is not currently supported for component &lt;image&gt; and &lt;text&gt;. Weex box model uses border-box as the default value of box-sizing, meaning the width and height properties includes content, padding and border, but not the margin. example: &lt;template&gt; &lt;div&gt; &lt;image src=\"...\" style=\"width: 400; height: 200; margin-left: 20;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex box style model based on the CSS flexbox, ensures that elements behave predictably and the page layout can accommodates to different screen sizes and different display devices. Flexbox consists of flex containers and flex items. If a weex element can containing other elements, it is a flex container. Notice that the old version of flexbox specification has differences with the new ones, such as whether or not to support wrapping. This is described at w3c’s working drafts, and you should notice the differences among them. Also notice that the old version is only supported below the 4.4 version of android. Flex containerFlexbox is the default and only style model in Weex, so you don’t have to add display: flex; in a container. flex-direction: values row | column, default value column The flex-direction property specifies the direction of the flexible items inside the flex container. Default value is column (top-to-bottom). justify-content: values flex-start | flex-end | center | space-between, default value flex-start The justify-content property horizontally aligns the flexible container’s items when the items do not use all available space on the main-axis. Default value is flex-start meaning the flex items are positioned at the beginning of the container. flex-end means the items are positioned at the end of the container. center means the items are positioned at the center of the container. space-between means the items are positioned with space between the lines. align-items: values stretch | flex-start | center | flex-end, default value stretch The align-items property vertically aligns the flexible container’s items when the items do not use all available space on the cross-axis. Default value is stretch meaning the items are stretched to fit the container. flex-start means the items are positioned at the top of the container; flex-end means the items are positioned at the bottom of the container; center means items are positioned at the center of the container (vertically). Flex item flex: number type, default value 0 the flex property specifies the length of the flex item, relative to the rest of the flex items inside the same container. If all of the flex items set flex: 1, they will have equal width or height on direction of flex container’s flex-direction. If there are two flex items, with one setting flex: 1, and the other setting flex: 2, the first one will take 1/3 container space, and the second one will take 2/3 container space. If all of flex items don’t set flex, they will be aligned depending on the container’s justify-content property. Examplesa list of images with equal scales align at the vertical axis: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;image src=\"...\" style=\"flex: 1;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; a image with fixed width aligns with a stretched text: &lt;template&gt; &lt;div style=\"width: 300; height: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;text style=\"flex: 1;\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; mixed direction alignment: &lt;template&gt; &lt;div style=\"width: 100;\"&gt; &lt;image src=\"...\" style=\"width: 100; height: 100;\"&gt;&lt;/image&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text style=\"flex: 2; font-size: 32;\"&gt;title&lt;/text&gt; &lt;text style=\"flex: 1; font-size: 16;\"&gt;$100&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; one text align left , the other float right: &lt;template&gt;&lt;div style=\"flex-direction: row; justify-content: space-between;\"&gt; &lt;text&gt;WEEX&lt;/text&gt; &lt;text&gt;2016-05-08&lt;/text&gt;&lt;/div&gt;&lt;/template&gt; Positionwe can use properties below to control placement of weex tag position: values relative | absolute | fixed | sticky, default value relative relative means the item is positioned relative to its normal position. absolute means the item is positioned relative to its container. fixed keeps the elements position fixed when the page is scrolling. sticky keeps elements positioned inside the viewport as “stuck” at the top or “relative” at its original place depending on whether does it about to scroll out of the view. top: number type, default value 0, upward offset value bottom: number type, default value 0, downward offset value left: number type, default value 0, leftward offset value right: number type, default value 0, rightward offset value Examples&lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"top: 50; left: 50; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: sticky; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;div style=\"height: 3000;\"&gt; &lt;image src=\"...\" style=\"position: absolute; top: 50; left: 50; ...\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; Other Common Style opacity background-color Type of Style Value length type number type color type (The list of color keywords.) enumerated type Simple StepThese up-to-down steps may help you to plan the whole style of weex pages. overall style: divide the whole page to different parts flex alignment: align boxes in every part of page position box: place box, set offset element specific style: set styles for certain element if needed","type":"references"},{"title":"Component Definition","path":"references/component-defs.html","permalink":"http://alibaba.github.io/references/component-defs.html","text":"Component DefinitionA component definition is a set of options to describe a component. It’s always assigned to module.exports in &lt;script&gt;. module.exports = &#123; // a set of options here&#125; Data &amp; Methods optionsmodule.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, methods: &#123; doThis: function () &#123;...&#125;, doThat: function () &#123;...&#125; &#125;, ...&#125; The data option is a function that return a observable data object for this ViewModel.The methods option is a map which contains all ViewModel methods. Each data or methods property will be proxied to the ViewModel instance. So you can read and write data with this.x, also you can call methods with this.doThis(...). A whole example: &lt;template&gt; &lt;div style=\"width: &#123;&#123;w&#125;&#125;; height: &#123;&#123;h&#125;&#125;; background-color: red;\" onclick=\"update\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;w: 750, h: 200&#125; &#125;, methods: &#123; update: function (e) &#123; this.h += 200 &#125; &#125; &#125;&lt;/script&gt; Events optionsmodule.exports = &#123; data: ..., methods: &#123; foo: function () &#123; ... this.$emit('customtype1', data) &#125; &#125;, events: &#123; customtype1: function (e) &#123; console.log(e.type, e.detail) &#125; &#125;, ...&#125; The events options could allow you to add custom event listeners when ViewModel created. Then it will listen these type of events and handle them by the function-type value. The first argument is a event object which contains event data in e.detail. Lifecycle optionsmodule.exports = &#123; data: ..., methods: ..., init: function () &#123; console.log('ViewModel constructor begins') &#125;, created: function () &#123; console.log('Data observation finished') &#125;, ready: function () &#123; console.log('Virtual DOM finished') &#125;, ...&#125; Weex ViewModel now supports these lifecycle hook functions which could be write as component options: init: fired at the beginning of a ViewModel constructor call. created: fired when ViewModel observes default data but not compile the template. ready: fired when ViewModel observes default data and compiles the template to generate virtual DOM finally. Note: If you want to use the function in methods, events or lifecycle options as a parameter, please make sure the context is correct as expect. For example: module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, ready: function () &#123; // `undefined` // because the context changed this.foo(this.bar) // `1` // because the context bound correct this.foo(this.bar.bind(this)) &#125;, methods: &#123; foo: function (fn) &#123; return fn() &#125;, bar: function () &#123; return this.x &#125; &#125;&#125;","type":"references"},{"title":"Bootstrap","path":"references/index.html","permalink":"http://alibaba.github.io/references/index.html","text":"BootstrapBesides its default meaning, &lt;script&gt; tag supports two more configuration with its type property in the top level component of a page. type=&quot;data&quot;: For initial data configuration, the data defined here will overwrite the data definition in the &lt;script&gt;. type=&quot;config&quot;: For configuration definition. &lt;script type=\"data\"&gt; /* (optional) the definition of initial data */&lt;/script&gt;&lt;script type=\"config\"&gt; /* (optional) the definition of configuration */&lt;/script&gt; Initial data definitionSometimes, it is hard to maintain huge data structure in the default &lt;script&gt; tag. So Weex allows us to have a &lt;script type=&quot;data&quot;&gt; tag to define initial data. The data defined in here will totally replace the data defined in the default &lt;script&gt; tag. here is an example: &lt;script type=\"data\"&gt;&#123; title: 'Alibaba', date: new Date().toLocaleString()&#125;&lt;/script&gt; script configurationWeex also allows us to do some configuration with a &lt;script type=&quot;config&quot;&gt;, So far, we only support the downgrade configs. downgrade.osVersion downgrade.appVersion downgrade.weexVersion downgrade.deviceModel","type":"references"},{"title":"Gesture","path":"references/gesture.html","permalink":"http://alibaba.github.io/references/gesture.html","text":"Gesture Experiment Feature Weex encapsulates native touch events to provide a gesture system. Using gesture is similar to use event in Weex. Just set on attributes on a node to listen to gesture. TypeFor now, there are four types of gestures: Touch. Touch gesture is fired when a touch point is placed, moved or removed from the touch surface. Touch gesture is accuracy as it will report every trivial event. As a result, listening to touch gesture may be slow, a great deal of events needs to be processed even a small move happened. There are three types of Touch gesture: touchstart will be fired when a touch point is placed on the touch surface. touchmove will be fired when a touch point is moved along the touch surface. touchend will be fired when a touch point is removed from the touch surface. Pan. Pan gesture also report motion of touch point on the touch surface, which is similar to touch gesture. But Pan gesture is sampled and faster than the touch event. As consequence, it is less accuracy than touch gesture. There are also three types of Pan gesture, and the meaning of these types is very close to types of Touch. panstart panmove panend Swipe. Swipe is fired when user swipe a touch point on the screen. A serial of motion will only trigger one Swipe gesture. LongPress. Swipe is fired when a touch point is held for 500 ms or more. The Touch gesture and Pan is very close to each other, with following features hold: Touch. Not sampled, accuracy, but slow. Pan. Sampled, fast, less accuracy. Users may choose their gesture according to their situation. PropertiesThe following properties can be used in gesture callback: direction. Only exists for Swipe gesture. Indicate the direcion of the swipe, choose from up, left, bottom, right. changedTouches. An array of motion for every touch pointer that has contribute to the current gesture. changedToucheschangedTouches is an array, with the following properties in its children: identifier. A unique identifier for a touch pointer. pageX. The X coordinate of the touch pointer relative to the left edge of the document. pageY. The Y coordinate of the touch pointer relative to the top of the document. screenX. The X coordinate of the touch point relative to the left edge of the screen. screenY. The Y coordinate of the touch point relative to the top edge of the screen. ConstrainCurrently, Weex Android do not support listening to gesture on scroller, list and webview, as it would lead a large amount of event conflicting. How to useExample: &lt;template&gt;2&lt;div ontouchstart=\"handleTouchstart\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;2methods: &#123;22handleTouchstart: function(eventProperties) &#123;222// handling with the Event Properties22&#125;2&#125;&#125;&lt;/script&gt; With the code above, a touchstart event will be fired when a touch point is placed on the touch surface.","type":"references"},{"title":"Special Element","path":"references/special-element.html","permalink":"http://alibaba.github.io/references/special-element.html","text":"Special ElementContentThe element serves as content distribution outlet in a composed component template. The element itself will be replaced. alias: ‘slot’. ExampleAs shown in the example, ‘content’ replaced by ‘text’. &lt;we-element name=\"item\"&gt; &lt;template&gt; &lt;div&gt; &lt;content&gt;&lt;/content&gt; &lt;/div&gt; &lt;/template&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;item&gt; &lt;text&gt;Content Text&lt;/text&gt; &lt;/item&gt; &lt;/div&gt;&lt;/template&gt;","type":"references"},{"title":"Text Style","path":"references/text-style.html","permalink":"http://alibaba.github.io/references/text-style.html","text":"Text Style0.5 Text alike components share some common style rules. The text alike components currently includes text and input. Properties color: &lt;colors&gt; this property set the foreground color of an component’s text content. font-size: &lt;length&gt; this property specifies the size of the font. font-style: &lt;enum&gt; normal | italic. This property lets you select italic or normal faces within a font-family. Default value is normal. font-weight: &lt;enum&gt; normal | bold. This property specifies the boldness of the font. Default value is normal. text-decoration: &lt;enum&gt; none | underline | line-through. This property is used to set the text formatting to underline or line-through. The default value is none. text-align: &lt;enum&gt; left | center | right. This property describes how inline content like text is aligned in its parent component. The default value is left. font-family:&lt;string&gt; this property set the font-family of the text. This property doesn’t guarantee the given font will always be set to the text. If the specified font cannot be found at the device, a typeface fallback will occur and the default typeface will be load. The fallback mechanism may vary in different devices. text-overflow:&lt;string&gt; clip | ellipsis. This property determines how overflowed content that is not displayed is signaled to users. It can be clipped, display an ellipsis. The property color support multiple fomats of values, contains rgb, rgba, #fff, #ffffff, named-color. Example: .my-class &#123; color: red; &#125;.my-class &#123; color: #f00; &#125;.my-class &#123; color: #ff0000; &#125;.my-class &#123; color: rgb(255, 0, 0); &#125;.my-class &#123; color: rgba(255, 0, 0, 0.5); &#125; Type of Style Value length: number followed by length unit px, px can be omitted. colors: support multiple formats of values, including rgb (rgb(255, 0, 0)), rgba (rgba(255, 0, 0, 0.5)), hexadecimal (#ff0000), short hexadecimal (#f00), named color (red). enumerated values: a limited number of string values. Note: The list of color keywords.","type":"references"},{"title":"Devtools for Android","path":"tools/devtools-android.html","permalink":"http://alibaba.github.io/tools/devtools-android.html","text":"Devtools for Android Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page.At present The devtools consist of two part : Inspector and Debugger. If you want it work well, you must install a weex-devtool as debug server. InspectorInspector can be used to show your Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. DebuggerDebugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Install and launch devtools serverOpen your terminal then type npm install -g weex-toolkit and run.Launch it just type and run the command weex debug, then a Chrome web page will be opened. Use on an android device or emulatorTaste of first debug with playgroundIf you are a green hand to the debug of weex, we recommend you to try your first debug with playground, what you need to do is just launch the playground and scan the QR code shown in the debug page which wound opened if the devtools server have been launched. after you scan the QR code, the web page will list your connected devices. How Debugger WorksDevtools expands Chrome Debugging Protocol and the mechanism of communication between client and debug sever is based on JSON-RPC. Devtools ClientDevtools Client is integrated in App as aar, it connects to debug server through webscoket protocol with out permission check. I recommend you just packaged it in your debug version consider of the security mechanism. Devtools Debug ServerDevtools Debug Server is the center node of the communication, it connects to both app and chrome, acts as the turn server of debugging protocol messages and the manager of the js runtime. Chrome FrontEndChrome’s V8 engine acts as the javascript runtime, when debug mode is enabled, all the js code run on it. On the other side we also reuse most of the Chrome’s debugging user interface, such as set breakpoint, see call stack and so on. Enable devtools in your own appOf course you can reuse the code of playground to build your own app, that is the simplest way to let your app’s js code debuggable. On the other hand QR code is not necessary, if your review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. following those steps you can do the same thing. Gradle dependency on inspector.There are two choices to set the dependency, the Choice A is recommanded if you have no change to weex_sdk or inspector, while if you use your own custom weex_sdk or inspector Choice B is suitable. A - aar dependency from jcenter.dependencies &#123; compile &apos;com.taobao.android:weex_inspector:0.0.8.1&apos;&#125; I strongly recommend you use the latest version since both weex sdk and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. B - source code dependency. you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(&apos;:inspector&apos;)&#125; Version compatibility weex sdk weex inspector debug server 0.8.0.1+ 0.0.8.1 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 Initialize in your XXXApplication file. public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;/*&quot;DEBUG_SERVER_HOST&quot;*/); &#125; private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = &quot;ws://&quot; + host + &quot;:8088/debugProxy/native&quot;; &#125;&#125; Ship It! You must launch your bundle server firstly. In your weex dir, run command “./start”; Launch your remote debug server. Run command weex debug, chrome will open a web page show a simply guidance and QR code; Launch your app and make sure debug mode was enabled. You will see a device list in the chrome web page opened by last step, each device item have two button, Debugger and Inspector;There are two way to enable debug mode: scaning the QR code and handle the content just like the playground have done. init it in the XXXApplication by calling initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;), if you call initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;) after weex sdk inited, you need to call WXSDKEngine.reload() to refresh the runtime. Once you click the button Inspector chrome will open a page show the inspector view, on the other side, click the button Debugger chrome will open a new page to show the debug view; OPTIONS[OPTION] set your remote bundle server ip.For example, in the playground it is in the `IndexActivity.java`, you need to change the value of `DEFAULT_IP` in IndexActivity.java from `&quot;your_current_IP&quot;` to a server ip like `&quot;30.30.30.150&quot;`: private static final String DEFAULT_IP = &quot;30.30.30.150&quot;; // &quot;your_current_IP&quot;; [OPTION] enable network inspection.OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new OkHttpInterceptor()); Notice The network inspection only support OKHttpClient right now!!! If you want to use the network inspection to catch your bundle request, you must change your bundle server ip to the real server ip. Known Issues You can report issues and bugs here. We will reply as soon as possible.","type":"tools"},{"title":"Devtools for IOS","path":"tools/devtools-ios.html","permalink":"http://alibaba.github.io/tools/devtools-ios.html","text":"Devtools for IOSRemote debug for your native iOS app using Chrome Developer Tools weex-devtool launch： install and run weex-devtool $:npm install -g weex-devtool $:weex-devtool it will launch chrome browser, showing wss ip address in chrome address bar. playground install WXDevtool Install dependencies. $:pod install Usage AppDelegate.m header file #import &quot;WXDevTool.h&quot; Initialize inspector when the APP launched Note: The inspector API must be called before weex is initialized + (void)setDebug:(BOOL)isDebug; isDebug default is NO, now you open inspect model. opposite is YES, if you set isDebug to YES, then open debug model and inspect model. + (void)launchDevToolDebugWithUrl:(NSString *)url; wssip was the wss address showing in the chrome address bar. open debug model and inspector model eg：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } open inspect model, remove the @selector(setDebug:) or add [WXDevTool setDebug:NO] eg：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } Build and running APP, this time chrome will display your device with App name, select inspector to open the inspector tab. Log print support for different levels of print. eg: #import &quot;WXDevTool.h&quot; PDLogE()/PDLogW() WXDevtool DependenciesYour app must be linked against the following frameworks/dylibs libicucore.dylib CFNetwork.framework CoreData.framework Security.framework Foundation.framework","type":"tools"},{"title":"Devtools","path":"tools/devtools.html","permalink":"http://alibaba.github.io/tools/devtools.html","text":"DevtoolsWeex devtools is a custom devtools for weex that implements Chrome Debugging Protocol, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page, both Android and IOS platform are supported. Install$ npm install -g weex-toolkit usageweex debug [options] [we_file|bundles_dir] Options: -h, --help output usage information -V, --verbose display logs of debugger server -v, --version display version -p, --port [port] set debugger server port -e, --entry [entry] set the entry bundlejs path when you specific the bundle server root path -m, --mode [mode] set build mode [transformer|loader] -w, --watch watch we file changes auto build them and refresh debugger page![default enabled] start debugger$weex debug this command will start debug server and launch a chrome opening DeviceList page.this page will display a qrcode ,you can use Playground App scan it for starting debug. start debugger with a we file$weex debug your_weex.we this command will compile your_weex.we to your_weex.js and start the debug server as upon command.your_weex.js will deploy on the server and displayed in DeviceList page as another qrcode contain the url of your_weex.js start debugger with a directory of we files$weex debug your/we/path -e index.we this command will build every file in your/we/path and deploy them on the bundle server. your directory will mapping to http://localhost:port/weex/use -e to set the entry of these bundles. and the url of “index.we” will display on device list page as another qrcode. FeaturesConnect devices Inspector Inspector can be used to show your Element \\ Network \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. Elementnative view element weex dom element Networkshow the total time and latency show the header and response Console Resource Debugger Debugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Breakpoint and CallStack Integrate devtools Android See the doc Weex devtools (Android), it will lead you to config and use it step by step. IOS See the doc Weex devtools (IOS), it will lead you to config and use it step by step.","type":"tools"},{"title":"CLI","path":"tools/index.html","permalink":"http://alibaba.github.io/tools/index.html","text":"Weex-ToolkitPlease access npmjs.com for latest version Weex CLI tool set Pre Installsome dependencies need recent version of npm to install if your$ npm --version output less then 2.15.1, please run below cmd upgrade your npm at firstsudo npm install -g npm Install$npm install -g weex-toolkit Usage$weex foo/bar/input_path [options] $weex create file_name [options]Options: --qr display QR code for native runtime, **default action** -o,--output transform weex we file to JS Bundle, output path (single JS bundle file or dir) [for create sub cmd] it specified we file output path --watch using with -o , watch input path , auto run transform if change happen -s,--server start a http file server, weex .we file will be transforme to JS bundle on the server , specify local root path using the option --port http listening port number ,default is 8081 --wsport websocket listening port number ,default is 8082 -f, --force [for create sub cmd] force to replace exsisting file(s) --version show version of weex toolkit --help Show help Examplescrate a we file(weex source file) using standard template$weex create hello-world-weex a file named ‘hello-world-weex.we’ we be created in current directory transform a we file to JS Bundle$weex your_best_weex.we -o . your_best_weex.we will be transform to JS Bundle file your_best_weex.js , saved in your current directory transform a we file to JS Bundle , watch this file ，auto run transformer if change happen.$weex your_best_weex.we -o . --watch transform every we file in a directory$weex we/file/storage/path -o outputpath every we file in we/file/storage/path we be transform to JS Bundle , saved in outputpath path preview your we file using Weex Playground Appdownload &amp; install weex playground App$weex your_best_weex.we --qr a QR code will display in your terminal , using Playground App scan that. start http server$weex -s . a http server will start running , your current directory(.) will be the document root for the server , every weex .we file will be transforme to JS Bundle when access through the server Issue &amp; FeedbackGithub Issue List","type":"tools"},{"title":"Playground","path":"tools/playground.html","permalink":"http://alibaba.github.io/tools/playground.html","text":"Weex Playground AppOne of best parts of Weex is Native Runtime . After preview your we file render in H5 using weex-toolkit CLI , you can try Native Runtime in a standalone App , this is Weex Playground App . More then that ,Weex playground App preset a lot of Demo &amp; ShowCase ,so you will get to experience performance of Weex native runtime easily. Android and IOS version of Playground App can be downloaded here. Screenshot This is main interface of Weex Playground App , you can click the item to see the corresponding demo . click top right corner Icon will active QR scaner that work with Weex toolkit CLI please refer to Weex Tutorial","type":"tools"},{"title":"Transformer","path":"tools/transformer.html","permalink":"http://alibaba.github.io/tools/transformer.html","text":"gulp-weex gulp plugin for weex transformer Usagevar gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) OptionsoldFormatwhether transform to old format. default: false. isEntrywhether is an entry module which has bootstrap(...). default: true.","type":"tools"},{"title":"自定义 native 组件","path":"cn/advanced/customize-a-native-component.html","permalink":"http://alibaba.github.io/cn/advanced/customize-a-native-component.html","text":"如何自定义 native 组件？Weex 已经包含了最关键的平台组件，例如 ScrollView, ListView, Text, Imageview 等等。当然，这些组件并不能完全满足你的需求。另外，那些在你的工程中常用的大量原生 UI 组件，可能需要被简单地集合到 Weex 中。幸运的是，通过任意已存在的组件来创建你的自定义组件是一件很方便的事。 Android步骤：1.自定义组件必须继承自 WXComponent 或者 WXContainer ；2.weex SDK 可以识别 @WXComponentProp (name = value(value 是 attr 或者 dsl style))；3.方法必须是 public 的；4.组件类不能是一个内部类；5.自定义组件不能被 ProGuard 之类的工具混淆；6.组件方法在 UI 线程被调用，因此不要在里面进行耗时的操作；7.Weex 的参数类型可以是 int, double, float, String, Map, List 和实现了 WXObject 接口的自定义类； 参考以下例子： `package com.taobao.weex.ui.component;// ……public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject node, WXVContainer parent, String instanceId, boolean lazy) &#123; super(instance, node, parent, instanceId, lazy); &#125; @Override protected void initView() &#123; //TODO:your own code …… &#125; @Override public WXFrameLayout getView() &#123; //TODO:your own code ……… &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; 必须注册组件： WXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class); iOS虽然 WeexSDK 中有很多的 native 的 Component，但这有可能并不能满足你的需求。在之前你可能已经写了一些很酷炫 native 的组件，想包装一下，导入到 Weex 中，因此我们提供了让开发者实现自己的 native Component。下面将以 WeexSDK 中已经存在的 Component：image 为例子，介绍一下如何构建一个 native Component。假设你已经了解 iOS 开发 注册 Component注册一个 component 比较简单，调用 WXSDKEngine 中的 registerComponent:withClass: 方法，传入组件的标签名称，还有对应的 class 然后你可以创建一个 WXImageComponent 表示 image 组件的实现。在 .we 文件中，只需要写 &lt;image&gt;&lt;/image&gt; 添加属性现在我们要做一些让 image component 更加强大的事情。既然作为一个图片的 component，那它应该要有源，给他加上一个 src 的属性，同时给它加上一个 resize 的属性（可以配置的有 contain/cover/stretch） @interface WXImageComponent ()@property (nonatomic, strong) NSString *imageSrc;@property (nonatomic, assign) UIViewContentMode resizeMode;@end component 中所有的 style，attribute，events 都会被传递到 Component 的初始化方法中，所以，你可以在初始化方法中存储你感兴趣的一些属性值 @implementation WXImageComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]];&#125; return self;&#125;@end attribute 中拿到的值的类型都是 id，我们可以用转换方法把它转换到任何值。Weex SDK 提供了一些基础的转换方法，可以参考 WXConvert 类，或者你可以添加自己的转换函数。 Hooking 渲染生命周期native 的 component 是由 Weex 管理的，Weex 创建，布局，渲染，销毁。Weex 的 component 生命周期都是可以 hook 的，你可以在这些生命周期中去做自己的事情。 方法 描述 initWithRef:type:… 用给定的属性初始化一个component. layoutDidFinish 在component完成布局时候会调用. loadView 创建component管理的view. viewWillLoad 在component的view加载之前会调用. viewDidLoad 在component的view加载完之后调用. viewWillUnload 在component的view被释放之前调用. viewDidUnload 在component的view被释放之后调用. updateStyles: 在component的style更新时候调用. updateAttributes: 在component的attribute更新时候调用. addEvent: 给component添加event的时候调用. removeEvent: 在event移除的时候调用. 在 image component 的例子里面，如果我们需要我们自己的 image view 的话，可以复写 loadView这个方法. - (UIView *)loadView&#123;return [[WXImageView alloc] init];&#125; 现在我们使用 WXImageView 渲染 image component。作为一个 image component，我们需要拿到服务器图片，而且把它设置进 image view 里. 这个操作可以在 viewDidLoad 方法中做，这个方法是在 view 已经被创建而且加载了时候 Weex SDK 会调用到，而且 viewDidLoad 这个方法是你做额外初始化工作比如改变 content mode(也就是设置resize) 的最好时间. - (void)viewDidLoad&#123; UIImageView *imageView = (UIImageView *)self.view; imageView.contentMode = _resizeMode; imageView.userInteractionEnabled = YES; imageView.clipsToBounds = YES; imageView.exclusiveTouch = YES; // Do your image fetching and updating logic&#125; 如果可以改变 image 的 src，也可以 hook updateAttributes: 方法来做属性更新操作，当 updateAttributes: 或者 updateStyles: 被调用的时候， component 的 view 已经加载完成 - (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;src&quot;]) &#123; _imageSrc = [WXConvert NSString:attributes[@&quot;src&quot;]]; // Do your image updating logic &#125; if (attributes[@&quot;resize&quot;]) &#123; _resizeMode = [WXConvert UIViewContentMode:attributes[@&quot;resize&quot;]]; self.view.contentMode = _resizeMode; &#125;&#125; 或许你需要考虑更多的生命周期方法去 Hook，当布局完成时候，像 layoutDidFinish，如果你想了解更多，可以参考一下WXComponent.h 声明的方法。 现在你可以用在任何 .we 文件里面使用 &lt;image&gt;，而且可以加上 image 的属性。 &lt;image style=\"your-custom-style\" src=\"image-remote-source\" resize=\"contain/cover/stretch\"&gt;&lt;/image&gt;","type":"advanced"},{"title":"如何创建一个 Weex 项目","path":"cn/advanced/create-a-weex-project.html","permalink":"http://alibaba.github.io/cn/advanced/create-a-weex-project.html","text":"如何创建一个 Weex 项目对于前端开发者来说开发一个 app 是不容易的，既然 Weex 能以 web 的开发体验构建高性能、可扩展的 native 应用，那我们怎么利用 Weex 简单高效的开发一个 native 应用呢？Weex 替你考虑了这件事。在本章中，我们将学习如何使用 Weexpack 工具快速生成一个全新的 Weex 项目。 根据你的操作系统的不同，步骤也略有差异，如果你从未接触过 native 开发，请慢慢来，遇到问题随时查阅 FAQ。 首先，不论任何平台，我们都需要 node.js 和 Weexpack。在本节中，默认你已经安装好了 node.js 和 npm，如有疑问，可参考上一章 如何在本地开发 Weex 页面。 Weexpack 是 Weex 新一代的工程开发套件，它允许开发者通过简单的命令，创建 weex 工程项目，将项目运行在不同的开发平台上。未来，我们考虑会将其集成在 weex-toolkits 上，但目前仍需要单独安装。好在安装 Weexpack 非常简单，可以直接使用 npm 安装： npm install weexpack -g 或者用 cnpm： cnpm install weexpack -g 接下来的步骤会有一些复杂和区别，根据开发平台的不同，我们提供了快速导航便于阅读： iOS Android iOSMac 是唯一可以开发 iOS 应用的平台，因此创建 iOS 项目只支持 mac。对于 iOS，你需要安装 Xcode 和 CocoaPods 。 安装 Xcode 最简单的方法是到 Mac App Store。Xcode 体积较大，下载请耐心等待。 安装好 Xcode 后，你需要运行 Xcode，使 Xcode 自动安装开发者工具和确认使用协议。 之后你还需要安装 CocoaPods 。CocoaPods 是 Xcode 项目的类库管理工具，可以使用如下命令安装： $ sudo gem install cocoapods 如果执行该命令无反应，很可能是 gem source 问题，你可以切换为淘宝 gem source： $ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ sudo gem install cocoapods 如有问题，可参考 CocoaPods 官方文档 创建项目然后，就可以使用 weexpack 创建 weex 工程了： $ weexpack init appName weexpack 会自动新建以 appName 命名的目录，并将项目模板拉取到该目录。 最终形成如下目录结构： -&gt; /appName.|—— .gitignore|—— README.md|—— package.json|-- android.config.json|-- ios.config.json|—— webpack.config.js|—— /src| |—— index.we|—— /html5| |—— index.html|—— /ios| |—— /playground| |—— /sdk| |—— /WXDevtool|—— /android| |—— /playground| |—— /appframework 其中： webpack.config.js 是 webpack 配置文件，用于生成 .we 文件的 JSBunlde ios.config.json 是 iOS 项目配置文件 android.config.json 是 Android 项目配置文件 /src 目录放置 Weex 页面 /html5 是 H5 端入口文件 /ios 放置 iOS 项目 /android 放置 Android 项目 紧接着，进入目录，并且安装依赖： $ cd appName &amp;&amp; npm install 至此，项目模版创建完成，接下来我们可以自定义我们的 APP 信息并打包运行。 运行与打包如果一切正常，你可以使用 weexpack 打包或模拟器运行了： 模拟器运行 $ weexpack run ios 构建 ipa 包： $ weexpack build ios 构建包的过程中，将会提示让您输入 CodeSign（证书）、Profile(provisioning profile)、AppId，只有输入真实的这些信息才能成功打包。 其余如AppName，和入口 weex bundle 文件可以编辑项目目录下的 ios.config.json 配置。 打完包成功之后，可以在 /playground/build/ipa_build/ 目录下获取 ipa 文件。 注：证书需要预先安装到 keychain 中，在 keychain 中点击右键获取证书 id（证书名称）、provisioning profile 文件（*mobileprovision）需要获取 UUID，进入目录可以看到 mobileprovision_UUID.sh 文件，此文件可以获取到 UUID。 mobileprovision_UUID.sh 用法如下： $ ./mobileprovision_UUID.sh *mobileprovision 参数（*mobileprovision）为 provisioning profile 文件路径 注：run 与 build 部分涉及 pod 的依赖安装问题。 首先要安装 cocoapods ，具体安装步骤可查看这里，建议安装 0.39.0 版本。 为了加快 CLI 执行速度，weexpack 创建的工程默认安装了需要的依赖库。但是命令执行依然会更新需要升级的依赖库。 如果出现这种错误提示 unable to find a specification for &#39;WeexSDK&#39; 这种错误，说明你本地没有更新 cocoapods master 仓库，运行 pod repo update ，此时运行 pod search WeexSDK： 说明 master repo 更新成功。以上是以 WeexSDK 为例，其他库类似。 如果出现这种错误 error: The sandbox is not in sync with the Podfile.lock. Run &#39;pod install&#39; or update your CocoaPods installation. 进入 playground 目录（podfile 文件所在目录）按提示执行。 更多 pod 使用细节请移步cocoapods mobileprovision，参数（*mobileprovision）为 provisioning profile 文件路径。 Android在 Mac 平台开发 Android 首先需要下载 Android Studio（你可能需要翻墙才能访问）。Android Studio 为我们提供了 Android SDK 及 AVD（模拟器）以便我们快速运行 Android 项目。 下载完成后运行 Android Studio，任意新建一个 Android 项目，在第二步中选择 Android 5.1，然后点击 next 完成项目创建，如图所示： 待 Android Studio 打开后，在顶部菜单栏选择 Tools -&gt; Android -&gt; AVD Manager，安装 Android 模拟器： 之后，打开模拟器运行 Android。 注意： 必须保持模拟器运行。 保证 Android build-tool 的版本为 23.0。【可以在 Android Studio 的 SDK Manager 里查看是否已安装这个版本，如果没有可选择安装这一版本】。 配置环境变量因为 Android Studio 安装的 SDK 不会自动配置环境变量（你自己安装的 SDK 同样不会）。所以需要您自己手动配置 Android_HOME 环境变量和 PATH 如果是 Android Studio 安装的 SDK 安装路径可已在 SDK manager 里找到（打开 SDK manager 的方式请参照图2） Windows 下请参照 window 下如何设置 ANDROID 环境变量 Linux/Mac 下只需编辑 .bash_profile 增加 PATH 即可： vim ~/.bash_profile 然后添加下列代码进去（路径替换为你的真实路径） export ANDROID_HOME=/xxx/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools 然后保存退出（:wq）。再执行下列命令： source ~/.bash_profile 创建项目然后，就可以使用 weexpack 创建 weex 工程了： $ weexpack init appName weexpack 会自动新建以 appName 命名的目录，并将项目模板拉取到该目录。 最终形成如下目录结构： -&gt; /appName.|—— .gitignore|—— README.md|—— package.json|-- android.config.json|-- ios.config.json|—— webpack.config.js|—— /src| |—— index.we|—— /html5| |—— index.html|—— /ios| |—— /playground| |—— /sdk| |—— /WXDevtool|—— /android| |—— /playground| |—— /appframework 其中： webpack.config.js 是 webpack 配置文件，用于生成 .we 文件的 JSBunlde ios.config.json 是 iOS 项目配置文件 android.config.json 是 Android 项目配置文件 /src 目录放置 Weex 页面 /html5 是 H5 端入口文件 /ios 放置 iOS 项目 /android 放置 Android 项目 紧接着，进入目录，并且安装依赖： $ cd appName &amp;&amp; npm install 至此，项目模版创建完成，接下来我们可以自定义我们的 APP 信息并打包运行。 运行与打包如果一切正常，你可以使用 weexpack 打包或模拟器运行了： Android 的打包和构建是一体的 ： $ weexpack run android 同样的你可以更改项目目录下的android.config.json AppName: 应用名 AppId: application_id 包名 SplashText: 欢迎页上面的文字 WeexBundle: 指定的 weex bundle 文件（支持文件名和 url 的形式） 指定文件名则以本地文件的方式加载 bundle，指定 url 则以远程的方式加载 JSBundle。如果以本地方式指定 bundle .we 文件请放到 src 目录。","type":"advanced"},{"title":"自定义 native API","path":"cn/advanced/cuszomize-native-apis.html","permalink":"http://alibaba.github.io/cn/advanced/cuszomize-native-apis.html","text":"如何自定义 native API？Weex 的 SDK 只提供了页面渲染的能力，但是一些其它操作，比如网络请求、图片加载、重定向等功能需要你自己去实现，这个例子讲述了如何用原生代码去扩展 Weex 的功能。 关于 URLHelper 的例子新建一个 WXModulepublic class URLHelperModule extends WXModule&#123; private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\"; @WXModuleAnno public void openURL(String url)&#123; if (TextUtils.isEmpty(url)) &#123; return; &#125; StringBuilder builder=new StringBuilder(\"http:\"); builder.append(url); Uri uri = Uri.parse(builder.toString()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.addCategory(WEEX_CATEGORY); mWXSDKInstance.getContext().startActivity(intent); &#125;&#125; 这里要注意 @WXModuleAnno 这个注解，它表示了你把这个方法暴露给 JavaScript。 public class URLHelperModule extends WXModule&#123; @WXModuleAnno public void openURL(String url,String callbackId)&#123; //... //callback to javascript Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(\"ts\", System.currentTimeMillis()); WXBridgeManager.getInstance().callback(mWXSDKInstance.getInstanceId(), callbackId, result); &#125;&#125; 把module注册到WXSDKEngine：try &#123; WXSDKEngine.registerModule(\"myURL\", URLHelperModule.class); //'myURL' is the name you'll use in javascript &#125; catch (WXException e) &#123; WXLogUtils.e(e.getMessage()); &#125; 在 JavaScript 中使用 eventModule：let URLHelper = require('@weex-module/myURL');//same as you registeredURLHelper.openURL(\"http://www.taobao.com\",function(ts)&#123; console.log(\"url is open at \"+ts);&#125;); 一些注意事项： 定义一个 components 需要继承 WXModule 不要忘记添加 @WXModuleAnno 注解，不然 Weex 没法识别这个方法 定义的方法必须是 `public 的 module 类一定不能是内部类 你定义的 components 不能被混淆，不然会找不到 Module 中的方法会在 UI 线程中被调用，所以一定不要做一些耗时操作 Moudle 中的方法参数类型可以为 int，double，float，String，Map，List，以及实现 WXObject 接口的类。","type":"advanced"},{"title":"Android 扩展","path":"cn/advanced/extend-to-android.html","permalink":"http://alibaba.github.io/cn/advanced/extend-to-android.html","text":"Android 扩展Weex 提供了扩展机制，可以根据自己的业务进行定制自己的功能。主要分为两类扩展： Module 扩展 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展 Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。 Module 扩展 Module 扩展必须继承 WXModule 类。 扩展方法必须加上 @WXModuleAnno 注解。Weex 会根据注解来判断当前方法是否要运行在 UI 线程，和当前方法是否是扩展方法。 Weex是根据反射来进行调用 Module 扩展方法，所以Module中的扩展方法必须是 public 类型。 同样因为是通过反射调用，Module 不能被混淆。请在混淆文件中添加代码：-keep public class * extends com.taobao.weex.common.WXModule{*;} Module 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Module 后一定要在初始化时注册 WXSDKEngine.registerModule(&quot;myModule&quot;, MyModule.class); 否则会报类似错误：ReportException :undefined:9: TypeError: Object #&lt;Object&gt; has no method &#39;printLog&#39; 示例如下： public class MyModule extends WXModule &#123; @WXModuleAnno(runOnUIThread = true) public void printLog(String msg) &#123; Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show(); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"click\"&gt;点击我测试&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; click: function() &#123; require('@weex-module/myModule').printLog(\"我是一个测试!\"); &#125; &#125; &#125;&lt;/script&gt; Component 扩展 Component 扩展类必须集成 WXComponent. Component 对应的设置属性的方法必须添加注解 @WXComponentProp(name=value(value is attr or style of dsl)) Weex sdk 通过反射调用对应的方法，所以 Component 对应的属性方法必须是 public，并且不能被混淆。请在混淆文件中添加代码 -keep public class * extends com.taobao.weex.ui.component.WXComponent{*;} Component 扩展的方法可以使用 int, double, float, String, Map, List 类型的参数 完成 Component 后一定要在初始化时注册 WXSDKEngine.registerComponent(&quot;richtext&quot;,RichText.class); 示例如下: public class RichText extends WXComponent &#123; public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent, boolean isLazy) &#123; super(instance, dom, parent, isLazy); &#125; @Override protected void initView() &#123; mHost=new TextView(mContext); ((TextView)mHost).setMovementMethod(LinkMovementMethod.getInstance()); &#125; @WXComponentProp(name = \"tel\") public void setTelLink(String tel)&#123; SpannableString spannable=new SpannableString(tel); spannable.setSpan(new URLSpan(\"tel:\"+tel),0,tel.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); ((TextView)mHost).setText(spannable); &#125;&#125; JS 调用如下： &lt;template&gt; &lt;div&gt; &lt;richText tel=\"12305\" style=\"width:200;height:100\"&gt;12305&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; Adapter扩展图片下载： 需要时集成接口 IWXImgLoaderAdapter，实现 setImage 方法。 示例如下： public class ImageAdapter implements IWXImgLoaderAdapter &#123; public ImageAdapter() &#123; &#125; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(view==null||view.getLayoutParams()==null)&#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith(\"//\")) &#123; temp = \"http:\" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; Picasso.with(WXEnvironment.getApplication()) .load(temp) .into(view); &#125; &#125;,0); &#125;&#125; 注:工程要添加依赖 compile &#39;com.squareup.picasso:picasso:2.5.2&#39;","type":"advanced"},{"title":"weex-html5 扩展","path":"cn/advanced/extend-to-html5.html","permalink":"http://alibaba.github.io/cn/advanced/extend-to-html5.html","text":"扩展 weex-html5简介Weex 是一个高可扩展性的跨平台动态化开发方案，你可以在现有组件基础上定制自己需要的三端组件。你可以为 Weex API 模块添加新的方法，或者创建新的 API 模块和新的加载器。按照以下几个步骤扩展你的组件，API 或者加载器。 首先要明确的是，组件和 API 模块是基于 Weex 的扩展，但是独立于 Weex，组件的定义本身是不需要依赖于 Weex 的，这样有助于组件的分散化管理，去除中心化依赖。 其次，当你扩展一个组件，你需要同时扩展三端的组件（android, ios 和 web 端），毕竟 Weex 是一个重视三端一致体验的跨平台移动框架。你可以一个端一个端的扩展，也可以召唤其他端上的开发者来共同完成你在其他端上的组件（你总是可以在社区找到对某个功能有共同需求的开发者）。这里有一些在 android 端和 ios 端做扩展的文档可以参考。 你应该将你的扩展发布到 Weex 开发者可以方便找到和使用的渠道，比如 npm。我们推荐你将你开发的组件发布到 npm 供其他 Weex 开发者使用。 最重要的是，你的组件的命名需要遵守 Weex 组件命名规范：以 weex- 开头作为组件的前缀，并且以 -&lt;platform&gt; 做为结尾后缀，除非你发布的包是三端的实现都包含在内的。这里有个 &lt;weex-hello-web&gt; 的例子作为参考，这里注册了一个简单的自定义的组件。 创建新组件步骤: 在你的组件实现中必须继承 Weex.Component 这个类, 并选择性的重写其中的一些方法。 你的组件的 exports 需要暴露一个 init 方法，并在其中使用 Weex.registerComponent 注册你的组件。 这里用一个例子展示如何扩展一个新的组件 看这个组件扩展的代码( web 端上的组件)： const attr = &#123; // ...&#125;const style = &#123; // ...&#125;const event = &#123; // ...&#125;// 每个扩展组件都需要实现一个init方法，Weex会通过这方法进行安装和注册.function init (Weex) &#123; const Component = Weex.Component const extend = Weex.utils.extend // 组件的构造函数 function Hello (data) &#123; Component.call(this, data) &#125; // prototype继承 Hello.prototype = Object.create(Component.prototype) extend(Hello.prototype, proto) // 配置属性、样式以及事件 extend(Hello.prototype, &#123; attr &#125;) extend(Hello.prototype, &#123; style: extend(Object.create(Component.prototype.style), style) &#125;) extend(Hello.prototype, &#123; event &#125;) Weex.registerComponent('weex-hello', Hello)&#125;// 暴露init方法接口.export default &#123; init &#125; 上述代码摘引自 weex-hello-web/src/index.js 这个demo重写了基类 Component中的create方法。你也可以选择重写Component中的一些其他方法来定制组件的行为。典型的方法包括： create: 创建组件的节点，在方法体中return这个节点. createChildren 创建子节点. insertBefore 在某个子节点之前插入一个新的子节点. appendChild 在子节点列表的最后加上一个节点. removeChild 移除一个子节点. 进阶：更多关于组件定制和扩展的细节和代码展示，可以参考 weex 主仓库的代码，这里的组件基本上都是通过上述方式进行定义的。 重要的一点，注册组件的关键方法是 Weex.registerComponent，如示例里的 weex-hello 组件的注册： Weex.registerComponent('weex-hello', Hello) 上述代码引自 weex-hello-web/src/index.js 在某个需要使用该组件的weex项目中使用 Weex.install 方法安装该组件： // import the original weex-html5.import weex from 'weex-html5'import hello from 'weex-hello-web'// install the component.weex.install(hello) 上述代码引自 weex_extend_demo/src/main.js 在你的 .we 文件中直接使用这个组件： &lt;template&gt; &lt;div&gt; &lt;weex-hello class=\"hello\" style=\"txt-color:#fff;bg-color:green\" value=\"WEEX\" onclick=\"handleClick\"&gt; &lt;/weex-hello&gt; &lt;/div&gt;&lt;/template&gt; 上述代码引自weex_extend_demo/demo/index.we 扩展API你可以扩展新的 API 模块，或者为某个已有的模块添加新的 API. 比如，你可以添加一个 API 模块叫做 user，在里面添加一些用户登录登出处理的 API，比如 login, logout 等等。你可以通过 require(&#39;@weex-module/moduleName)[methodName](arg1, arg2, ...) (Module APIs) 的方式调用你的 API. 步骤: 实现你的 API module. 在你的 API 安装模块里暴露一个 init 方法，并在这个方法里面使用 Weex.registerAPIModules 注册你的 API module. 这里用一个例子展示如何扩展一个新的 API 模块 创建一个文件 user.js，在其中定义登录登出 login/logout 方法. const user = &#123; // 定义用户登录方法. login (callbackId) &#123; login.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;, // 定义用户登出方法. logout (callbackId) &#123; logout.then(res =&gt; &#123; this.sender.performCallback(callbackId, res) &#125;).catch(err =&gt; &#123; this.sender.performCallback(callbackId, err) &#125;) &#125;&#125;// 定义user模块的元 (meta) 信息.const meta = &#123; user: [&#123; name: 'login', args: ['function'] &#125;, &#123; name: 'logout', args: ['function'] &#125;]&#125;export default &#123; init (Weex) &#123; // 注册这个模块，最后一个参数是模块的元信息. Weex.registerApiModule('user', user, meta) &#125;&#125; 这个简单的 user helper 模块就实现好了，可以发布到 npm 上，我们可以给这个模块取个名字，比如说 weex-user-helper。 在你的新的 Weex 项目里安装这个模块: import Weex from 'weex-html5'import user from 'weex-user-helper'Weex.install(user) 安装了这个模块，你就可以在 DSL 代码里引用这个模块干点事情了: &lt;template&gt; &lt;div&gt; &lt;div class=\"btn\" onclick=\"handleClick\"&gt; &lt;text&gt;LOGIN&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var userHelper = require('@weex-module/user') module.exports = &#123; methods: &#123; handleClick: function () &#123; userHelper.login(function () &#123; // ... do sth. in callback. &#125;) &#125; &#125; &#125;&lt;/script&gt; 定制加载器loaderLoader仅用于weex-html5 (web端)加载dsl打包出来的bundle代码，native平台有其他的加载机制 已有的加载器包括 xhr, jsonp 和 source. 你可以使用 weex.registerLoader 注册一个新的加载器。例如，你有一个获取 Weex bundle 的服务 myServe.getWeexBundle , 通过这个服务可以加载 weex bundle，为此你可以定义一个加载器： function loadByMyServe(pageId, callback) &#123; myServe.getWeexBundle(pageId).then(function (bundle) &#123; callback(bundle) &#125;).catch(function(err) &#123; callback(err) &#125;)&#125;// 暴露init方法用于Weex安装此加载器.export default &#123; init (Weex) &#123; Weex.registerLoader('myserve', loadByMyServe) &#125;&#125; 在你的 weex-html5 项目的启动文件里安装并使用这个加载器： import Weex from 'weex-html5'// 或者import from './myserve.js'，不管是import一个npm模块还是import一个文件.import loader from 'myLoader'Weex.install(loader)// 在init方法里使用这个加载器加载bundle文件.(function () &#123; function getUrlParam (key) &#123; const reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') const match = location.search.match(reg) return match &amp;&amp; match[1] &#125; const page = getUrlParam('page') || 'examples/build/index.js' Weex.init(&#123; appId: location.href, loader: 'myserve', // 使用刚才定义的loader类型 source: page, rootId: 'weex' &#125;)&#125;)(); 以上是 Weex 带来的扩展性里比较主要的一部分，更多实现细节可以在 weex 项目代码库以及 weex 的开源社区里找到。","type":"advanced"},{"title":"iOS 扩展","path":"cn/advanced/extend-to-ios.html","permalink":"http://alibaba.github.io/cn/advanced/extend-to-ios.html","text":"iOS 扩展Module 扩展swift 扩展 module Weex SDK 只提供渲染，而不是其他的能力，如果你需要 像网络，图片，URL跳转这些特性，需要自己动手实现他们例如，如果你想实现一个url地址跳转函数，你可以按照如下步骤实现一个 Module 自定义module的步骤 自定义的module类 必须实现 WXModuleProtocol 必须添加宏WX_EXPORT_METHOD, 它可以被weex识别，它的参数是 JavaScript调用 module指定方法的参数 添加@synthesized weexInstance，每个moudle对象被绑定到一个指定的实例上 Module 方法会在UI线程中被调用，所以不要做太多耗时的任务在这里，如果要在其他线程执行整个module 方法，需要实现WXModuleProtocol中- (NSThread *)targetExecuteThread的方法，这样，分发到这个module的任务会在指定的线程中运行 Weex 的参数可以是 String 或者Map Module 支持返回值给 JavaScript中的回调，回调的类型是WXModuleCallback,回调的参数可以是String或者Map @implementation WXEventModule@synthesize weexInstance; WX_EXPORT_METHOD(@selector(openURL:callback))- (void)openURL:(NSString *)url callback:(WXModuleCallback)callback&#123; NSString *newURL = url; if ([url hasPrefix:@&quot;//&quot;]) &#123; newURL = [NSString stringWithFormat:@&quot;http:%@&quot;, url]; &#125; else if (![url hasPrefix:@&quot;http&quot;]) &#123; newURL = [NSURL URLWithString:url relativeToURL:weexInstance.scriptURL].absoluteString; &#125; UIViewController *controller = [[WXDemoViewController alloc] init]; ((WXDemoViewController *)controller).url = [NSURL URLWithString:newURL]; [[weexInstance.viewController navigationController] pushViewController:controller animated:YES]; callback(@&#123;@&quot;result&quot;:@&quot;success&quot;&#125;);&#125;@end Register the module通过调用 WXSDKEngine 中的 registerModule:withClass方法来注册自己的module WXSDKEngine.h/*** @abstract Registers a module for a given name* @param name The module name to register* @param clazz The module class to register**/+ (void)registerModule:(NSString *)name withClass:(Class)clazz;[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; 使用自己的module 这里的 require 里面的event 就是在 上一步调用registerModule: 注册module 时候的name var eventModule = require('@weex-module/event'); eventModule.openURL('url',function(ret) &#123; nativeLog(ret);&#125;); Weex SDK没有 图片下载，navigation 操作的能力，请大家自己实现这些 protocol WXImgLoaderProtocol weexSDK 没有图片下载的能力，需要实现 WXImgLoaderProtocol,参考下面的例子 WXImageLoaderProtocol.h@protocol WXImgLoaderProtocol &lt;WXModuleProtocol&gt;/** * @abstract Creates a image download handler with a given URL * @param imageUrl The URL of the image to download * @param imageFrame The frame of the image you want to set * @param options : The options to be used for this download * @param completedBlock : A block called once the download is completed. image : the image which has been download to local. error : the error which has happened in download. finished : a Boolean value indicating whether download action has finished.*/-(id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)options completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock;@end 实现上述协议 @implementation WXImgLoaderDefaultImpl#pragma mark -#pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;//&quot;]) &#123; url = [@&quot;http:&quot; stringByAppendingString:url]; &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end handler注册 你可以通过WXSDKEngine 中的 registerHandler:withProtocol注册handler WXSDKEngine.h/*** @abstract Registers a handler for a given handler instance and specific protocol* @param handler The handler instance to register* @param protocol The protocol to confirm*/+ (void)registerHandler:(id)handler withProtocol:(Protocol *)protocol;[WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]","type":"advanced"},{"title":"数据绑定原理","path":"cn/advanced/how-data-binding-works.html","permalink":"http://alibaba.github.io/cn/advanced/how-data-binding-works.html","text":"数据绑定实现原理Weex 的 JS Framework 是一个 MVVM，即 Model-View-ViewModel 框架。他会自动监听数据的变化，并通过 {{字段名}} 的语法把数据和视图中所展示的内容自动绑定起来。当数据被改写的时候，视图会自动根据数据的变化而发生相应的变化。 比如下面这个例子，&lt;text&gt; 的内容被绑定在了 notes 数据字段上： &lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;notes&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;template&gt;&lt;script&gt; module.exports = &#123; data: &#123; notes: 'Hello' &#125; &#125;&lt;/script&gt; Weex 的 JS Framework 会首先对 data 里的数据进行监听，这样未来的数据变化都能够被监听到。然后我们会编译整个 &lt;template&gt; 标签里的内容。当我们找到 &lt;text&gt; 标签里的 {{notes}} 时，JS Framework 会跟踪 data.notes 的变化并在其发生变化时触发一个句柄，将 &lt;text&gt; 的内容设置为 data.notes 最新的值。这样的话开发者就不必手动关心数据和视图之间的数据同步问题了。 在这个基础上我们还设计了一些特殊的语法： &lt;foo if=&quot;...&quot;&gt; 代表一个条件监听，当其值为 true 时，&lt;foo&gt; 元素将会被创建和载入，反之则不会被创建或被移除掉。 &lt;foo repeat=&quot;...&quot;&gt; 代表一个列表监听，第一次加载的时候 &lt;foo&gt; 元素会被按照数组里的数据逐条 clone 并赋值。而当有列表项增加、移动或移除时，视图层也会自动触发相应的改变，并且智能优化至最小变更策略 &lt;foo if=&quot;...&quot; repeat=&quot;...&quot;&gt; 两个特殊语法共用时，将会优先展开 repeat 然后逐条判断 if。 相比于一些 virtual-DOM 的 diff 计算机制，我们会直接对数据进行 diff，而且只会 diff 由于用户操作或数据操作发生改变的那部分数据和视图，这是一种更小范围的计算方式。尤其在追求轻量快速的移动端界面上，这种更新机制更加显得具有优势。","type":"advanced"},{"title":"Weex 工作原理","path":"cn/advanced/index.html","permalink":"http://alibaba.github.io/cn/advanced/index.html","text":"Weex 工作原理概述总览Weex是跨平台，可扩展的动态化技术. 你能通过在Weex源码中写&lt;template&gt;, &lt;style&gt; 和 &lt;script&gt;标签，然后把这些标签转换为JS Bundle用于部署, 在服务端以这些JS Bundle响应请求. 当客户端接收到JS Bundle时，它能用被客户端中的JS引擎用于管理Native渲染;API调用和用户交互. 工作流Weex we 文件 --------------前端(we源码)↓ (转换) ------------------前端(构建过程)JS Bundle -----------------前端(JS Bundle代码)↓ (部署) ------------------服务器在服务器上的JS bundle ----服务器↓ (编译) ------------------ 客户端(JS引擎)虚拟 DOM 树 --------------- 客户端(Weex JS Framework)↓ (渲染) ------------------ 客户端(渲染引擎)Native视图 --------------- 客户端(渲染引擎) 在上面的工作流中，我们提到: Transformer（转换器): 一个Node JS工具， 转换Weex源码为JS Bundle Weex JS Framework(JS框架): 运行于客户端的的JS框架，管理着Weex实例的运行。Weex实例由JS Bundle创建并构建起虚拟DOM树. 另外，它发送/接受 Native 渲染层产生的系统调用，从而间接的响应用户交互。 Native引擎: 在不同的端上，有着不同的实现: iOS/Android/HTML5. 他们有着共同的组件设计, 模块API 和渲染效果. 所以他们能配合同样的 JS Framework 和 JS Bundle工作。 转换器转换器转换Weex源码为JS Bundle. 整体工作可以分为三个部分: 转换 &lt;template&gt; 为类JSON的树状数据结构, 转换数据绑定为返回数据的函数原型.例如. For example: &lt;foo a=&quot;{{x}}&quot; b=&quot;1&quot; /&gt; 将转换为 {type: &quot;foo&quot;, attr: {a: function () {return this.x}, b: 1}}. 转换 &lt;style&gt; 为类JSON的树状数据结构. 例如: .classname {name: value;} 将转换为 {classname: {name: value}}. 把上面两部分的内容和 &lt;script&gt; 中的内容结合. 上面的三个部分将结合成一个JavaScript AMD 模块. 一个完整的例子: &lt;template&gt; &lt;foo a=\"&#123;&#123;x&#125;&#125;\" b=\"1\" class=\"bar\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;style&gt; .bar &#123;width: 200; height: 200&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;x: 100&#125; &#125; &#125;&lt;/script&gt; 将转换为: define('@weex-component/main', function () &#123; module.exports = &#123; data: function () &#123; return &#123;x: 100&#125; &#125; &#125; module.template = &#123; type: \"foo\", attr: &#123; a: function () &#123;return this.x&#125;, b: 1, classname: ['bar'] &#125; &#125; module.style = &#123; bar: &#123;width: 200, height: 200&#125; &#125;&#125;)bootstrap('@weex-component/main') 除此之外,转换器还会做一些额外的事情: 合并Bundle ,添加引导函数，配置外部数据等等，更详细的，请参阅Synatax章节. 注意当前大部分Weex工具最终输出的JS Bundle格式都经过了Webpack的二次处理，所以你实际使用工具输出的JS Bundle会和上面的有所区别. JS FrameworkJS Framework 在初始化阶段被原生 JavaScript 引擎运行. 它提供被每个JS Bundle调用的 define() 和 bootstrap() 函数. 一旦JS Bundle从服务器下载后，这些函数就会执行. define() 函数以注册模块;bootstrap()会编译主要的模块为虚拟DOM，并发送渲染指令给Native . JS 和 Native 的沟通主要通过两个关键方法进行: callNative 是一个由native代码实现的函数, 它被JS代码调用并向native发送指令,例如 rendering, networking, authorizing和其他客户端侧的 toast 等API. callJS 是一个由JS实现的函数, 它用于Native向JS发送指令. 目前这些指令由用户交互和Native的回调函数组成.Native 渲染引擎 Native 渲染引擎提供客户端组件和模块. Component(组件) 在屏幕内可见，有特定行为. 能被配置不同的属性和样式,能响应用户交互. 常见的组件有: &lt;div&gt;, &lt;text&gt;, &lt;image&gt;. Module(模块) 是一组能被JS Framework调用的API. 其中的一些能以异步的方式调用JS Framework, 例如: 发送HTTP请求. 在Weex实例运行期间,Native渲染引擎将接收各种各样不同模块的API调用。这些调用创建或更新组件外观，运行如toast的Native API.当用户交互或模块回调时，callJS()会由JS Framework调用. 这样的循环往复将从Weex实例初始化到销毁一直持续. 如下面的架构图所示, HTML5渲染引擎提供和Native渲染引擎几乎一致的功能。 Weex架构图 从Javascript中调用Native[JS Framework]↓ callNative模块 APIs 渲染 -&gt; 模块显示 其他功能[Native 渲染引擎] 从Native中调用Javascript[Native 渲染引擎]模块 APIs 回调用户交互↓ callJS[JS Framework] 渲染流程 Weex 渲染流程 虚拟DOM. 构造树结构. 分析虚拟DOM JSON数据以构造渲染树(RT). 添加样式. 为渲染树的各个节点添加样式. 创建视图. 为渲染树各个节点创建Native视图. 绑定事件. 为Native视图绑定事件. CSS布局. 使用 css-layout 来计算各个视图的布局. 更新视窗(Frame). 采用上一步的计算结果来更新视窗中各个视图的最终布局位置. 最终页面呈现. 在Weex HTML5环境下 CSS 布局 and 更新视窗 由浏览器引擎(例如webkit)实现.","type":"advanced"},{"title":"集成 Devtools 到 Android","path":"cn/advanced/integrate-devtools-to-android.html","permalink":"http://alibaba.github.io/cn/advanced/integrate-devtools-to-android.html","text":"集成 Devtools 到 AndroidWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 Android 端如何接入 Weex Devtools。 Android 应用接入添加依赖可以通过 Gradle 或者 Maven 添加对 devtools aar 的依赖，也可以直接对源码依赖。强烈建议使用最新版本，因为 Weex SDK 和 devtools 都在快速的迭代开发中，新版本会有更多惊喜，同时也修复老版本中一些问题。最新的 release 版本可在这里查看。所有的 release 版本都会发布到 jcenter repo。 Gradle 依赖 dependencies &#123; compile 'com.taobao.android:weex_inspector:0.8.0.0'&#125; Maven依赖 &lt;dependency&gt; &lt;groupId&gt;com.taobao.android&lt;/groupId&gt; &lt;artifactId&gt;weex_inspector&lt;/artifactId&gt; &lt;version&gt;0.8.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 源码依赖 需要复制 inspector 目录到你的 App 的同级目录，然后在工程的 settings.gradle 文件下添加 include &quot;:inspector&quot;，此过程可以参考 playground 源码的工程配置及其配置，然后在 App 的 build.gralde 中添加依赖。 dependencies &#123; compile project(':inspector')&#125; 另外 weex_inspector 中有一部分包是以 provided 的方式引入，接入方需要自行解决依赖和版本冲突。 provided方式引用的包 dependencies &#123; provided 'com.google.code.findbugs:jsr305:2.0.1' provided 'com.android.support:appcompat-v7:23.1.1' provided 'com.taobao.android:weex_sdk:0.8.0' provided 'com.alibaba:fastjson:1.1.45+' ...&#125; 反射引用的包(0.8.0.0以上版本) dependencies &#123; compile 'com.squareup.okhttp:okhttp:2.3.0' compile 'com.squareup.okhttp:okhttp-ws:2.3.0' ...&#125; 或者 dependencies &#123; compile 'com.squareup.okhttp:okhttp:3.4.1' compile 'com.squareup.okhttp:okhttp-ws:3.4.1' ...&#125; 版本兼容 weex sdk weex inspector Debugger Server 0.8.0.1+ 0.0.8.1+ 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 - 添加 Debug 模式开关控制调试模式的打开和关闭的关键点可以概括为三条规则。 规则一：通过 sRemoteDebugMode 和 sRemoteDebugProxyUrl 和来设置开关和 Debugger Server 地址。 Weex SDK 的 WXEnvironment 类里有一对静态变量标记了 Weex 当前的调试模式是否开启分别是： public static boolean sRemoteDebugMode; // 是否开启 debug 模式，默认关闭public static String sRemoteDebugProxyUrl; // DebugServer的websocket地址 无论在 App 中无论以何种方式设置 Debug 模式，都必须在恰当的时机调用类似如下的方法来设置 WXEnvironment.sRemoteDebugMode 和 WXEnvironment.sRemoteDebugProxyUrl。 private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = \"ws://\" + host + \":8088/debugProxy/native\";&#125; 规则二：修改 sRemoteDebugMode 后一定要调用`WXSDKEngine.reload()。 一般來說，在修改了 WXEnvironment.sRemoteDebugMode 以后调用了 WXSDKEngine.reload() 方法才能够使 Debug模式生效。WXSDKEngine.reload() 用来重置 Weex 的运行环境上下文，在切换调试模式时需要调用此方法来创建新的 Weex 运行时和 DebugBridge 并将所有的 JS 调用桥接到调试服务器执行。在 reload 过程中会调用 launchInspector，这就是 SDK 控制 Debug 模式最核心一个方法，其传入参数即为 sRemoteDebugMode，若为 true 则该方法中尝试以反射的方式获取 DebugBridge 用来在远端执行 JS，否则在本地运行。 private void launchInspector(boolean remoteDebug) &#123; if (WXEnvironment.isApkDebugable()) &#123; try &#123; if (mWxDebugProxy != null) &#123; mWxDebugProxy.stop(); &#125; HackedClass&lt;Object&gt; debugProxyClass = WXHack.into(\"com.taobao.weex.devtools.debug.DebugServerProxy\"); mWxDebugProxy = (IWXDebugProxy) debugProxyClass.constructor(Context.class, WXBridgeManager.class) .getInstance(WXEnvironment.getApplication(), WXBridgeManager.this); if (mWxDebugProxy != null) &#123; mWxDebugProxy.start(); if (remoteDebug) &#123; mWXBridge = mWxDebugProxy.getWXBridge(); &#125; else &#123; if (mWXBridge != null &amp;&amp; !(mWXBridge instanceof WXBridge)) &#123; mWXBridge = null; &#125; &#125; &#125; &#125; catch (HackAssertionException e) &#123; WXLogUtils.e(\"launchInspector HackAssertionException \", e); &#125; &#125;&#125; 只要遵循上面的原理，开启 Debug 模式的方式和时机可由接入方灵活实现。从 launchInspector 可以看到，SDK 对 devtools 的 aar 包并无强依赖,我们的 App 只需要在 Debug 包中打包该 aar 即可，这样多少可以缓解包大小问题和安全问题。 例外： 若修改 WXEnvironment.sRemoteDebugMode 的时机在 WXBridgeManager 初始化和 restart 和之前则 WXSDKEngine.reload() 可忽略. 规则三：通过响应 ACTION_DEBUG_INSTANCE_REFRESH 广播及时刷新。 广播 ACTION_DEBUG_INSTANCE_REFRESH 在调试模式切换和 Chrome 调试页面刷新时发出，主要用来通知当前的 Weex容器以 Debug 模式重新加载当前页。在 playground 中的处理过程如下： public class RefreshBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH.equals(intent.getAction())) &#123; if (mUri != null) &#123; if (TextUtils.equals(mUri.getScheme(), \"http\") || TextUtils.equals(mUri.getScheme(), \"https\")) &#123; loadWXfromService(mUri.toString()); &#125; else &#123; loadWXfromLocal(true); &#125; &#125; &#125; &#125;&#125; 如果接入方的容器未对该广播做处理，那么将不支持刷新和调试过程中编辑代码时的 watch 功能。 接入示例最简单方式就是复用 Playground 的相关代码，比如扫码和刷新等模块，但是扫码不是必须的，它只是与 App 通信的一种形式，二维码里的包含DebugServer IP 及 bundle 地址等信息，用于建立 App 和 Debugger Server 之间的连接及动态加载 bundle。在 Playground 中给出了两种开启 debug 模式的范例。 范例1：通过在 XXXApplication 中设置开关打开调试模式 public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, \"xxx.xxx.xxx.xxx\"/*\"DEBUG_SERVER_HOST\"*/); &#125;&#125; 这种方式最直接，在代码中直接 hardcode 了开启调试模式，如果在 SDK 初始化之前调用甚至连 WXSDKEngine.reload() 都不需要调用，接入方如果需要更灵活的策略可以将 initDebugEnvironment(boolean enable, String host) 和 WXSDKEngine.reload() 组合在一起在合适的位置和时机调用即可。 范例2：通过扫码打开调试模式 Playground 中较多的使用扫码的方式传递信息，不仅用这种方式控制 Debug 模式的开关,而且还通过它来传入 bundle 的 url 直接调试。应当说在开发中这种方式是比较高效的，省去了修改 SDK 代码重复编译和安装 App 的麻烦，缺点就是调试工具这种方式接入需要 App 具有扫码和处理特定规则二维码的能力。除了 Playground 中的方式，接入方亦可根据业务场景对 Debugger 和接入方式进行二次开发。 Playground 集成的具体代码可参考如下两个文件： 开关控制，主要参考对二维码的处理部分，详见 WXApplication.java 刷新控制 ，主要参考是对容器 ACTION_DEBUG_INSTANCE_REFRESH的处理，详见 WXPageActivity.java 牛刀小试前置工作如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 本地开发）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 开始调试如果你的 App 客户端完成了以上步骤那么恭喜你已经接入完毕，可以愉快的调试 Weex bundle 了，调试体验和网页调试一致！建议新手首先用官方的 Playground 体验一下调试流程。只需要启动 App 扫描 Chrome 调试页面下方的第一个二维码即可建立与 Debugger Server 的通信，Chorome 的调试页面将会列出连接成功的设备信息。 主要步骤如下 如果你要加载服务器上 bundle，第一步就是要让你的 bundle sever 跑起来. 在 Playground 中特别简单，只需要你到 Weex 源码目录下，运行 ./start 即可。 命令行运行 weex debug 启动 Debugger Server，Chrome 将会打开一个网页，在网页下方有一个二维码和简单的介绍。 启动 App 并确认打开调试模式。你将在上一步中打开的网页中看到一个设备列表，每个设备项都有两个按钮，分别是 Debugger 和 Inspector。 点击 Inspector Chrome 将创建 Inspector 网页；点击 Debugger Chrome 将创建 Debugger 网页；二者是相互独立的功能，不相互依赖。 背景知识Devtools 组件介绍Devtools 扩展了 Chrome Debugging Protocol，在客户端和调试服务器之间的采用 JSON-RPC 作为通信机制，本质上调试过程是两个进程间协同，相互交换控制权及运行结果的过程。更多细节还请阅读 Weex Devtools Debugger 的技术选型实录这篇文章。 客户端 Devtools 客户端作为 aar 被集成 App 中，它通过 webscoket 连接到调试服务器，此处并未做安全检查。出于安全机制及包大小考虑，强烈建议接入方只在 debug 版本中打包此 aar。 服务器 Devtools 服务器端是信息交换的中枢，既连接客户端，又连接 Chrome，大多数情况下扮演一个消息转发服务器和 Runtime Manager 的角色。 Web端 Chrome 的 V8 引擎扮演着 Bundle javascript runtime 的角色。开启 debug 模式后，所有的 bundle js 代码都在该引擎上运行。另一方面我们也复用了 Chrome 前端的调试界面，例如设置断点，查看调用栈等，调试页关闭则 runtime 将会被清理。 调试的大致过程请参考如下时序图。 FAQ在各业务接入过程中，陆续发现一些问题，对高频次的问题解答如下，开发中以 weex debug -V 的方式启动 Debugger Server 可以看到 server 端的 log 信息，对照上文中的时序图对于定位问题还是非常有帮助，建议调试中默认开启 server 端 log。 扫码 App 在 DebugServerProxy 中抛出 class not found 已知的原因如下： weex_inspector 以 provided 方式引用的包是否引入成功，如 fastjson 等。 weex_inspector 以 compile 方式引用的包是否引入成功，某些 app 重新引入 com.squareup.okhttp:okhttp:2.3.0 和 com.squareup.okhttp:okhttp-ws:2.3.0 则不再报错。 混淆规则影响反射。 playground 扫码调试 crash 已知的原因如下： 系统为 android 6+，崩溃信息提示进程需要 android.permission.READ_PHONE_STATE 权限，代码中未做权限检查，在 0.0.2.7 版本以后已修复，不再需要此权限。 扫码后设备列表页并没有出现我的设备信息 已知的原因如下： Debugger Server 和手机在不同网段，被防火墙隔离。 手机连接了 PC 端的代理，当前尚不支持。 多进程连接服务器端的同一端口，比如在 Application 的 onCreate 中初始化 sdk，若多个进程连接服务器端的同一端口则报错，在 0.0.2.3 版本以后已支持多进程无此问题。 调试过程中频繁刷新连接失败，Server 端提示重新启动 App，非必现 已知的原因如下： 多线程操作网络连接引起，在频繁的即断即连时容易触发。在 0.0.7.1 版本已修复。","type":"advanced"},{"title":"集成 Devtools 到 iOS","path":"cn/advanced/integrate-devtools-to-ios.html","permalink":"http://alibaba.github.io/cn/advanced/integrate-devtools-to-ios.html","text":"集成 Devtools 到 iOSWeex Devtools 能够方便调试 Weex 页面，但此功能离不开 Native 的支持。如何让你的 App 也集成 Devtools，在本章将会详细说明 iOS 端如何接入 Weex Devtools。 iOS 应用接入添加依赖方法一：cocoapods 依赖在工程目录的 podfile 添加如下代码 source https://github.com/CocoaPods/Specs.git，pod &apos;WXDevtool&apos;, &apos;0.7.0&apos;, :configurations =&gt; [&apos;Debug&apos;]， 目前有如下几个版本： 0.7.0, 0.6.1, 0.1.1, 0.1.0 [master repo] 可以通过更新本地 podspec repo，pod search 来查询最新版本，在 podfile 文件添加依赖。 推荐在DEBUG模式下依赖。 方法二：github 源码依赖 拉取最新的WXDevtool代码。 按照如下图示：直接拖动source目录源文件到目标工程中 按照红框中配置勾选 在相对较大的互联网App研发中, framework 静态库被广泛应用，所以推荐使用方法一接入。 集成功能如果按照方法一接入：podfile 的方式，添加头文件包含： #import &lt;TBWXDevtool/WXDevtool.h&gt; 如果按照方法二接入：源码依赖的方式，添加头文件包含： #import &quot;WXDevtool.h&quot;``` 查看 WXDevtool 头文件如下： ```object-c#import &lt;Foundation/Foundation.h&gt;@interface WXDevTool : NSObject/*** set debug status* @param isDebug : YES:open debug model and inspect model;* default is NO,if isDebug is NO, open inspect only;* */+ (void)setDebug:(BOOL)isDebug;/*** get debug status* */ + (BOOL)isDebug;/*** launch weex debug* @param url : ws://ip:port/debugProxy/native, ip and port is your devtool server address* eg:@&quot;ws://30.30.29.242:8088/debugProxy/native&quot;* */+ (void)launchDevToolDebugWithUrl:(NSString *)url;@end``` `setDebug`：参数为 `YES` 时，直接开启 debug 模式，反之关闭，使用场景如下所述在你自己的程序中添加如下代码：```object-c [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 其中的 ws 地址正是 Weex debug 控制台中出现的地址，直接 copy 到 launchDevToolDebugWithUrl 接口中。 如果程序一启动就开启 Weex 调试，需要在 WeexSDK 引擎初始化之前添加代码： [WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://30.30.31.7:8088/debugProxy/native&quot;]; 附加页面刷新功能 为什么需要页面刷新功能？ 如下图所示，当点击 debug 按钮时，js 的运行环境会从手机端（JavaScriptCore）切换到 Chrome（V8），这时需要重新初始化 Weex 环境，重新渲染页面。页面渲染是需要接入方在自己的页面添加。 什么场景下需要添加页面刷新功能? 点击 debug 按钮调试 切换 RemoteDebug 开关 刷新 Chrome 页面（command+R） 如何添加刷新 在 Weex 页面初始化或 viewDidLoad 方法时添加注册通知，举例如下： [[NSNotificationCenter defaultCenter] addObserver:self selector:notificationRefreshInstance: name:@&quot;RefreshInstance&quot; object:nil]; 最后千万记得在 dealloc 方法中取消通知，如下所示 - (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 页面刷新实现，先销毁当前 instance，然后重新创建 instance，举例如下: - (void)render &#123; CGFloat width = self.view.frame.size.width; [_instance destroyInstance]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; weakSelf.weexView = view; [weakSelf.view addSubview:weakSelf.weexView]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, weakSelf.weexView); &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; [weakSelf updateInstanceState:WeexInstanceAppear]; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; if (!self.url) &#123; return; &#125; NSURL *URL = [self testURL: [self.url absoluteString]]; NSString *randomURL = [NSString stringWithFormat:@&quot;%@?random=%d&quot;,URL.absoluteString,arc4random()]; [_instance renderWithURL:[NSURL URLWithString:randomURL] options:@&#123;@&quot;bundleUrl&quot;:URL.absoluteString&#125; data:nil];&#125; 具体实现可参考 playground WXDemoViewController.m 文件 说明：目前版本需要注册的通知名称为固定的 “RefreshInstance”，下个版本会添加用户自定义 name 。 使用如果未安装 Debugger Server，在命令行执行 npm install -g weex-toolkit 既可以安装调试服务器，运行命令 weex debug 就会启动 DebugServer 并打开一个调试页面（详情请查看 本地开发）。页面下方会展示一个二维码，这个二维码用于向 App 传递 Server 端的地址建立连接。 日志级别控制 日志级别可以控制native端关于weex的日志。 日记级别描述如下： Off = 0, Error = ErrorWarning = Error | Warning,Info = Warning | Info,Log = Log | Info,Debug = Log | Debug, All = NSUIntegerMax 解释：off 关闭日志，Warning 包含 Error、Warning，Info 包含 Warning、Info，Log 包含 Info、Log，Debug 包含 Log、Debug，All 包含所有。 Vdom/Native tree选择 图一 图二 点击图一所示native选项会打开图二，方便查看native tree以及view property 图三 图四 点击图三所示 vdom 选项会打开图四，方便查看 vdom tree 以及 component property。","type":"advanced"},{"title":"集成到 Android","path":"cn/advanced/integrate-to-android.html","permalink":"http://alibaba.github.io/cn/advanced/integrate-to-android.html","text":"WEEX SDK 集成到 Android 工程注：以下文档都是假设您已经具备一定的Android开发经验。 Android 集成有两种方式 源码依赖：能够快速使用WEEX最新功能，可以根据自己项目的特性进行相关改进。 SDK依赖：WEEX 会在jcenter 定期发布稳定版本。jcenter注:国内可能需要翻墙 前期准备 已经安装了JDK version&gt;=1.7 并配置了环境变量 已经安装Android SDK 并配置环境变量。 Android SDK version 23 (compileSdkVersion in build.gradle) SDK build tools version 23.0.1 (buildToolsVersion in build.gradle) Android Support Repository &gt;= 17 (for Android Support Library) 快速接入如果你是尝鲜或者对稳定性要求比较高可以使用依赖SDK的方式。步骤如下： 创建Android工程，没有什么要特别说明的，按照你的习惯来。 修改build.gradle 加入如下基础依赖 compile 'com.android.support:recyclerview-v7:23.1.1'compile 'com.android.support:support-v4:23.1.1'compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.alibaba:fastjson:1.1.46.android'compile 'com.taobao.android:weex_sdk:0.5.1@aar' 注:版本可以高不可以低。 代码实现注:附录中有完整代码地址 实现图片下载接口，初始化时设置。 package com.weex.sample;import android.widget.ImageView;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;/** * Created by lixinke on 16/6/1. */public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(String url, ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现你自己的图片下载，否则图片无法显示。 &#125;&#125; 初始化 package com.weex.sample;import android.app.Application;import com.taobao.weex.InitConfig;import com.taobao.weex.WXSDKEngine;/** * 注意要在Manifest中设置android:name=\".WXApplication\" * 要实现ImageAdapter 否则图片不能下载 * gradle 中一定要添加一些依赖，否则初始化会失败。 * compile 'com.android.support:recyclerview-v7:23.1.1' * compile 'com.android.support:support-v4:23.1.1' * compile 'com.android.support:appcompat-v7:23.1.1' * compile 'com.alibaba:fastjson:1.1.45' */public class WXApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build(); WXSDKEngine.initialize(this,config); &#125;&#125; 开始渲染 package com.weex.sample;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import com.taobao.weex.IWXRenderListener;import com.taobao.weex.WXSDKInstance;import com.taobao.weex.common.WXRenderStrategy;import com.taobao.weex.utils.WXFileUtils;public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * WXSample 可以替换成自定义的字符串，针对埋点有效。 * template 是.we transform 后的 js文件。 * option 可以为空，或者通过option传入 js需要的参数。例如bundle js的地址等。 * jsonInitData 可以为空。 * width 为-1 默认全屏，可以自己定制。 * height =-1 默认全屏，可以自己定制。 */ mWXSDKInstance.render(\"WXSample\", WXFileUtils.loadFileContent(\"hello.js\", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 源码依赖(IDE Android Studio) 下载源码 git clone https://github.com/alibaba/weex 创建 Android 工程。 通过以下路径引入 SDK ModuleFile-&gt;New-Import Module-&gt; 选择 WEEX SDK Module(weex/android/sdk) -&gt; Finish app 的 build.gradle 中添加如下依赖:compile project(&#39;:weex_sdk&#39;) 其他设置请参考上面快速接入 附录WXSample地址https://github.com/xkli/WXSample.git","type":"advanced"},{"title":"集成到 web","path":"cn/advanced/integrate-to-html5.html","permalink":"http://alibaba.github.io/cn/advanced/integrate-to-html5.html","text":"项目中引入 html5 版 Weex简介Weex 是一个跨平台可扩展的动态化移动框架，能够真正帮助开发者实现’一次开发，到处运行’。由 Weex 提供的相关工具进行打包好的 bundle 文件可以运行在 android, ios 以及 web（这里我们也称之为html5）平台的渲染器上。Weex HTML5 是一个专用于在移动端 webview 以及各种现代浏览器上渲染 weex 文件的渲染器。 获取 Weex HTML5使用 npm 安装最新版本的 Weex HTML5，并在你的项目中 require 进来。 从 npm 安装请确保通过 npm install 或者 npm update 获取 Weex HTML5 的最新版本 npm 包。更多关于 npm 的信息情查阅 npm 官方网站。 npm install weex-html5 通过 require 引入 weex-html5: var weex = require('weex-html5') 注意: 介于 Weex 目前仍处于开源内测阶段，还没有完全开放源代码，因此 weex-jsframework 可能还没有在 npm 上发布。当前版本的 weex-html5 包含了 weex-jsframework，你只需要 require weex-html5 即可暂时在 web 平台上运行 weex 代码。建议关注 Weex 的后续版本发布并做必要的引用方式调整。 初始化 Weex你可以通过 Weex 暴露的 API init 来初始化一个 Weex 实例。这个方法需要传递一些配置信息已确定一些环境变量等信息，这些配置信息介绍如下： appId: Weex 实例的 id，可以是任意字符串或者数字，并注意不要重复. source: 请求的 Weex bundle 文件地址，或者 Weex bundle 文件代码本身，取决于下面的 loader 配置. loader: 加载器类型，用于加载 weex bundle，值可以是 ‘xhr’, ‘jsonp’ 或者 ‘source’. xhr: 通过 XMLHttpRequest 加载 source(即 weex bundle 的 url 地址). jsonp: 通过 JSONP 加载 weex bundle. source: 直接接受 weex bundle 的代码作为参数. rootId: root 容器的 id，默认容器 id 是 ‘weex’. 以下是一个 Weex 初始化的示例: function weexInit() &#123; function getUrlParam (key) &#123; var reg = new RegExp('[?|&amp;]' + key + '=([^&amp;]+)') var match = location.search.match(reg) return match &amp;&amp; match[1] &#125; var loader = getUrlParam('loader') || 'xhr' var page = getUrlParam('page') // 需要指定一个jsonp回调函数名称，如果没有则用默认值'weexJsonpCallback' var JSONP_CALLBACK_NAME = 'weexJsonpCallback' window.weex.init(&#123; jsonpCallback: JSONP_CALLBACK_NAME, appId: location.href, source: page, loader: loader, rootId: 'weex' &#125;)&#125;weexInit()","type":"advanced"},{"title":"集成到 iOS","path":"cn/advanced/integrate-to-ios.html","permalink":"http://alibaba.github.io/cn/advanced/integrate-to-ios.html","text":"Weex SDK 集成到 iOScocoaPods 引入 Weex iOS SDK到工程可以通过源码编译出 Weex SDK，可以在新的 feature 或者 bugfix 分支，尝试最新的 feature cocoaPods集成 假设你已经完成了安装iOS 开发环境 和 CocoaPods 从 github 上 clone 一份代码 git clone https://github.com/alibaba/weex.git 把 WeexSDK 导入到你已有的项目，如果没有，可以参考新建项目拷贝 ios/sdk 下面目录到你的项目目录，在添加依赖之前，确保项目目录有 Podfile，如果没有，创建一个，用文本编辑器打开，添加如下依赖 如果使用正式版本如 0.6.1 的，就不需要做 拷贝 ios/sdk 这个操作，直接引用 cocoaPods 的 master repo 上就可以，这个需要在 Podfile 最前面添加 source &apos;https://github.com/CocoaPods/Specs.git&apos; target &apos;YourTarget&apos; do platform :ios, &apos;7.0&apos; pod &apos;WeexSDK&apos;, :path=&gt;&apos;./sdk/&apos; # pod &apos;WeexSDK&apos;, &apos;0.6.1&apos;end 在命令行（terminal）中，切换到当前目录，运行 pod install, 过一会，项目的 .workspace 结尾的文件就被创建出来，到这步，依赖已经添加完了 初始化 Weex 环境在 AppDelegate.m 文件中做初始化操作，一般会在 didFinishLaunchingWithOptions 方法中如下添加 //business configuration[WXAppConfiguration setAppGroup:@&quot;AliApp&quot;];[WXAppConfiguration setAppName:@&quot;WeexDemo&quot;];[WXAppConfiguration setAppVersion:@&quot;1.0.0&quot;];//init sdk enviroment [WXSDKEngine initSDKEnviroment];//register custom module and component，optional[WXSDKEngine registerComponent:@&quot;MyView&quot; withClass:[MyViewComponent class]];[WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]];//register the implementation of protocol, optional[WXSDKEngine registerHandler:[WXNavigationDefaultImpl new] withProtocol:@protocol(WXNavigationProtocol)];//set the log level [WXLog setLogLevel: WXLogLevelAll]; 渲染 weex InstanceWeex 支持整体页面渲染和部分渲染两种模式，你需要做的事情是用指定的 URL 渲染 weex 的 view，然后添加到它的父容器上，父容器一般都是 viewController #import &lt;WeexSDK/WXSDKInstance.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; _instance.frame = self.view.frame; __weak typeof(self) weakSelf = self; _instance.onCreate = ^(UIView *view) &#123; [weakSelf.weexView removeFromSuperview]; [weakSelf.view addSubview:weakSelf.weexView]; &#125;; _instance.onFailed = ^(NSError *error) &#123; //process failure &#125;; _instance.renderFinish = ^ (UIView *view) &#123; //process renderFinish &#125;; [_instance renderWithURL:self.url options:@&#123;@&quot;bundleUrl&quot;:[self.url absoluteString]&#125; data:nil];&#125; WXSDKInstance 是很重要的一个类，提供了基础的方法和一些回调，如renderWithURL,onCreate,onFailed等，可以参见 WXSDKInstance.h的 声明 销毁 Weex Instance 在 viewController 的 dealloc 阶段 销毁掉 weex instance， 释放内存，避免造成内存泄露 - (void)dealloc&#123; [_instance destroyInstance];&#125; 导入 Weex SDK framework到工程 参考此处直接导入weexSDK","type":"advanced"},{"title":"","path":"cn/blog/index.html","permalink":"http://alibaba.github.io/cn/blog/index.html","text":"","type":"blog"},{"title":"如何在本地开发 Weex 页面","path":"cn/guide/develop-on-your-local-machine.html","permalink":"http://alibaba.github.io/cn/guide/develop-on-your-local-machine.html","text":"如何在本地开发 Weex 页面使用 dotWe 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex， dotWe 就不怎么够用了。本章会教你如何搭建本地开发环境进行 Weex 开发。 第一步：安装依赖首先，你需要 Node.js 和 weex-toolkit。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 对于 Mac，可以使用 Homebrew 进行安装： brew install node 更多安装方式可参考 Node.js 官方信息 安装完成后，可以使用以下命令检测是否安装成功： $ node -vv6.3.1$ npm -v3.10.3 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit。 npm 是一个 JavaScript 包管理工具，它可以让开发者轻松共享和重用代码。Weex 很多依赖来自社区，同样，Weex 也将很多工具发布到社区方便开发者使用。 $ npm install -g weex-toolkit ``` 国内开发者可以考虑使用淘宝的 npm 镜像 —— [cnpm](https://npm.taobao.org/) 安装 weex-toolkit```bash$ npm install -g cnpm$ cnpm install -g weex-toolkit 提示： 如果提示权限错误（permission error），使用 sudo 关键字进行安装 $ sudo cnpm install -g weex-toolkit 安装结束后你可以直接使用 weex 命令验证是否安装成功，它会显示 weex 命令行工具各参数： 第2步：创建文件现在可以开始编写代码了。首先，我们创建一个 .we 文件（Weex 程序的文件后缀（扩展名）是 .we）。 打开空白的 hello.we 文件，输入三个标签，内容为： &lt;template&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; ``` 我们在 [Get started](./index.md) 里已经介绍过 Weex 基本的代码结构：`&lt;template&gt;`、`&lt;style&gt;`、`&lt;script&gt;` 分别对应于 Web 中的 HTML，CSS（`&lt;style&gt;` 标签），JavaScript（`&lt;script&gt;` 标签）。其实，上面的代码就是最简单的 Weex 程序。但是 `.we` 文件是不能直接运行的，这时候需要使用刚才安装好的 weex-toolkit。weex-toolkit 会编译 `.we` 文件，并且创建静态服务器。这里，使用 `weex hello.we` 命令编译该程序。```bash$ weex hello.we 这时，命令行会做几件事： 编译 .we 文件； 启动热加载服务； 启动静态服务器； 拉起浏览器，访问 http://127.0.0.1:8081/weex_tmp/h5_render/?hot-reload_controller&amp;page=hello.js&amp;loader=xhr 这时候，已经可以在浏览器预览 Weex 页面了。不过此时页面是空白的，因为 .we 文件中没有任何实质的内容。 第3步：添加内容修改 weex.we 文件，向 &lt;template&gt; 标签中添加内容。具体代码如下： &lt;template&gt; &lt;div&gt; &lt;text&gt;Hello world&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 保存代码后，浏览器会自动刷新页面，这时会看到浏览器显示了 “Hello world”。 第4步：添加样式现在，对已有的文本内容进行样式修饰。这里将文本颜色设置为红色，字体大小为 50 像素。具体代码如下： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\" style=\"color: #FF0000;\"&gt;Hello world&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text&#123; font-size: 50; &#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 这时候，浏览器已经重新载入了页面。其实，是weex-toolkit开启了热加载。可以看到红色的 “Hello world”。 注意：Weex 支持通过 style 标签来设定样式，也支持内联样式风格。 对于数值，无需添加任何单位（包括 px、em、rem 等），这是建议的写法。如需了解有哪些通用的样式，可以参考 通用样式。 第5步：预览已经在浏览器中看到了刚才的代码效果，为了验证三端是否一致，我们还需 Playground App 验证。 这里，我们需要为 weex hello.we 增加 --qr 参数，表示生成二维码。 $ weex hello.we --qr 然后，使用 Playground 扫码即可。 第6步：调试weex-toolkit 已经集成了 Debugger，只需要使用如下命令即可开启 Debugger 开关调试 hello.we： $ weex debug hello.we 我们输入以上命令开启，会自动打开浏览器，页面上有两个二维码，第一个是 Debugger Server，第二个是 .we 文件的地址。我们在 Playground 中先扫第一个，此时浏览器会进入一个新的页面，请你选择你需要的调试模式： Debugger：将会打开 js debugger 页面，您可以通过 debugger 页面调试 js（诸如打断点 查看js log 和查看调用堆栈等信息）； Inspector：将会打开 inspector 页面，您可以通过这个页面查看 Weex 页面的 element 属性结构，包含高亮元素，展示样式表，以及显示 native 的 log。同时可以打开一个远程的手机镜像，便于查看界面。另外调试方块中的 ElementMode 可以用来选择 element 树显示原始的 native 组件树还是显示面向前端同学的 DSL （HTML）组件树。 选择一种模式后会新开窗口进入调试页面，这时我们再扫第二个二维码即可进入我们想要调试的页面进行调试了。 接下来做什么？到目前为止，你已经可以在 dotWe 或者本地开发 Weex 页面。接下来你可以去学习 Weex 语法 和 开发手册 了解 Weex 更多特性。这些语法和特性，你完全可以用 Playground 运行起来。 如果你已经熟悉 Weex 开发，你应该考虑如何让你的 App 也支持 Weex 页面，或者，怎样用 Weex 开发一个全新的 App 呢？带着这些问题，你可以阅读 开发进阶。","type":"guide"},{"title":"上手教程","path":"cn/guide/index.html","permalink":"http://alibaba.github.io/cn/guide/index.html","text":"起步教程Weex 是一套简单易用的跨平台开发方案，能以 web 的开发体验构建高性能、可扩展的 native 应用，为了做到这些，Weex 与 Vue 合作，使用 Vue 作为上层框架，并遵循 W3C 标准实现了统一的 JSEngine 和 DOM API，这样一来，你甚至可以使用其他框架驱动 Weex，打造三端一致的 native 应用。 尝试 Weex 最简单的方法是使用 Playground App 和在 dotWe 编写一个 Hello World 例子。你不需要考虑安装开发环境或编写 native 代码，只需要做下面两件事： 为你的手机安装 Playground App，当然，Weex 是跨平台的框架，你依然可以使用浏览器进行预览，只是这样你就无法感受到 native 优秀的体验了。 在新标签页中打开 Hello World 例子，点击预览，然后用 Playground 扫码即可。 在这个例子中，我们看到了熟悉的 HTML 语义化标签、CSS 样式和 Javascript 代码。这是一个最简单的 Weex 示例，它在页面中渲染了一个 “Hello World”。 发生了什么？就如示例代码所示： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text &#123; font-size: 50; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; text: 'Hello World.' &#125; &#125;&lt;/script&gt; 我们暂时不去关心 Weex 的技术细节，仅看大致的代码结构。Weex 代码由三部分构成：template、style、script，这三个概念之于 Weex 就如 HTML，CSS，JavaScript 之于 Web。 模板部分赋予 Weex 以骨架，由标签以及标签包围的内容构成，标签中能添加 attribute（特性），不同的 attribute 有不同的含义，例如 class 特性让同样的样式可以作用于多组 Weex 标签， onclick 特性让标签能对用户点击事件作出回应。 样式部分描述 Weex 标签如何显示。和你一样，我们喜欢 CSS，所以 Weex 中的样式尽量和 CSS 标准一致。Weex 支持很多 CSS 中的特性： margin, padding, fixed…… 更好的是， flexbox 布局模型在 Weex 中获得了很好的支持。 脚本部分为 Weex 标签添加数据与逻辑，在这里你能方便的访问本地或远程的数据并动态更新。你还能定义方法并让这些方法响应不同的事件。Weex 脚本的组织方式基本遵循于 CommonJS module 规范。 是不是觉得这些语法有些眼熟？没错，Weex 语法参考了 Vue，如果你熟悉 Vue，你会很快适应 Weex 语法（最新的 Weex framework 将会基于 Vue 2.0 开发，完全兼容 Vue，可参见我们的 Roadmap），更好的是，我们拥抱规范，尽可能的按照 W3C 标准进行实现，因此，你大可不必担心 Weex 三端差异。 你可以试着修改 Hello World 的代码，再次点击预览即可生成新的二维码进行扫描。 Weex 不止是个 Demo，在接下来的章节中，你还会看到更多 Weex 开发 native 应用并将其集成到你的 App 中的精彩教程。不要忘了随时在 dotWe 中编写代码验证并通过 Playground App 预览。","type":"guide"},{"title":"Weex 快查手册","path":"cn/references/cheatsheet.html","permalink":"http://alibaba.github.io/cn/references/cheatsheet.html","text":"Weex 备忘录Native 组件 code { word-break: break-all; } 组件 特性 样式 事件 特殊父组件 子组件 &lt;div&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;text&gt; value box modelflexpositionbackground-coloropacitycolorfont-sizefont-stylefont-weighttext-decorationtext-aligntext-overflowline-height clickappeardisappear - text only &lt;image&gt; src box modelflexboxpositionbackground-coloropacityresize clickappeardisappear - (none) &lt;scroller&gt; show-scrollbarscroll-direction box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;list&gt; loadmoreoffset box modelflexboxpositionbackground-coloropacity clickappeardisappearloadmorerefreshloading - &lt;cell&gt;&lt;header&gt;&lt;refresh&gt;&lt;loading&gt; &lt;cell&gt; - box modelflexboxpositionbackground-coloropacity clickappeardisappear &lt;list&gt; (any) &lt;slider&gt; auto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearchange - (any)&lt;indicator&gt; &lt;indicator&gt; - box modelflexboxpositionitem-coloritem-selected-coloritem-size clickappeardisappear &lt;slider&gt; (none) &lt;wxc-navpage&gt; heightbackground-colortitletitle-colorleft-item-titleleft-item-colorright-item-titleright-item-colorleft-item-srcright-item-src box modelflexboxpositionbackground-coloropacity clickappeardisappearnaviBar.leftItem.clicknaviBar.rightItem.click - (any) &lt;wxc-tabbar&gt; tab-items box modelflexboxpositionbackground-coloropacity tabBar.onClick - (none) &lt;embed&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappear - (none) &lt;web&gt; src box modelflexboxpositionbackground-coloropacity clickappeardisappearpagestartpagefinisherror - (none) &lt;video&gt; srcplay-statusauto-play box modelflexboxpositionbackground-coloropacity clickappeardisappearstartpausefinishfail - (none) &lt;a&gt; href box modelflexboxpositionbackground-coloropacity clickappeardisappear - (any) &lt;input&gt; typevalueplaceholderdisabledautofocus box modelflexboxpositionbackground-coloropacityplaceholder-colorcolorfont-sizefont-stylefont-weighttext-align clickappeardisappear - (none) &lt;switch&gt; checked box modelflexboxpositionbackground-coloropacity appeardisappearinputchangefocusblur - (none) Native Modules module apis @weex-module/dom scrollToElement(node, { offset }) @weex-module/modal toast({ message, duration })alert({ message, okTitle }, callback)confirm({ message, okTitle, cancelTitle }, callback(result))prompt({ message, okTitle, cancelTitle }, callback(result, data)) @weex-module/stream fetch({ method, url, headers, type, body }, callback({ status, ok, statusText, data, headers }), progressCallback({ readyState, status, length, statusText, headers})) @weex-module/webview goBack(ref)goForward(ref)reload(ref) @weex-module/navigator push({ url, animated }, callback)pop({ animated }, callback) @weex-module/animation transition(node, { styles, duration, timingFunction, delay, transform-origin }, callback) 特殊的模版语法 &lt;foo x=&quot;abc&quot;&gt; &lt;foo style=&quot;name1: value1; name2: value2&quot;&gt; &lt;foo class=&quot;a b c&quot;&gt; &lt;foo onclick=&quot;methodName&quot;&gt; &lt;foo id=&quot;abc&quot;&gt; &lt;foo if=&quot;expr&quot;&gt; &lt;foo repeat=&quot;item in list&quot;&gt; &lt;foo repeat=&quot;(key,item) in list&quot;&gt; &lt;component type=&quot;foo&quot;&gt; ViewModel APIs this.$vm(el) this.$el(el) this.$getConfig() this.$emit(type, data) this.$dispatch(type, data) this.$broadcast(type, data) ViewModel Options data methods computed init, created, ready events 示例： module.exports = &#123; data: function () &#123; return &#123; x: 1, y: 2 &#125; &#125; methods: &#123; foo: function () &#123; console.log('foo') &#125; &#125;, computed: &#123; z: function () &#123; return this.x + this.y &#125; &#125;, events: &#123; custom: function (e) &#123; console.log(e) &#125; &#125;, init: function () &#123;&#125;, created: function () &#123;&#125;, ready: function () &#123;&#125;&#125;","type":"references"},{"title":"ViewModel APIs","path":"cn/references/api.html","permalink":"http://alibaba.github.io/cn/references/api.html","text":"接口你可以在组件的方法中通过 this （Vm）上下文访问这些 API。 例子： &lt;script&gt;module.exports = &#123; methods: &#123; somemethod: function() &#123; this.$vm('someId'); &#125; &#125;&#125;&lt;/script&gt; $(id)不建议使用，请使用 $vm 代替。 $el(id)返回对应 id 的元素对象的引用。 Arguments id (string): 唯一标识符。Returns (Element): 一个元素对象的引用。Tips id 只能保证是当前（页面）组件中是唯一的，如果你需要寻找父组件或子组件，你可以利用组件间的通信模式实现。 延伸阅读： id，Communicate Between Components$vm(id) 返回对应 id 的 vm 对象引用。 Arguments id (String): 唯一标识符。Returns vm (Vm): 一个 Vm 对象引用。Tips id 只能保证是当前（页面）组件中是唯一的，如果你需要寻找父组件或子组件，你可以利用组件间的通信模式实现。 延伸阅读： id，Communicate Between Components$getConfig() 获取当前全局环境变量和配置信息。 Returns config (object): 配置对象； bundleUrl (string): bundle 的 url； debug (boolean): 是否是调试模式； env (object): 环境对象； weexVersion (string): Weex sdk 版本； appName (string): 应用名字； appVersion (string): 应用版本； platform (string): 平台信息，是 iOS、Android 还是 Web； osVersion (string): 系统版本； deviceModel (string): 设备型号 （仅原生应用）； deviceWidth (number): 设备宽度，默认为 750； deviceHeight (number): 设备高度。$call(module, method, …args) 不建议使用，请使用 require(&#39;@weex-module/module&#39;)[method](...args) 代替。查看更多信息：modules。","type":"references"},{"title":"颜色名称列表","path":"cn/references/color-names.html","permalink":"http://alibaba.github.io/cn/references/color-names.html","text":"Weex 支持的所有颜色名称基础颜色关键词: 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词: 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32","type":"references"},{"title":"通用特性","path":"cn/references/common-attrs.html","permalink":"http://alibaba.github.io/cn/references/common-attrs.html","text":"通用特性特性（attribute）与 HTML 中元素特性类似，提供了与 Weex 元素有关的其他附加信息。所有的元素都可以拥有特性, 特性总是在 Weex 元素的起始标签中定义，并总是以键值对的形式出现，例如：name=&quot;value&quot;。可以使用 Mustache 对特性值进行数据绑定。 Notes! Weex 遵循 HTML attribute 命名规范, 所以请 不要在特性中使用驼峰风格（CamelCase） , 使用-连接符的羊肉串风格（kebab-case） 才是更好的命名方式。 所有 Weex 元素都拥有以下特性： id为 &lt;template&gt; 内定义的元素指定一个唯一的 id，通过 this.$el(id) 可以容易地获取一个 Weex 元素的引用。更多信息可参考 Instance APIs &lt;template&gt; &lt;div id=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 style为元素定义行内样式。 &lt;div style=\"width: 200px; height: 200px; color: #ff0000;\"&gt;&lt;/div&gt;&lt;div style=\"padding: &#123;&#123;x&#125;&#125;; margin: 0\"&gt;&lt;/div&gt; class为元素定义一个或多个类名（引用样式表中的类）。 &lt;div class=\"button\"&gt;&lt;/div&gt;&lt;div class=\"button &#123;&#123;btnStatus&#125;&#125;\"&gt;&lt;/div&gt; repeat我们可以通过 repeat 特性根据一个数组进行渲染，迭代地生成当前标签的内容。repeat 特性有着 item in items 形式的特殊语法，其中，items 是数组数据，item 是数组元素迭代的别名。 &lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 if提供一个布尔值来决定是否显示当前标签。当值为 true 时，元素显示，为 false 时元素隐藏。 &lt;div if=\"true\"&gt;&lt;/div&gt;&lt;div if=\"&#123;&#123;opened&#125;&#125;\"&gt;&lt;/div&gt;&lt;div if=\"&#123;&#123;direction === 'row'&#125;&#125;\"&gt;&lt;/div&gt; appendappend 特性用于控制渲染次序。它的可选值为 tree 或 node，默认为 tree，不支持数据绑定。不同的值会执行不同的渲染过程： append=&quot;tree&quot; 是一次性渲染整个节点树，渲染更高效，但是如果页面太大容易造成较长时间的白屏。 append=&quot;node&quot; 所有节点逐个渲染，整体渲染速度略慢，但是用户体验好一些。 通过 node 和 tree 可以精细化地控制页面展示的逻辑和颗粒度，一般比较好的实践为首屏以内按 tree 解析，首屏以外按 node 解析。 &lt;div append=\"tree\"&gt;&lt;/div&gt;&lt;div append=\"node\"&gt;&lt;/div&gt; 事件处理 (on…)在 Weex 标签上注册事件处理器。以 on 加 事件名为 key，事件处理函数为 value。 &lt;template&gt; &lt;div class=\"btn\" onClick=\"alertMsg\"&gt;&lt;text&gt;Click me&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.btn &#123; justify-content: center; align-items: center; width: 200; height: 100; background-color: #ff0000; border-radius: 5; color: #ffffff;&#125;&lt;/style&gt;&lt;script&gt;var modal = require('@weex-module/modal')module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'click', okTitle: 'alert' &#125;, function() &#123; &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"通用事件","path":"cn/references/common-event.html","permalink":"http://alibaba.github.io/cn/references/common-event.html","text":"通用事件Weex 提供了通过事件触发动作的能力，例如在用户点击组件时执行 JavaScript。下面列出了可被添加到 Weex 组件上以定义事件动作的属性： click当组件上发生点击手势时被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type: click target: 触发点击事件的目标组件 timestamp: 触发点击事件时的时间戳 示例点击按钮，将弹出弹框，再点击弹框 ×，关闭弹框。 &lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text class=\"btn\" onclick=\"openDialog\"&gt;Show Dialog&lt;/text&gt; &lt;/div&gt; &lt;div id=\"dialog\" class=\"dialog\" if=\"&#123;&#123;isShowDialog&#125;&#125;\"&gt; &lt;div class=\"dialog-backdrop\"&gt;&lt;/div&gt; &lt;div class=\"dialog-content\"&gt; &lt;div class=\"dialog-header\"&gt; &lt;text class=\"dialog-title\"&gt;&#123;&#123;dialogTitle&#125;&#125;&lt;/text&gt; &lt;text class=\"close\" onclick=\"closeDialog\"&gt;×&lt;/text&gt; &lt;/div&gt; &lt;div class=\"dialog-body\"&gt; &lt;text&gt;&#123;&#123;dialogBody&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.dialog-backdrop &#123; opacity: .5; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #000000;&#125;.dialog &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; justify-content: center; align-items: center;&#125;.dialog-content &#123; width: 450; background-color: #ffffff;&#125;.dialog-header &#123; padding: 20; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.dialog-body &#123; padding: 20;&#125;.close &#123; font-size: 50; position: absolute; right: 10; top: 10;&#125;.btn &#123; text-align: center; color: #ffffff; padding: 12; background-color: #3071a9; border-color: #285e8e; border-radius: 4;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; isShowDialog: false, dialogTitle: 'HELLO', dialogBody: 'Weex is best!' &#125;, methods: &#123; openDialog: function (e) &#123; this.isShowDialog = true &#125;, closeDialog: function (e) &#123; this.isShowDialog = false &#125; &#125; &#125;&lt;/script&gt; 体验一下 longpress如果一个组件被绑定了 longpress 事件，那么当用户长按这个组件时，该事件将会被触发。 注意： &lt;input&gt; 和 &lt;switch&gt; 组件目前不支持 click 事件，请使用 change 或 input 事件来代替。 事件对象 type : longpress target : 触发长按事件的目标组件 timestamp : 长按事件触发时的时间戳 示例长按按钮，变换背景色。 &lt;template&gt; &lt;div style=\"width: 400; height: 200; background-color: &#123;&#123;bg&#125;&#125;; justify-content: center; align-items: center;\" onlongpress=\"&#123;&#123;update&#125;&#125;\"&gt; &lt;text style=\"font-size: 60\"&gt;Press me&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; bg: '#FF0000' &#125;, methods: &#123; update: function () &#123; this.bg = this.bg === '#FF0000' ? '#00FF00' : '#FF0000' &#125; &#125; &#125;&lt;/script&gt; 体验一下 Appear 事件如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 事件对象 type : appear target : 触发 Appear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down 示例当滚到最下方时，最后一个 item 出现，将会弹出弹框。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;viewappear&#125;&#125;\" onviewdisappear=\"&#123;&#123;viewdisappear&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\" onappear=\"alertMsg\" &gt; &lt;text&gt;I will alert a message when I appeared.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'I am appeared.', okTitle: 'Appear' &#125;, function() &#123; &#125;) &#125;, viewappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewappear') &#125;, viewdisappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewdisappear') &#125; &#125; &#125;&lt;/script&gt; 体验一下 Disappear 事件如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 事件对象 type : disappear target : 触发 Disappear 事件的组件对象 timestamp : 事件被触发时的时间戳 direction : 触发事件时屏幕的滚动方向，up 或 down 示例当向下滚动到第一个 item 消失后，将会弹出弹框。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;viewappear&#125;&#125;\" onviewdisappear=\"&#123;&#123;viewdisappear&#125;&#125;\"&gt; &lt;div class=\"item\" ondisappear=\"alertMsg\" &gt; &lt;text&gt;I will alert a message when I disappeared.&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertMsg: function (e) &#123; modal.alert(&#123; message: 'I am disappeared.', okTitle: 'Disappear' &#125;, function() &#123; &#125;) &#125;, viewappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewappear') &#125;, viewdisappear: function () &#123; nativeLog('&gt;&gt;&gt;&gt;&gt;', 'viewdisappear') &#125; &#125; &#125;&lt;/script&gt; 体验一下 Page 事件注意：仅支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件。 事件对象 type : viewappear 或 viewdisappear target : 触发事件的组件对象 timestamp : 事件被触发时的时间戳 示例进出页面时，都会弹框提示。 &lt;template&gt; &lt;scroller onviewappear=\"&#123;&#123;alertViewappearMsg&#125;&#125;\" onviewdisappear=\"&#123;&#123;alertViewdisappearMsg&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 1&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 2&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 3&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 4&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 5&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 6&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 7&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 8&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 9&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;text&gt;scroll 10&lt;/text&gt; &lt;/div&gt; &lt;div class=\"item\" onappear=\"alertMsg\" &gt; &lt;text&gt;scroll 11&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;style&gt; .list &#123; height: 850; &#125; .count &#123; font-size: 48; margin: 10; &#125; .indicator &#123; height: 40; width: 40; color: #45b5f0; &#125; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 200; padding: 20; &#125;&lt;/style&gt;&lt;script&gt; var modal = require('@weex-module/modal') module.exports = &#123; data: &#123;&#125;, methods: &#123; alertViewappearMsg: function () &#123; modal.alert(&#123; message: 'viewappear.', okTitle: 'viewappear' &#125;, function() &#123; &#125;) &#125;, alertViewdisappearMsg: function () &#123; modal.alert(&#123; message: 'viewdisappear.', okTitle: 'viewdisappear' &#125;, function() &#123; &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"通用样式","path":"cn/references/common-style.html","permalink":"http://alibaba.github.io/cn/references/common-style.html","text":"通用样式所有 Weex 组件都支持以下通用样式规则。 盒模型 Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 注意：Weex 对于长度值目前只支持像素值，单位可省略，不支持相对单位（em、rem）。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有如下写法： padding-left {length}：，默认值 0 padding-right {length}：，默认值 0 padding-top {length}：，默认值 0 padding-bottom {length}：，默认值 0 margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： margin-left {length}：，默认值 0 margin-right {length}：，默认值 0 margin-top {length}：，默认值 0 margin-bottom {length}：，默认值 0 border： 设定边框，border 目前不支持类似这样 border: 1 solid #ff0000; 的组合写法。 可有如下写法： border-style： 设定边框样式，值类型为 string，可选值为 solid | dashed | dotted，默认值 solid 可有如下写法： border-left-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-top-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-right-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-bottom-style {string}：可选值为 solid | dashed | dotted，默认值 solid border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： border-left-width {length}：，非负值, 默认值 0 border-top-width {length}：，非负值, 默认值 0 border-right-width {length}：，非负值, 默认值 0 border-bottom-width {length}：，非负值, 默认值 0 border-color {color}： 设定边框颜色，默认值 #000000 可有如下写法： border-left-color {color}：，默认值 #000000 border-top-color {color}：，默认值 #000000 border-right-color {color}：，默认值 #000000 border-bottom-color {color}：，默认值 #000000 border-radius {length}： 设定圆角，默认值 0 可有如下写法： border-bottom-left-radius {length}：，非负值, 默认值 0 border-bottom-right-radius {length}：，非负值, 默认值 0 border-top-left-radius {length}：，非负值, 默认值 0 border-top-right-radius {length}：，非负值, 默认值 0 注意：目前在 &lt;image&gt; 和 &lt;text&gt; 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。 Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 示例：&lt;template&gt; &lt;div&gt; &lt;image style=\"width: 400; height: 200; margin-left: 20;\" src=\"https://g.alicdn.com/mtb/lab-zikuan/0.0.18/weex/weex_logo_blue@3x.png\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt; FlexboxWeex 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 Weex 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。另外，老版本只在安卓 4.4 版以下得到支持。 Flex 容器在 Weex 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch 是默认值，即拉伸高度至 flex 容器的大小； flex-start 则是上对齐，所有的成员项排列在容器顶部； flex-end 是下对齐，所有的成员项排列在容器底部； center 是中间对齐，所有成员项都垂直地居中显示。 Flex 成员项flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例一个简单的网格布局。 &lt;template&gt; &lt;div&gt; &lt;div repeat=\"(i, v) in list\" class=\"row\"&gt; &lt;div repeat=\"(k, text) in v\" class=\"item\"&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .item&#123; flex:1; justify-content: center; align-items:center; border-width:1; &#125; .row&#123; flex-direction: row; height:80; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123; list:[ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] &#125; &#125; &#125;&lt;/script&gt; 体验一下 一个在相对于屏幕水平居中，全屏居中的 &lt;div&gt;。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; justify-content: center; align-items: center; &#125; .box &#123; width: 200; height: 200; background-color: #fc0000; &#125;&lt;/style&gt; 体验一下 定位Weex 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 注意： Weex 目前不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 如果定位元素超过容器边界，在 Android 下，超出部分将不可见，原因在于 Android 端元素 overflow 默认值为 hidden，但目前 Android 暂不支持设置 overflow: visible。 示例 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"box box1\"&gt; &lt;/div&gt; &lt;div class=\"box box2\"&gt; &lt;/div&gt; &lt;div class=\"box box3\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; &#125; .box &#123; width: 400; height: 400; position: absolute; &#125; .box1 &#123; top: 0; left: 0; background-color: #ff0000; &#125; .box2 &#123; top: 150; left: 150; background-color: #0055dd; &#125; .box3 &#123; top: 300; left: 300; background-color: #00ff49; &#125;&lt;/style&gt; 体验一下 其他基本样式 opacity {number}：取值范围为 [0, 1] 区间。默认值是 1，即完全不透明；0 是完全透明；0.5 是 50% 的透明度。 background-color {color}：设定元素的背景色，可选值为色值，支持RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red），默认值是 transparent 。 注意： 色值的关键字列表。 上手样式如果对于样式写法需要更多上手参考，可参考 如何做出高性能长列表 如何布局 以及每个组件的文档中，都有常见的例子可供参考。 你可以按照以下步骤来规划 Weex 页面的样式。 全局样式规划：将整个页面分割成合适的模块。 flex 布局：排列和对齐页面模块。 定位盒子：定位并设置偏移量。 细节样式处理：增加特定的具体样式。","type":"references"},{"title":"ViewModel 选项","path":"cn/references/component-defs.html","permalink":"http://alibaba.github.io/cn/references/component-defs.html","text":"组件定义定义组件是通过一组选项来描述一个组件。这组选项总是被赋值给 &lt;script&gt; 标签中的 module.exports 。 module.exports = &#123; // a set of options here&#125; 数据和方法module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, methods: &#123; doThis: function () &#123;...&#125;, doThat: function () &#123;...&#125; &#125;, ...&#125; data 选项是一个函数，它返回这个视图模型可监听的数据对象。而 methods 是一个映射，其中包含所有视图模型的方法。 每个 data 或 method 属性将被代理到视图模型实例中。所以，你能通过 this.x 读写数据，或者通过 this.doThis() 调用方法。 一个完整的例子： &lt;template&gt; &lt;div style=\"width: &#123;&#123;w&#125;&#125;; height: &#123;&#123;h&#125;&#125;; background-color: red;\" onclick=\"update\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123; return &#123;w: 750, h: 200&#125; &#125;, methods: &#123; update: function (e) &#123; this.h += 200 &#125; &#125; &#125;&lt;/script&gt; 事件module.exports = &#123; data: ..., methods: &#123; foo: function () &#123; ... this.$emit('customtype1', data) &#125; &#125;, events: &#123; customtype1: function (e) &#123; console.log(e.type, e.detail) &#125; &#125;, ...&#125; events 选项允许你在视图模型被创建时注册自定义事件。然后，它会监听这些类型的事件，并通过函数类型的值处理它们。 Weex 会把一个事件对象作为第一个参数传递给其绑定的事件，这个事件对象在 e.detail 中包含事件数据。 生命周期module.exports = &#123; data: ..., methods: ..., init: function () &#123; console.log('ViewModel constructor begins') &#125;, created: function () &#123; console.log('Data observation finished') &#125;, ready: function () &#123; console.log('Virtual DOM finished') &#125;, ...&#125; Weex 视图模型现在支持生命周期内的钩子函数，这些钩子函数能被写为组件选项： init: 在视图模型的构造函数开始调用时激活； created: 当视图模型监听默认数据，但还未编译模板时激活； ready: 当视图模型监听默认数据并且编译模板生成虚拟DOM后被激活。 注意：当 methods、events 或生命周期方法作为参数传递给别的函数时，务必确认函数执行时的上下文符合您的预期，例如： module.exports = &#123; data: function () &#123; return &#123;x: 1, y: 2&#125; &#125;, ready: function () &#123; // `undefined` // 因为上下文发生了变化 this.foo(this.bar) // `1` // 正确绑定上下文之后可以得到预期的值 this.foo(this.bar.bind(this)) &#125;, methods: &#123; foo: function (fn) &#123; return fn() &#125;, bar: function () &#123; return this.x &#125; &#125;&#125;","type":"references"},{"title":"手势","path":"cn/references/gesture.html","permalink":"http://alibaba.github.io/cn/references/gesture.html","text":"手势注：该功能属于实验性功能 Weex 封装了原生的触摸事件以提供手势系统。使用手势类似于在 Weex 中使用事件，只需在节点上设置 on 特性来监听手势即可。 手势类型目前，仅支持以下四种手势类型： Touch：当触摸到一个点，移动或从触摸面移开时触发 touch 手势。触摸手势很精准，它会返回所有详细的事件信息。所以，监听 touch 手势可能很慢，即使只移动一丁点也需要处理大量事件。有三种类型的 touch 手势： touchstart 将在触摸到触摸面上时触发。 touchmove 将在触摸点在触摸面移动时被触发。 touchend 将在从触摸面离开时被触发。 Pan：pan 手势也会返回触摸点在触摸面的移动信息，有点类似于 touch 手势。但是 pan 手势只会采样收集部分事件信息因此比 touch 事件要快得多，当然精准性差于 touch。pan 也有三中类型的手势，这些手势的意义与 touch 完全一样： panstart panmove panend Swipe：swipe 将会在用户在屏幕上滑动时触发，一次连续的滑动只会触发一次 swiper 手势。 LongPress：LongPress 将会在触摸点连续保持 500 ms以上时触发。 touch 和 pan 非常接近，它们的特点可以总结成这样： Touch：完整信息，精准、很慢 Pan：抽样信息，很快，不够精准 开发者可以根据自己的情况选择合适的手势。 属性以下属性可以在手势的回调中使用： direction：仅在 swipe 手势中存在，返回滑动方向，返回值可能为 up, left, bottom, right。 changedTouches：一个数组，包含了当前手势的触摸点的运动轨迹 changedToucheschangedTouches 是一个数组，其子元素中包含以下属性： identifier：触摸点的唯一标识符。 pageX：触摸点相对于文档左侧边缘的 X 轴坐标。 pageY：触摸点相对于文档顶部边缘的 Y 轴坐标。 screenX：触摸点相对于屏幕左侧边缘的 X 轴坐标。 screenY：触摸点相对于屏幕顶部边缘的 Y 轴坐标。 约束目前，由于会触发大量事件冲突，Weex Android 还不支持在滚动类型的元素上监听手势，例如 scroller, list 和 webview 这三个组件。 示例&lt;template&gt;2&lt;div ontouchstart=\"handleTouchstart\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123;2methods: &#123;22handleTouchstart: function(eventProperties) &#123;222// handling with the Event Properties22&#125;2&#125;&#125;&lt;/script&gt; 如上面代码所示，一个 touchstart 事件会在触摸点与触摸面接触的时候触发。","type":"references"},{"title":"Bootstrap","path":"cn/references/index.html","permalink":"http://alibaba.github.io/cn/references/index.html","text":"Bootstrap除了其默认的意义，&lt;script&gt;标签支持在页面的顶级组件中通过 type 属性定义两种配置。 type=&quot;data&quot;: 配置初始化数据，这里定义的数据会覆盖定义在&lt;script&gt;中的数据； type=&quot;config&quot;: 定义配置项。 &lt;script type=\"data\"&gt; /* (可选) 定义初始化数据 */&lt;/script&gt;&lt;script type=\"config\"&gt; /* (可选) 定义配置项 */&lt;/script&gt; 定义初始化数据有时，很难在默认的&lt;script&gt;标签中维护巨大的数据结构。所以 Weex 允许我们通过 &lt;script type=&quot;data&quot;&gt; 标签定义初始化数据。在这里定义的数据将完全取代默认的 &lt;script&gt; 标签中定义的数据。 例如： &lt;script type=\"data\"&gt; module.exports = &#123; title: 'Alibaba', date: new Date().toLocaleString() &#125;&lt;/script&gt; 配置项Weex 也允许我们通过 &lt;script type=&quot;config&quot;&gt; 定义一些配置项，目前，仅只支持配置 downgrade。 downgrade.osVersion downgrade.appVersion downgrade.weexVersion downgrade.deviceModel","type":"references"},{"title":"","path":"cn/references/replace.html","permalink":"http://alibaba.github.io/cn/references/replace.html","text":"Replace optionThe replace option is boolean type. It determined whether this composed component will be replaced with the &lt;template&gt; content or just as a normal &lt;div&gt; element which include the &lt;template&gt; content. For example: &lt;element name=&quot;foo&quot;&gt; &lt;template&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; replace: false // by default &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;foo&gt;&lt;/foo&gt;&lt;/template&gt; will rendered as: &lt;div&gt; &lt;text&gt;Foo&lt;/text&gt;&lt;/div&gt; but: &lt;element name=&quot;foo&quot;&gt; &lt;template&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; replace: true &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;foo&gt;&lt;/foo&gt;&lt;/template&gt; will rendered as: &lt;text&gt;Foo&lt;/text&gt; So you can choose a way you need or like to manage your virtual DOM structure."},{"title":"特殊元素","path":"cn/references/special-element.html","permalink":"http://alibaba.github.io/cn/references/special-element.html","text":"特殊元素&lt;content&gt;&lt;content&gt; 在编写组件模板时作为作为内容节点元素存在，使用时将被真正的元素替换。 替代写法: &lt;slot&gt;。 示例如示例中写法，&lt;content&gt; 节点被 &lt;text&gt; 替代。 &lt;element name=\"item\"&gt; &lt;template&gt; &lt;div&gt; &lt;content&gt;&lt;/content&gt; &lt;/div&gt; &lt;/template&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;item&gt; &lt;text&gt;Content Text&lt;/text&gt; &lt;/item&gt; &lt;/div&gt;&lt;/template&gt; 体验一下","type":"references"},{"title":"文本样式","path":"cn/references/text-style.html","permalink":"http://alibaba.github.io/cn/references/text-style.html","text":"文本样式v0.5+ 文本类组件共享一些通用样式, 这类组件目前包括 &lt;text&gt; 和 &lt;input&gt;。 属性 color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 &lt;text&gt; 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}：字体粗细程度。可选值 normal | bold，默认为 normal。 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其它参考 颜色关键字列表。","type":"references"},{"title":"CSS 单位","path":"cn/references/units.html","permalink":"http://alibaba.github.io/cn/references/units.html","text":"CSS 单位CSS color 单位支持以下写法： .classA &#123; /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray;&#125; 注意 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看 颜色名称列表. CSS length 单位在 Weex 中，我们只支持 px 长度单位。并且它将在 JavaScript 运行时和本机渲染器中解析为数字类型。所以你也可以省略 px 单位后缀，直接写数字。 下面这些不同的写法，解析的结果完全相同。 .classA &#123; font-size: 48; line-height: 64; &#125;.classB &#123; font-size: 48px; line-height: 64px; &#125; 不支持类似 em，rem，pt 这样的 CSS 标准中的其他长度单位。 CSS number 单位仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 注意：也可以将所有的 px length 值简化为一个数字。 CSS percentage 单位 (暂不支持)表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 Weex 暂不支持。","type":"references"},{"title":"Devtools for Android","path":"cn/tools/devtools-android.html","permalink":"http://alibaba.github.io/cn/tools/devtools-android.html","text":"Devtools for Android Weex devtools is a custom devtools for weex that implements Chrome Debugging Protocol inspired by Stetho, it is designed to help you quickly inspect your app and debug your JS bundle source in a chrome web page.At present The devtools consist of two part : Inspector and Debugger. If you want it work well, you must install a weex-devtool as debug server. InspectorInspector can be used to show your Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View and so on. DebuggerDebugger can be used to debug your bundle js source, you can set Breakpoint \\ watch CallStack. Install and launch devtools serverOpen your terminal then type npm install -g weex-toolkit and run.Launch it just type and run the command weex debug, then a Chrome web page will be opened. Use on an android device or emulatorTaste of first debug with playgroundIf you are a green hand to the debug of weex, we recommend you to try your first debug with playground, what you need to do is just launch the playground and scan the QR code shown in the debug page which wound opened if the devtools server have been launched. after you scan the QR code, the web page will list your connected devices. How Debugger WorksDevtools expands Chrome Debugging Protocol and the mechanism of communication between client and debug sever is based on JSON-RPC. Devtools ClientDevtools Client is integrated in App as aar, it connects to debug server through webscoket protocol with out permission check. I recommend you just packaged it in your debug version consider of the security mechanism. Devtools Debug ServerDevtools Debug Server is the center node of the communication, it connects to both app and chrome, acts as the turn server of debugging protocol messages and the manager of the js runtime. Chrome FrontEndChrome’s V8 engine acts as the javascript runtime, when debug mode is enabled, all the js code run on it. On the other side we also reuse most of the Chrome’s debugging user interface, such as set breakpoint, see call stack and so on. Enable devtools in your own appOf course you can reuse the code of playground to build your own app, that is the simplest way to let your app’s js code debuggable. On the other hand QR code is not necessary, if your review the source code you can draw a conclusion that QR CODE is just a way to set devtools server address. following those steps you can do the same thing. Gradle dependency on inspector.There are two choices to set the dependency, the Choice A is recommanded if you have no change to weex_sdk or inspector, while if you use your own custom weex_sdk or inspector Choice B is suitable. A - aar dependency from jcenter.dependencies &#123; compile &apos;com.taobao.android:weex_inspector:0.0.8.1&apos;&#125; I strongly recommend you use the latest version since both weex sdk and devtools are developed iteratively and rapidly. See the release version list here. All the release version will publish to the jcenter repo. B - source code dependency. you need to copy the dir of inspector to the same dir of your app and add include &quot;:inspector&quot;in your project’s settings.gradle file just like playground have done, then add dependency in your app’s build.gralde. dependencies &#123; compile project(&apos;:inspector&apos;)&#125; Version compatibility weex sdk weex inspector debug server 0.8.0.1+ 0.0.8.1 0.2.39+ 0.7.0+ 0.0.7.13 0.2.38 0.6.0+ 0.0.2.2 Initialize in your XXXApplication file. public class MyApplication extends Application &#123; public void onCreate() &#123; super.onCreate(); initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;/*&quot;DEBUG_SERVER_HOST&quot;*/); &#125; private void initDebugEnvironment(boolean enable, String host) &#123; WXEnvironment.sRemoteDebugMode = enable; WXEnvironment.sRemoteDebugProxyUrl = &quot;ws://&quot; + host + &quot;:8088/debugProxy/native&quot;; &#125;&#125; Ship It! You must launch your bundle server firstly. In your weex dir, run command “./start”; Launch your remote debug server. Run command weex debug, chrome will open a web page show a simply guidance and QR code; Launch your app and make sure debug mode was enabled. You will see a device list in the chrome web page opened by last step, each device item have two button, Debugger and Inspector;There are two way to enable debug mode: scaning the QR code and handle the content just like the playground have done. init it in the XXXApplication by calling initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;), if you call initDebugEnvironment(true, &quot;xxx.xxx.xxx.xxx&quot;) after weex sdk inited, you need to call WXSDKEngine.reload() to refresh the runtime. Once you click the button Inspector chrome will open a page show the inspector view, on the other side, click the button Debugger chrome will open a new page to show the debug view; OPTIONS[OPTION] set your remote bundle server ip.For example, in the playground it is in the `IndexActivity.java`, you need to change the value of `DEFAULT_IP` in IndexActivity.java from `&quot;your_current_IP&quot;` to a server ip like `&quot;30.30.30.150&quot;`: private static final String DEFAULT_IP = &quot;30.30.30.150&quot;; // &quot;your_current_IP&quot;; [OPTION] enable network inspection.OkHttpClient client = new OkHttpClient();client.networkInterceptors().add(new OkHttpInterceptor()); Notice The network inspection only support OKHttpClient right now!!! If you want to use the network inspection to catch your bundle request, you must change your bundle server ip to the real server ip. Known Issues You can report issues and bugs here. We will reply as soon as possible.","type":"tools"},{"title":"Devtools for iOS","path":"cn/tools/devtools-ios.html","permalink":"http://alibaba.github.io/cn/tools/devtools-ios.html","text":"Devtools for iOS通过Chrome开发者工具远程调试你的原生iOS app 启动weex-devtool： 安装和运行 weex-devtool $:npm install -g weex-devtool$:weex-devtool 它会启动chrome浏览器，展示wss ip 地址在chrome地址栏。 playground 安装 WXDevtool 安装依赖. $:pod install 使用 AppDelegate.m 头文件 #import &quot;WXDevTool.h&quot; 在App启动的时候初始化 inspector 注意: The inspector API 必须在weex初始化之前调用 (void)setDebug:(BOOL)isDebug; isDebug默认是NO，那么你打开的是inspect模式。假如设置isDebug为YES，那么打开debug模式和inspect模式。 (void)launchDevToolDebugWithUrl:(NSString *)url; wssip 是 展示在 chrome 地址栏的wss 地址. 打开 debug 模式 和 inspector 模式 eg：- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } 打开 inspect 模式, 移除 @selector(setDebug:) 或者 增加 [WXDevTool setDebug:NO] eg：- (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions { [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://wssip/debugProxy/native&quot;]; } 编译和运行APP，chrome会显示你的设备，选择inspector。 支持不同级别的Log打印。 eg: #import “WXDevTool.h” PDLogE()/PDLogW() WXDevtool依赖 你的app必须链接下面的frameworks/dylibs libicucore.dylib CFNetwork.framework CoreData.framework Security.framework Foundation.framework","type":"tools"},{"title":"Devtools","path":"cn/tools/devtools.html","permalink":"http://alibaba.github.io/cn/tools/devtools.html","text":"Devtoolsweex devtools是专门为weex定制的一款实现了Chrome Debugging Protocol的inspect/debug工具，能够帮助你快速查看app运行状态和调试weex中的Javascript代码，当前支持IOS和Android两个平台。 安装$ npm install -g weex-toolkit 用法 weex debug [options] [we_file|bundles_dir] 选项: -h, --help 显示帮助-V, --verbose 显示debug服务器运行时的各种log-v, --version 显示版本-p, --port [port] 设置debug服务器端口号 默认为8088-e, --entry [entry] debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码)-m, --mode [mode] 设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer 开启调试$weex debug 单纯启动一个调试服务器,并同时唤起chrome浏览器打开调试主页.这个调试主页上会有一个二维码,使用Playground App扫这个二维码可以开启Playground调试.开启调试后,设备列表中会出现您的设备,根据提示进行后续的调试操作 调试 we文件$weex debug your_weex.we 这个命令会将your_weex.we编译成bundlejs文件 部署到debug服务器并启动debug服务器如上述命令那样.打开的调试主页会多显示一个二维码,使用playground app扫这个码可以加载your_weex.we.(注意要先扫描开启调试的那个码)这个命令会自动检测your_weex.we文件变动,如果发现内容被修改则立即重新编译部署,并刷新debugger页面. 调试整个bundle/we文件夹$weex debug your/we/path -e index.we 这个命令会编译你指定目录下的所有的we文件,并把编译好的bundlejs部署到debug服务器,他们的地址会映射到 http://lcoalhost:8088/weex/ 下比如 your/we/path/index.we 可以通过http://lcoalhost:8088/weex/index.js访问your/we/path/demo/test.we 可以通过http://lcoalhost:8088/weex/demo/index.js -e参数可以指定一个入口的we文件,这个文件的地址会显示在调试主页上(作为二维码) 特性连接设备 Inspector Inspector 能够用来查看 Element \\ NetWork \\ Console log \\ ScreenCast \\ BoxModel \\ Native View 等。 Element NetWork查看网络请求的总耗时和延时 查看网络请求的header和response 控制台 资源 Debugger 调试器用来调试weex中的js代码，能够设置断点、查看调用栈。 Breakpoint and CallStack 集成devtools Android 请参考文档 Weex devtools (Android), 其中有详细说明。 IOS 请参考文档 Weex devtools (IOS), 其中有详细说明。","type":"tools"},{"title":"CLI (英)","path":"cn/tools/index.html","permalink":"http://alibaba.github.io/cn/tools/index.html","text":"CLIPlease access npmjs.com for latest version Weex CLI tool set Pre Installsome dependencies need recent version of npm to install if your$ npm --version output less then 2.15.1, please run below cmd upgrade your npm at firstsudo npm install -g npm Install$npm install -g weex-toolkit Usage$weex foo/bar/input_path [options] $weex create file_name [options]Options: --qr display QR code for native runtime, **default action** -o,--output transform weex we file to JS Bundle, output path (single JS bundle file or dir) [for create sub cmd] it specified we file output path --watch using with -o , watch input path , auto run transform if change happen -s,--server start a http file server, weex .we file will be transforme to JS bundle on the server , specify local root path using the option --port http listening port number ,default is 8081 --wsport websocket listening port number ,default is 8082 -f, --force [for create sub cmd] force to replace exsisting file(s) --version show version of weex toolkit --help Show help Examplescrate a we file(weex source file) using standard template$weex create hello-world-weex a file named ‘hello-world-weex.we’ we be created in current directory transform a we file to JS Bundle$weex your_best_weex.we -o . your_best_weex.we will be transform to JS Bundle file your_best_weex.js , saved in your current directory transform a we file to JS Bundle , watch this file ，auto run transformer if change happen.$weex your_best_weex.we -o . --watch transform every we file in a directory$weex we/file/storage/path -o outputpath every we file in we/file/storage/path we be transform to JS Bundle , saved in outputpath path preview your we file using Weex Playground Appdownload &amp; install weex playground App$weex your_best_weex.we --qr a QR code will display in your terminal , using Playground App scan that. start http server$weex -s . a http server will start running , your current directory(.) will be the document root for the server , every weex .we file will be transforme to JS Bundle when access through the server Issue &amp; FeedbackGithub Issue List","type":"tools"},{"title":"Playground","path":"cn/tools/playground.html","permalink":"http://alibaba.github.io/cn/tools/playground.html","text":"Weex Playground AppWeex 的最棒的一个部分是 Native Runtime。你的 .we 文件可以使用 weex-toolkit CLI 在浏览器中预览 Web 效果，也可以通过 Weex Playground App 这样一个单独的应用来预览原生效果。不仅如此，Weex playground App 还内置了大量的 Demo 和展示案例，这样你就可以更加容易地体验到 Weex 在 Native 层面的效果了。 Playground App 的下载地址在 这里。 截图： 上图就是 Weex Playground App 的主界面，点击列表中的每一项即可进入某个 Demo 或者展示案例。用 Weex toolkit CLI 生成二维码，用 Weex Playground App 扫描二维码（点击右上角图标即可开始扫描）可以预览你的文件。 请参阅 起步教程。","type":"tools"},{"title":"Transormer (英)","path":"cn/tools/transformer.html","permalink":"http://alibaba.github.io/cn/tools/transformer.html","text":"gulp-weex gulp plugin for weex transformer Usagevar gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) OptionsoldFormatwhether transform to old format. default: false. isEntrywhether is an entry module which has bootstrap(...). default: true.","type":"tools"},{"title":"Customize a native Component","path":"guide/how-to/customize-a-native-component.html","permalink":"http://alibaba.github.io/guide/how-to/customize-a-native-component.html","text":"How to customize a native Component ?Weex has wrapped up the most critical platform components, such as ScrollView, ListView, Text, Imageview and so on. Certainly these components can not completely meet your need. And thousands of native UI components that always be using in our project may be required to integrate into Weex easily. Fortunately, it’s quite convenient to wrap up your own components that should be from any existing components. Step By Step Customized components must inherit from WXComponent or WXContainer; @WXComponentProp(name=value(value is attr or style of dsl)) for it be recognized by weex SDK; The access levels of method must be public; The component class can not be an inner class; Customized components should not be obfuscated by tools like ProGuard; Component methods will be invoked on the UI thread, so do not contain time-consuming operations here; Weex parameter’s type can be int, double, float, String, Map, List, self-defined class that implements WXObject interface; Refer to the following example:package com.taobao.weex.ui.component;……public class MyViewComponent extends WXComponent&#123; public MyViewComponent(WXSDKInstance instance, WXDomObject node, WXVContainer parent, String instanceId, boolean lazy) &#123; super(instance, node, parent, instanceId, lazy); &#125; @Override protected void initView() &#123; //TODO:your own code …… &#125; @Override public WXFrameLayout getView() &#123; //TODO:your own code ……… &#125; @WXComponentProp(name=WXDomPropConstant.WX_ATTR_VALUE) public void setMyViewValue(String value) &#123; ((TextView)mHost).setText(value); &#125;&#125; Component should be registeredWXSDKEngine.registerComponent(\"MyView\", MyViewComponent.class);","type":"guide"},{"title":"Customize native APIs","path":"guide/how-to/cuszomize-native-apis.html","permalink":"http://alibaba.github.io/guide/how-to/cuszomize-native-apis.html","text":"How to customize native APIs ?Weex SDK provides only rendering capability, rather than having other capabilities, such as network, picture, and URL redirection. If you want the these features, you need to implement them yourselves.The example below will describe how to extend weex with native logic or ‘bridge’ your existed native code. A URLHelper ExampleCreate your own WXModule in native:public class URLHelperModule extends WXModule&#123;2private static final String WEEX_CATEGORY=\"com.taobao.android.intent.category.WEEX\";2@WXModuleAnno2public void openURL(String url)&#123;22if (TextUtils.isEmpty(url)) &#123;222return;22&#125;22StringBuilder builder=new StringBuilder(\"http:\");22builder.append(url);22Uri uri = Uri.parse(builder.toString()); Intent intent = new Intent(Intent.ACTION_VIEW, uri);22intent.addCategory(WEEX_CATEGORY); mWXSDKInstance.getContext().startActivity(intent);2&#125;&#125; Notice the @WXModuleAnno, use this annotation to mark the methods you wanna expose to javascript.If your also want to callback to javascript, you should define a callbackId parameter to received ‘JS callback function id’: public class URLHelperModule extends WXModule&#123;22@WXModuleAnno2public void openURL(String url,String callbackId)&#123;22//...22//callback to javascript 22Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();22result.put(\"ts\", System.currentTimeMillis());22WXBridgeManager.getInstance().callback(mWXSDKInstance.getInstanceId(), callbackId, result);2&#125;&#125; Register your module to engine:try &#123;2 WXSDKEngine.registerModule(&quot;myURL&quot;, URLHelperModule.class);//&apos;myURL&apos; is the name you&apos;ll use in javascript2&#125; catch (WXException e) &#123;2 WXLogUtils.e(e.getMessage());2&#125; Now, you can use eventModule in javascript like this:let URLHelper = require('@weex-module/myURL');//same as you registeredURLHelper.openURL(\"http://www.taobao.com\",function(ts)&#123;2console.log(\"url is open at \"+ts);&#125;); Things you need to note: Customized components must inherit from WXModule; @WXModuleAnno annotation must be added, as it is the only way to be recognized by Weex; The access levels of method must be public; The module class also can not be an inner class; Customized components should not be obfuscated by tools like ProGuard; Module methods will be invoked on the UI thread, so do not put time-consuming operations there; Weex parameter’s type can be int, double, float, String, Map, List, self-defined class that implements WXObject interface;","type":"guide"},{"title":"Debug in html5 renderer","path":"guide/how-to/debug-with-html5.html","permalink":"http://alibaba.github.io/guide/how-to/debug-with-html5.html","text":"How to debug in html5 renderer ?Since weex-html5 can run on a modern mobile browser, it’s naturally supported to debug weex-html5 code in browsers’ dev tools. Use browser’s devTools to iterate, debug and profile your weex-html5 app. Take chrome’s debug tool as a example: ElementsUse elements’ panel to inspect the layout and design of the weex-html5 page, and manipulate the DOM and CSS to do some experiment freely. ConsoleYou can use console.log to log information on console, but it’s highly recommended to use nativeLog instead, since nativeLog can run on a native platform based on a browser. The defect of nativeLog is that it’s not supported to trace it from the console to the source file which the nativeLog is called in, therefore in this situation you’d better use console.log, and you should make sure this code will not run on native platform (otherwise a exception or a crash will be caused). BreakpointsYou can set breakpoints to debug code. Breakpoints are one of the most effective way to debug code. Breakpoints enable you to pause script execution and then investigate the call stack variable values at that particular moment in time. Manual breakpoints are individual breakpoints that you set on a specific line of code. You can set these via Chrome DevTools GUI, or by inserting the debugger keyword in your code. Locate your bugGenerally speaking, there are three possible layer the bug could happen on: the renderer (weex-html5), the js-framework (weex-js-framework) and the transformer (gulp-weex). Here are some suggestions to locate your bug so that you can recognize which layer the bug is on: check the console for errors. In debug mode if there is a error happend there will be info about it on the console. in bridge/receiver.js, whether the callNative function is called. whether the supposed to be called API method is actually called and executed. whether the callJS method for event firing or callback executing is called. otherMore info about how to debug h5 pages on chrome devTools: chrome’s devTools docs","type":"guide"},{"title":"Preview in browser","path":"guide/how-to/index.html","permalink":"http://alibaba.github.io/guide/how-to/index.html","text":"How to preview weex code in browser ?weex-toolkitWe strongly suggest you use weex-toolkit to preview weex code in your browser. This tool is Node.JS based, so you need to install Node at first. Please download and install latest stable version of Node from https://nodejs.org/en/download/stable/. Then you can install weex-toolkit using npm install: $ npm install -g weex-toolkit Check that the toolkit does work by typing weex in the command line. Normally you should see the following help text: Options: --qr display QR code for native runtime, -o,--output transform weex we file to JS Bundle, output path (single JS bundle file or dir) -s,--server start a http file server, weex .we file will be transforme to JS bundle on the server , specify local root path using the option ...... --help Show help If all work well, navigate to the path the xxx.we file you want to preview in, and type the command: weex xxx.we A browser window will be opened automatically to display the page you want to preview:","type":"guide"},{"title":"Preview in native","path":"guide/how-to/preview-in-playground-app.html","permalink":"http://alibaba.github.io/guide/how-to/preview-in-playground-app.html","text":"How to preview weex code in sample-app ?Weex Sample Step By Step Clone Weex from github https://github.com/alibaba/weex/ Use Android Studio open Android Sample 。 run Sample project. into Sample homePage，you will see this picture Click the icon to the top right of the page to enter the two-dimensional code scanning useWeex-Toolkitmake .we to a QR code you will see the page rended by Weex","type":"guide"},{"title":"Require 3rd Party Libs","path":"guide/how-to/require-3rd-party-libs.html","permalink":"http://alibaba.github.io/guide/how-to/require-3rd-party-libs.html","text":"How to require 3rd Party Libs ?In the paragraph Maintain Your Component Code, we learn that JavaScript code can be written in &lt;script&gt; tag in one component. But there must be some common functions or modules in your project, such as parsing url params, extending properties from some objects to another object and so on. It’s a bad practice to copy and paste them in each component, therefore there’s a urgent need of require. Weex provides CommonJS require syntax for developers. Let take extend for example. Require Local Js ModulesA basic implementation of extend is as follows, and it’s placed in directory path ./common/utils.js. function extend(dest, src) &#123; for (var key in src) &#123; dest[key] = src[key] &#125;&#125;exports.extend = extend In a .we file, extend can be used with the help of require: &lt;script&gt; var utils = require('./common/utils') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; utils.extend(obj1, obj2) // obj1 =&gt; &#123;a: 1, b: 2&#125;&lt;/script&gt; Require Installed Node ModulesBesides, underscore is a JavaScript library that provides a whole mess of useful functional programming helpers without extending any built-in objects. It implements a more robust version of extend. We can use underscore’s extend instead of the version implemented by ourselves. After installing underscore to the node_modules directory, we can require and use it. $ npm install underscore &lt;script&gt; var _ = require('underscore') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; var obj3 = &#123;c: 3&#125; var ret = _.extend(obj1, obj2, obj3) // ret =&gt; &#123;a: 1, b: 2, c: 3&#125;&lt;/script&gt;","type":"guide"},{"title":"Transform Code into Js Bundle","path":"guide/how-to/transform-code-into-js-bundle.html","permalink":"http://alibaba.github.io/guide/how-to/transform-code-into-js-bundle.html","text":"Transform Code into Js BundleParagraphs Maintain Your Component Code and Require 3rd Party Libs show us how to write and organize weex code. However, Weex DSL code must be transformed to js bundle so that js framework can parse and execute it for iOS, Android and HTML5 portal. For more information, please refer to How It Works and JS Bundle Format. Now come back to the topic transform code into js bundle. There are several ways to achieve the goal. weex-toolkit$ npm install -g weex-toolkit transform a we file to JS Bundle$ weex your_best_weex.we -o . your_best_weex.we will be transform to JS Bundle file your_best_weex.js , saved in your current directory transform a we file to JS Bundle , watch this file ，auto run transformer if change happen.$ weex your_best_weex.we -o . --watch transform every we file in a directory$ weex we/file/storage/path -o outputpath every we file in we/file/storage/path will be transformed to JS Bundle , saved in outputpath path please access npmjs.com for more information about weex-toolkit. transformernpm install weex-transformer CLI ToolUsage: transformer [options] &lt;file...&gt;Options: -h, --help output usage information -V, --version output the version number -l, --oldFormat [value] whether to transform to old format (default: false) -e, --isEntry [value] whether is an entry module which has `bootstrap` (default: true) -o, --output [path] the output file dirname API transform(name, code, path, elements, config) var transformer = require('weex-transformer')var output = transformer.transform('foo', '/* code here */', '.', &#123;&#125;) params: name: string, current bundle name code: string, source code path: string optional, useful when find custom component in a certain path elements: object optional, existed custom component map config: object optional oldFormat: whether to transform to old format (default: false) isEntry: whether is an entry module which has bootstrap (default: true) returns: an object with keys result: string, all custom components define() and final bootstrap() logs: array, corresponding warning &amp; error logs gulp weex$ npm install gulp-weex var gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) Options: oldFormat: whether to transform to old format (default: false) isEntry: whether is an entry module which has bootstrap (default: true)","type":"guide"},{"title":"Communications","path":"guide/syntax/comm.html","permalink":"http://alibaba.github.io/guide/syntax/comm.html","text":"Communicate Between ComponentsFor Child-Parent CommunicationChildren component can use this.$dispatch([String type], [Object detail]) method passing information to parent component. first argument meaning type of message , second argument is the message object. If any parent of the child component register the same type of listener using $on([String type], [Function callback]) method , the callback will be execute with one argument , the message object will be detail property of the the argument. eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; this.$dispatch('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;foo title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; this.$on('notify', function(e) &#123; // when &lt;foo&gt; image tag be clicked ,the function will be executing. // e.detail is `&#123;a: 1&#125;` &#125;) &#125; &#125;&lt;/script&gt; For Parent-Child CommunicationParent component can use this.$vm([String id]) get vm instance of child component. you can access child component information using the vm instance. &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; setTitle: function (t) &#123; this.title = t &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo id=\"fooEl\" title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; var foo = this.$vm('fooEl') foo.setTitle('...') foo.imageUrl = '...' &#125; &#125; &#125;&lt;/script&gt; Parent to Children (multi-child) CommunicationParent can using this.$broadcast([String type], [Object detail]) broadcast message to all of children. eg: &lt;we-element name=\"bar\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; var self = this this.$on('changeImage', function(e) &#123; self.imageUrl = e.detail.imageUrl &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;bar&gt;&lt;/bar&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '' &#125;, created: function() &#123; var self = this this.$on('changeTitle', function(e) &#123; self.title = e.detail.title &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$broadcast('changeTitle', &#123; title: '...' &#125;) this.$broadcast('changeImage', &#123; imageUrl: '...' &#125;) &#125; &#125; &#125;&lt;/script&gt; Siblings Communicationsiblings components can using common parent as bridge for passing information eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; methods: &#123; callbar: function () &#123; this.$dispatch('callbar', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"bar\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; created: function() &#123; this.$on('callbar', function(e) &#123; // e.detail.a &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; var self = this this.$on('callbar', function(e) &#123; self.$broadcast('callbar', e.detail) &#125;) &#125; &#125;&lt;/script&gt; At last, you can learn how to write config &amp; data for a Weex page.","type":"guide"},{"title":"Composed Component","path":"guide/syntax/composed-component.html","permalink":"http://alibaba.github.io/guide/syntax/composed-component.html","text":"Composed ComponentIf some part of weex file is reused often, you could create a composed component represent these part. You can create a file named foo.we to define a composed component, the component name is just &lt;foo&gt;. &lt;!-- foo.we --&gt;&lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\" style=\"width:100;height:100;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: null, image: null &#125; &#125;&lt;/script&gt; The content of foo.we also consists of &lt;template&gt;, &lt;style&gt; and &lt;script&gt;. Once composed component been defined, you can use &lt;foo&gt; in a file which is in the same folder with foo.we. &lt;template&gt; &lt;foo title=\"...\" image=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt; Nesting ComponentsComposed component supports nesting. For example: &lt;!-- somepath/foo.we --&gt;&lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; // The key is required if you want this property observed // and could be updated from changing parent attribute title: null, image: null &#125; &#125;&lt;/script&gt; &lt;!-- somepath/foo-list.we --&gt;&lt;template&gt; &lt;container&gt; &lt;text&gt;&#123;&#123;description&#125;&#125;&lt;/text&gt; &lt;foo repeat=\"&#123;&#123;list&#125;&#125;\" title=\"&#123;&#123;text&#125;&#125;\" image=\"&#123;&#123;img&#125;&#125;\"&gt;&lt;/foo&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; description: '', // If no keys written here. There will be no data binding effect // from parent attribute \"list\". list: [] &#125; &#125;&lt;/script&gt; &lt;!-- somepath/main.we --&gt;&lt;template&gt; &lt;foo-list list=\"&#123;&#123;list&#125;&#125;\"&gt;&lt;/foo-list&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; The main.we uses &lt;foo-list&gt; from foo-list.we. And &lt;foo-list&gt; uses &lt;foo&gt; from foo.we. Notes Every composed component have an independent &lt;style&gt; work scope. If child component have id attribute, you can access the context of the child component by this.$vm(id) and find an element by this.$el(id). See more about find an element. Please refer to communicate between components for more communication issues. The keys must be existed in data options explicitly if you want to make the data observation work both through inside data changes and outside attribute changes. Next is how to find an element.","type":"guide"},{"title":"Data-Binding","path":"guide/syntax/data-binding.html","permalink":"http://alibaba.github.io/guide/syntax/data-binding.html","text":"Data-BindingIn Weex, we use the mustache syntax {{...}} to bind data in &lt;template&gt; which are defined in &lt;script&gt;. Once data and template is bound, the data changes will influence the corresponding template content immediately and automatically. Binding data path&lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 48, title: 'Alibaba Weex Team' &#125; &#125;&lt;/script&gt; The code above will bind the title and size data field to template. We can also use . syntax to bind cascading data structure. Let’s look at the following code snippet: &lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;title.size&#125;&#125;\"&gt;&#123;&#123;title.value&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: &#123; size: 48, value: 'Alibaba Weex Team' &#125; &#125; &#125;&lt;/script&gt; In-template expressionInside data bindings, Weex supports simply javascript expressions, e.g. &lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125; &#125;&lt;/script&gt; The expression will be evaluated in the data scope of current context. NOTE: EACH BINDING CAN ONLY CONTAIN ONE SINGLE EXPRESSION Computed Properties0.5 According to simple operations, in-template expressions are very convenient. But if you want to put more logic into the template, you should use a computed property. e.g. &lt;template&gt; &lt;container style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left:10px;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName &#125;, set: function(v) &#123; var s = v.split(' ') this.firstName = s[0] this.lastName = s[1] &#125; &#125; &#125;, methods: &#123; changeName: function() &#123; this.fullName = 'Terry King' &#125; &#125; &#125;&lt;/script&gt; Here we have declared a computed property fullName. The function we provided will be used as the getter function for concating firstName and lastName. Otherwise when you call changeName after click, the setter will be invoked and this.firstName and this.lastName will be updated accordingly. NOTE: data and methods can’t have duplicated fields. ‘Cause in the execution context – this, we can access both of them. Usage of some special attributes in Data-BindingStyles: style or classthe style of a component can be bind using the style attribute: &lt;template&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;; color: &#123;&#123;color&#125;&#125;; ...\"&gt;...&lt;/text&gt;&lt;/template&gt; while style can also get bound with class attribute, multiple classnames can be split by spaces: &lt;template&gt; &lt;container&gt; &lt;text class=\"&#123;&#123;size&#125;&#125;\"&gt;&lt;/text&gt; &lt;text class=\"title &#123;&#123;status&#125;&#125;\"&gt;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; here if and have empty value, then only class=&quot;title&quot; will be rendered. See more about style and class Event Handler: on...The event handler is an attribute which name has a prefix on.... The other part of attribute name is event type and the value is event handler name. We don’t need to add mustache around the method name or add parentheses to call it. &lt;template&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; toggle: function () &#123; // todo &#125; &#125; &#125;&lt;/script&gt; if &amp; repeatif attribute can control the display of a component by a truthy/falsy value. &lt;template&gt; &lt;container style=\"flex-direction: column;\"&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image src=\"...\" if=\"&#123;&#123;shown&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; We can also use repeat attribute to generate a list. NOTE: When you want to mutate an array in data. Something limitations existing below: When you directly set an item with the index (vm.items[0] = {};), it won’t trigger view update. So we have a prototype methods: $set(index, item). // same as `example1.items[0] = ...` but triggers view updateexample1.items.$set(0, &#123; childMsg: 'Changed!'&#125;) When you modify the length of the Array (vm.items.length = 0), it won’t trigger view update too. We recommend you just replace items with an empty array instead. // same as `example2.items.length = 0` but triggers view updateexample2.items = [] See more about display logic control staticstatic attribute can cancel the data binding, and the data changes will not be synchronized to UI. &lt;template&gt; &lt;div static&gt; &lt;text&gt;&#123;&#123; word &#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; ready: function() &#123; this.word = 'Data changes' &#125;, data: &#123; word: 'Hello, static' &#125; &#125;&lt;/script&gt; As shown above, after the static attribute is added, the rendering result will be Hello, static, which is equivalent to rendering a static node. The change of the data word in ready function will not be listened, so the text value will not change.static property is designed to reduce the long list or pure static page memory overhead. Be careful with it, as it will likely break your page logic. Next, let’s have a look at style and class.","type":"guide"},{"title":"Display Logic Control","path":"guide/syntax/display-logic.html","permalink":"http://alibaba.github.io/guide/syntax/display-logic.html","text":"Display Logic ControlThere are two attributes for display logic control: if and repeat. We can create Weex page structure and effects more flexible with them. Notes: The display logic could’t apply on the root element within &lt;template&gt;, please don’t use if or repeat directive on it. ifif attribute can control the display of a component by a truthy/falsy value. If the value is truthy, then the component will generated, otherwise it will be removed. &lt;template&gt; &lt;container&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image src=\"...\" if=\"&#123;&#123;shown&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; repeatrepeat statement is just for array rendering. Every item in an array is also a structured data. This means in repeated component, you can bind their item properties directly. &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .male &#123;...&#125; .female &#123;...&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;gender: 'male', nickname: 'Li Lei', avatar: '...'&#125;, &#123;gender: 'female', nickname: 'Han Meimei', avatar: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; The origin data properties which not belongs to the array will also be bound: &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125; - &#123;&#123;group&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .male &#123;...&#125; .female &#123;...&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; group: '...', list: [ &#123;gender: 'male', nickname: 'Li Lei', avatar: '...'&#125;, &#123;gender: 'female', nickname: 'Han Meimei', avatar: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; An extension of repeat syntaxuse default $index for the index of array.e.g. &lt;div repeat=\"&#123;&#123;list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;&lt;/text&gt;&lt;div&gt; specify the key and value of array.e.g. &lt;div repeat=\"&#123;&#123;v in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;$index + 1&#125;&#125;, &#123;&#123;v.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; &lt;div repeat=\"&#123;&#123;(k, v) in list&#125;&#125;\"&gt; &lt;text&gt;No. &#123;&#123;k + 1&#125;&#125;, &#123;&#123;v.nickname&#125;&#125;&lt;/text&gt;&lt;/div&gt; use track-by to specify unique attributeBy default when replacing an array, repeat will cause the entire list to be re-rendered. However you can use track-by to specify an unique attribute as a hint, so that weex can reuse existing elements as much as possible. NOTE: DO NOT USE DATA-BINDING SYNTAX FOR track-by e.g. &lt;template&gt; &lt;container&gt; &lt;container repeat=\"&#123;&#123;list&#125;&#125;\" track-by=\"nickname\" class=\"&#123;&#123;gender&#125;&#125;\"&gt; &lt;image src=\"&#123;&#123;avatar&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;nickname&#125;&#125; - &#123;&#123;group&#125;&#125;&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt; Later on, when you replace the array including an item of the same nickname, it knows it can reuse the existing scope and DOM elements associated with the same nickname. Omitted mustache wrapperParticularly for the if and repeat attribute, the mustache wrapper in values could be omitted: just the same as data-binding syntax. &lt;template&gt; &lt;container&gt; &lt;text if=\"shown\"&gt;Hello&lt;/text&gt; &lt;text if=\"&#123;&#123;shown&#125;&#125;\"&gt;Hello&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: function () &#123;return &#123;shown: true&#125;&#125; &#125;&lt;/script&gt; The two &lt;text&gt; components are both displayed. Next is render logic control.","type":"guide"},{"title":"Page Config & Data","path":"guide/syntax/config-n-data.html","permalink":"http://alibaba.github.io/guide/syntax/config-n-data.html","text":"Page Config &amp; DataYou can write some instance config and data in some additional &lt;script&gt; at the top-level Weex component. the instance config could declare some meta informations like which sdk/client version it supports or “downgrade” to HTML5 renderer. This part would be extended more in the future. the instance data could set an external data which would be processed instead of the default top-level component data. They all make Weex files more extendable and configurable and works easy with other tools &amp; services like CMS system. &lt;!-- definition of sub components --&gt;&lt;element name=\"sub-component-a\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-b\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-c\"&gt;...&lt;/element&gt;&lt;!-- definition of top-level component --&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: function () &#123;return &#123;x: 1, y: 2&#125;&#125; &#125;&lt;/script&gt;&lt;!-- instance config and data --&gt;&lt;script type=\"config\"&gt; &#123; downgrade: &#123; ios: &#123; os: '9', // all of 9.x.x app: '~5.3.2', framework: '^1.3', // all of 1.3.x deviceModel: ['AAAA', 'BBBB'] &#125;, android: &#123; os: '*', // all of version app: '^5', framework: '', deviceModel: '' &#125; &#125; &#125;&lt;/script&gt;&lt;script type=\"data\"&gt; &#123;y: 200&#125;&lt;/script&gt; Notice that these two additional &lt;script&gt; are both optinal and have type=&quot;config|data&quot; attribute and only works when it’s the top-level component of a Weex instance. So that’s all about Weex syntax. For more reading, please check out: how-tos articles and advanced topics.","type":"guide"},{"title":"Events","path":"guide/syntax/events.html","permalink":"http://alibaba.github.io/guide/syntax/events.html","text":"EventsWeex allow &lt;template&gt; to bind event type and handler on an Element. The attribute name is the event type with prefix on... and the attribute value is handler method name. For instance: onclick=&quot;handler&quot;. e.g. &lt;template&gt; &lt;image onclick=\"handler\" ...&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; handler: function (e) &#123; // TODO &#125; &#125; &#125;&lt;/script&gt; When user clicks the image , handler function which defined in &lt;script&gt; code will be executed. Inline HandlerBeside a handler method name, you can also call a handler inline. e.g.&lt;template&gt; &lt;image onclick=\"handler('arg1', $event)\" ...&gt;&lt;/image&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; handler: function (arg1, e) &#123; // TODO &#125; &#125; &#125;&lt;/script&gt; Event ObjectWhen an event handler called, it will receive an event object as the first argument. Every event object will contains following properties. type: event name, eg: click target: target Element of the event timestamp: time stamp that event triggered Next, let’s have a look at display logic control.","type":"guide"},{"title":"Find an Element","path":"guide/syntax/id.html","permalink":"http://alibaba.github.io/guide/syntax/id.html","text":"Find an ElementIn Weex, we may set the id property for a particular element, just as unique identification of a particular element. id can be used by this.$el(id) to find an element with a certain id. Take the API scrollToElement() For example: &lt;template&gt; &lt;container&gt; &lt;text id=\"top\"&gt;Top&lt;/text&gt; &lt;container style=\"height: 10000; background-color: #999999;\"&gt; &lt;/container&gt; &lt;text onclick=\"back2Top\"&gt;Back to Top&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') module.exports = &#123; methods: &#123; back2Top: function () &#123; var top = this.$el('top') dom.scrollToElement(top) &#125; &#125; &#125;&lt;/script&gt; id can also work with repeat attribute See more about display logical control, and ensure repetitive elements with different id: &lt;template&gt; &lt;container&gt; &lt;image id=\"&#123;&#123;imgId&#125;&#125;\" src=\"&#123;&#123;imgUrl&#125;&#125;\" onclick=\"getImageId\" repeat=\"&#123;&#123;images&#125;&#125;\"&gt;&lt;/image&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; images: [ &#123;imgId: 1, imgUrl: '...'&#125;, &#123;imgId: 2, imgUrl: '...'&#125;, &#123;imgId: 3, imgUrl: '...'&#125;, ... ] &#125;, methods: &#123; getImageId: function(e) &#123; // get e.target.id &#125; &#125; &#125;&lt;/script&gt; Additionally, in the composed components, we can get the corresponding sub component through this.$vm(id) APIs. Next is how to send messages between composed components.","type":"guide"},{"title":"Syntax","path":"guide/syntax/index.html","permalink":"http://alibaba.github.io/guide/syntax/index.html","text":"SyntaxThe syntax of Weex is deeply inspired from Vue.js, an elegant JavaScript framework with component system and reactive data binding. A simple Weex page sample is just a piece of &lt;template&gt; code, a piece of &lt;style&gt; code and a piece of &lt;script&gt; code. The three parts together describe a whole Weex page. &lt;template&gt;: required. Just uses HTML syntax and describes the structure of a Weex page, which is build upon several tags. Each tag means a type of component. &lt;style&gt;: optional. Describes the presetation details, and the content is based on CSS syntax. &lt;script&gt;: optional. Describes the data and behavior with JavaScript syntax. It defines data and how these data are processed etc. &lt;template&gt; &lt;!-- (required) the structure of page --&gt;&lt;/template&gt;&lt;style&gt; /* (optional) stylesheet */&lt;/style&gt;&lt;script&gt; /* (optional) the definition of data, methods and life-circle */&lt;/script&gt; &lt;template&gt;We describe page structure in &lt;template&gt; tag like the following definition: &lt;template&gt; &lt;container&gt; &lt;image style=\"width: 200; height: 200;\" src=\"http://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png\"&gt;&lt;/image&gt; &lt;text&gt;Alibaba Weex Team&lt;/text&gt; &lt;/container&gt;&lt;/template&gt; Here container tag is the root element of the component. image tag describes a picture, while text tag means a paragraph of text. Just similar to HTML, each component could have its own attributes, some components also have children as their sub components. The root element of template: In a template tag, there could be only one root component which has no display logics directive. Here are three types of root component we support now: &lt;container&gt;: a common native container &lt;scroller&gt;: a native scroll view &lt;list&gt;: a native cell-reusable list view Only these type of components are allowed for root element. See all built-in components. &lt;style&gt;You can consider the Weex style syntax is a subset of the CSS syntax, but there is still some differences. First we could write inline style attribute in &lt;template&gt; element. Second we could use the class attribute to apply stylesheets, which are defined with single-class selectors in &lt;style&gt; code. Here is an example: &lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: 64;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large\"&gt;Weex Team&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 64;&#125;&lt;/style&gt; Both the two text components above have the same font-size, which is 64 pixel. See common styles in Weex Notes!weex is basically following HTML attribute naming rule , so please do not use CamelCase in your attribute , long-name with “-” as delimiter is much better. &lt;script&gt;The syntax is JavaScript (ES5) and it describes data and behavior of a Weex page. Here we create three paragraphs: &lt;template&gt; &lt;container&gt; &lt;text&gt;The time is &#123;&#123;datetime&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;getTitle()&#125;&#125;&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: 'Alibaba', datetime: null &#125;, methods: &#123; getTitle: function () &#123; return 'Weex Team' &#125; &#125;, created: function() &#123; this.datetime = new Date().toLocaleString() &#125; &#125;&lt;/script&gt; This piece of &lt;script&gt; code will generate some component options and assign it to module.exports. The three text components above respectively shows the current datetime, ‘Alibaba’ and ‘Weex Team’. The data in the &lt;script&gt; code stores component data which could be used for data-binding in the &lt;template&gt;. When data changes, the bound value will be updated automatically. Also it could be read and written by this.x in its methods. See component definitions references Next, let’s have a look at data-binding.","type":"guide"},{"title":"Render Logic Control","path":"guide/syntax/render-logic.html","permalink":"http://alibaba.github.io/guide/syntax/render-logic.html","text":"Render Logic ControlappendAttribute append do not have data-binding. It won’t change the final rendering effect. But it determines whether this component should be rendered as a whole tree or a single node with child nodes appended after. append has two key attributes, tree and node, the usage is: &lt;template&gt; &lt;container&gt; &lt;container id=\"world\" append=\"tree\"&gt; &lt;text&gt;Hello World!&lt;/text&gt; &lt;/container&gt; &lt;container id=\"weex\" append=\"node\"&gt; &lt;text&gt;Hello Weex!&lt;/text&gt; &lt;/container&gt; &lt;/container&gt;&lt;/template&gt; In the code snippet above, the element with id ‘world’ will wait for all its children to be rendered then it will be rendered entirely, while the element with id ‘weex’ will only render itself to the page, then its child elements will be rendered to page one by one. The rendering result is obvious, The latter statement will render the element a bit faster on the first-paint, but the total time might be longger than append=&quot;tree&quot; case. By default, elements are rendered as node mode. Once an element is in tree rendering mode, its children elements will always be rendered in tree mode. Next we will introduce composed component.","type":"guide"},{"title":"Style & Class","path":"guide/syntax/style-n-class.html","permalink":"http://alibaba.github.io/guide/syntax/style-n-class.html","text":"Style &amp; ClassThe Basic SyntaxCSS style description can be viewed as a series of key-value pairs,each of which describes a particular style, such as the width and height of a component. .box &#123; width: 400; height: 50;&#125; The format of key-value pairs is prop-name: prop-value;. The key name is prop-name, the value name is prop-value. Usually,the key name and the value name follow Horizontal connection nomenclature, the value may be a number(the default units is px); The key and the value must be separated by :, between each key-value pairs must be separated by ;. The style description will appear on a weex page in two formats: Style attribute of &lt;template&gt; label Stylesheets of &lt;style&gt; label style attributeThe style written in the style label, for example: &lt;template&gt; &lt;container style=\"width: 400; height: 50;\"&gt; ... &lt;/container&gt;&lt;/template&gt; It is said that the width and height of &lt;container&gt; label is 400 pixels and 50 pixels respectively. the &lt;style&gt; tagFor example: &lt;style&gt; .wrapper &#123;width: 600;&#125; .title &#123;width: 400; height: 50;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt; The stylesheets contain multiple style rules, each style rule has only one class which is contained by its style selector, a pair of curly braces {...}, and the styles of the curly braces. For example: .title &#123; width: 400; height: 50;&#125; The above is a rule. Class attributeThe selectors of &lt;style&gt; label are matched with the class attribute of &lt;template&gt; label, we should use spaces to separate the class names. For example: &lt;template&gt; &lt;container class=\"wrapper\"&gt; &lt;text class=\"title\"&gt;...&lt;/text&gt; &lt;text class=\"title highlight\"&gt;...&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123;width: 600;&#125; .title &#123;width: 400; height: 50;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt; It means that the width of the outermost container is 600px, The inside of the two title text is 400 pixels wide 50 pixels high, the second piece of text is red. Notes In order to simplify the page design and the complete underlying implementation, the width of our default screen is unified to 750 pixels, different screens should be scaled with corresponding ratio. The CSS standard may support a lot of selectors, but now weex only support single-class selector. The CSS standard can support many types of length units, but now weex only support pixel, and the px unit could be ignored, you can write number directly. More details can be found in commmon styles. The styles of Weex cannot be inherited to children elements, this is different to the CSS standard, such as color and font-size. The CSS standard contains a lot of styles, but weex only sopport few styles which include layouts such as box model, flexbox, positions. And styles include font-size, color, etc. With Data-bindingPage data can be bound in style and class attribute. For example: &lt;template&gt; &lt;container&gt; &lt;text style=\"font-size: &#123;&#123;fontSize&#125;&#125;;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large &#123;&#123;textClass&#125;&#125;\"&gt;Weex Team&lt;/text&gt; &lt;/container&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 32;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; fontSize: 32, textClass: 'highlight' &#125; &#125;&lt;/script&gt; Next, let’s have a look at events.","type":"guide"},{"title":"<cell>","path":"references/components/cell.html","permalink":"http://alibaba.github.io/references/components/cell.html","text":"&lt;cell&gt;SummaryThis component must be used as a subcomponent of a list component, which is for the performance optimizing during scrolling. Child ComponentsThis type of component supports all kinds of weex component as its child components. AttributesThere is no specific attribute for this component other than the common attributes. Notes: you can’t give &lt;cell&gt; a flex value. Width of &lt;cell&gt; is equal to the width of its parent component &lt;list&gt;, and you don’t need to specify its height. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Exampleplease refer to List","type":"references"},{"title":"<div>","path":"references/components/div.html","permalink":"http://alibaba.github.io/references/components/div.html","text":"&lt;div&gt;SummaryThe most fundamental component which is a contianer to wrap any other components. It supports all the common styles, attributes and layout of flexbox. alias: &lt;container&gt; (deprecated) Child ComponentsThis type of component supports all kinds of weex component as its child components including its own kind. AttributesThere is no specific attribute for this component other than the common attributes. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples&lt;div&gt; &lt;image src=\"...\"&gt;&lt;/image&gt; &lt;text&gt;...&lt;/text&gt;&lt;/div&gt;","type":"references"},{"title":"<image>","path":"references/components/image.html","permalink":"http://alibaba.github.io/references/components/image.html","text":"&lt;image&gt;Summaryimage tag is used to render a specified picture, and it shouldn’t contain any child component. You can use img as alias. Notes: the styles of width and height should be specified, otherwise it won’t work. alias: &lt;img&gt; Child ComponentsThis component supports no child components. Attributes src: &lt;string&gt; image source url resize: v0.5+ &lt;string&gt; the ‘ScaleType’ of the component. The default value is stretch, if this attribute is not specified. Possible values are cover, contain, each of which has the same meaning with w3c standard. Other attributes please check out the common attributes. Styles width: &lt;length&gt; the width of the component. This style should be specified. height: &lt;length&gt; the height of the component. This style should be specifed. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Examples&lt;div&gt; &lt;image src=\"...\" &gt;&lt;/image&gt; &lt;text&gt;...&lt;/text&gt;&lt;/div&gt;","type":"references"},{"title":"<a>","path":"references/components/index.html","permalink":"http://alibaba.github.io/references/components/index.html","text":"&lt;a&gt;a defines a hyperlink to a page in the web. Its purpose and syntax is very similar to in HTML5. Child ComponentsThis type of component supports all kinds of weex component as it’s child components except for its own kind. Attributes href: href attributes defines the URL of the hyperlink. Styles:common stylesCheck out the common styles Eventscommon eventsCheck out the common events NotesWe can’t guarantee the order of execution between onclick function and href. we recommend that do not use the click event in a. Examples&lt;template&gt; &lt;div&gt; &lt;a href=\"http://h5.m.taobao.com\"&gt; &lt;text&gt;Click me to see how 'A' element opens a new world.&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt; Try it Use Weex Playground App to Scan the QR image and view the example for ‘a’.","type":"references"},{"title":"<indicator>","path":"references/components/indicator.html","permalink":"http://alibaba.github.io/references/components/indicator.html","text":"&lt;indicator&gt;SummaryThis component must be used as a subcomponent of a slider component. Child ComponentsThis component supports no child components. AttributesThere is no specific attribute for this component other than the common attributes. Styles item-color: &lt;colors&gt; This style attribute sets the normal item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-selectedColor: &lt;colors&gt; This style attribute sets the selected item color using either a named color or a color specified in the hexadecimal #RRGGBB format. item-size: &lt;length&gt; The size of the indicator elements, which is an float attribute. common styles: check out the common styles support flexbox related styles support box model related styles support position related styles Note: There are some specific details about the style width and height on this component: the position of indicator will not only depend on the top, left, bottom and right, but also depend on the value of width and height. Imagine there is a virtual container outside the indicator, and it inherit the width and height of the indicator. The top, left, right and bottom will always take effect on this container, not the indicator points themselves, and the indicator points will be positioned in the center of it. And also you should know the default width and height is the parent slider’s width and height. Note: background-color is not recommended to apply on this component, and you should use item-color and item-selectedColor instead. Eventscommon events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\"&gt; &lt;div class=\"slider-pages\" repeat=\"&#123;&#123;itemList&#125;&#125;\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123;width: 150; height: 150;&#125; .title &#123;flex: 1; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee;&#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<input>","path":"references/components/input.html","permalink":"http://alibaba.github.io/references/components/input.html","text":"inputThe weex builtin component input is used to create input controls to receive the user’s input characters. How a input component works varies considerably depending on the value of its type attribute, such as text, password, url, email, tel etc. Notes: does not support the common-event click. Please listen to the input or change event instead. Child ComponentsThis component supports no child components. Attributes type: the type of controls to display. The default value is text, if this attribute is not specified. Possible values are text, password, tel, email, url etc. each of which has the same meaning with \u001dW3C standard. value: the value(text) of the control. placeholder: a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: a boolean attribute lets you specify that a form control should have input focus when the page loads. maxlength: v0.7+ a number value to specify maxlength of input. Other attributes please check out the common attributes. Styles placeholder-color: the color of placeholder. Default value is ‘#999999’. text styles: checkout text styles support ‘color’ style. support ‘font-size’ style. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Events input: the value of an input character changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a ‘blur’ event. focus: a component has received focus. blur: a component has lost focus. common eventscheck out common events support ‘appear’ / ‘disappear’ event. Notesdoes not support the common-event ‘click’. Please listen to the ‘input’ or ‘change’ event instead. Parameters of events’ object for ‘input’ and ‘change’ events:’value’: the value of the component who dispatched this event.’timestamp’: the time stamp of the event. for ‘focus’ and ‘blur’ events:’timestamp’: the time stamp of the event. Example&lt;template&gt; &lt;div&gt; &lt;input type=\"text\" placeholder=\"Input Something\" class=\"input\" autofocus=\"true\" value=\"\" onchange=\"onchange\" oninput=\"oninput\" /&gt; &lt;text&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .input &#123; font-size: 60; height: 80; width: 400; &#125;&lt;/style&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; txtInput: '', txtChange: '' &#125;, methods: &#123; onchange: function(event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, oninput: function(event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125; &#125; &#125;;&lt;/script&gt; Try it Use Weex Playground App to Scan the QR image and view the example for ‘input’.","type":"references"},{"title":"<list>","path":"references/components/list.html","permalink":"http://alibaba.github.io/references/components/list.html","text":"Listv0.6.1+ The List component, which inherits from Scroller component, is a core component, and it provides the most popular features for using a list of items. It can provide excellent experience and performance while still maintaining smooth scroll and low memory usage. example &lt;template&gt; &lt;list&gt; &lt;cell onappear=\"onappear\" ondisappear=\"ondisappear\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;] &#125;, methods:&#123; onappear: function (e) &#123; var index = e.target.attr.index nativeLog('+++++', index); console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e) &#123; nativeLog('+++++', e.target.attr.index); &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsNotes: The list now supports the following child components: cell, header, refresh, loading and fixed-position components. Other kinds of components will not be guaranteed to be displayed correctly. cell 0.6.1 defines the attributes and behavior of the cells that appear in list. header 0.6.1 sticks to the top when it reaches the top of the screen. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsonloadmore 0.5 used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events APIAll cells or cell’s subcomponents in list support the scrollToElement API in dom module Difference between loading child component and onloadmore eventloading is a child component that can response to the onloading event, and this event can only be triggered when the scroller/list has been scrolled down to the bottom.onloadmore is an event that will be triggered when the rest of the scroller/list is less than loadmoreoffset long. scroller example list example RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal. Example&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; Try it","type":"references"},{"title":"<refresh> & <loading>","path":"references/components/refresh-loading.html","permalink":"http://alibaba.github.io/references/components/refresh-loading.html","text":"refresh &amp; loadingv0.6.1+ Loading ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. example &lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/loading&gt; &lt;cell onappear=\"onappear\" ondisappear=\"ondisappear\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onappear: function (e) &#123; var index = e.target.attr.index // nativeLog('+++++', index); // console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e) &#123; // nativeLog('+++++', e.target.attr.index); &#125;, onloading:function(e)&#123; console.log('onloading...'); this.staffs.push(&#123;name:'onloading'&#125;) &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component.example Attributes display has value of show or hide. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components Events onloading triggered when loading Restrictions refresh/loading does not support remove action, Weex 0.9 will fix it. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs. Refresh ComponentsTo be rendered properly, the refresh/loading Components must appear inside the Scroller Component or the List Component. &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"1000\"&gt; &lt;refresh onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text id=\"refreshText\"&gt;&#123;&#123;refreshText&#125;&#125;&lt;/text&gt; &lt;/refresh&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text id=\"loadingText\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh', items: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 30; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onrefresh: function () &#123; var vm = this; vm.refreshDisplay = 'show' if (vm.items.length &gt; 50) &#123; vm.refreshText = \"no more data!\" vm.refreshDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.unshift(&#123;'item': 'test data ' + i&#125;); &#125; vm.refreshDisplay = 'hide' &#125;, onloading: function () &#123; var vm = this; vm.loadingDisplay = 'show' if (vm.items.length &gt; 30) &#123; vm.loadingText = \"no more data!\" vm.loadingDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.push(&#123;'item': 'test data ' + i&#125;); &#125; vm.loadingDisplay = 'hide' &#125;, onloadmore:function()&#123; console.log(\"into--[onloadmore]\") &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsAny other components, like the text and img components, can be put inside the refresh component. And there is a special component named loading-indicator used only inside the refresh or the loading components. loading-indicator is a child component implemented with default animation effect for the refresh component.example Attributes display has value of show or hide, default value is show. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components Events onrefresh triggered when the scroller has been pulled down onpullingdown available on Android. triggered when the scroller has been pulled down. you can get dy, headerHeight, maxHeight from onpullingdowns event object. example example &lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;refresh onpullingdown='onpullingdown' onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell onappear=\"onappear\" ondisappear=\"ondisappear\" class=\"row\" repeat=\"&#123;&#123;staffs&#125;&#125;\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onappear: function (e) &#123; var index = e.target.attr.index // console.log(this.staffs[index].name + ' is appearing...'); &#125;, ondisappear:function (e) &#123; &#125;, onrefresh:function(e)&#123; this.refreshDisplay='show'; // this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;]; this.refreshDisplay='hide' // console.log(this.refreshDisplay); &#125;, onpullingdown:function(e)&#123; console.log('onpullingdown triggered.'); console.log('dy:'+e.dy); console.log('headerHeight:'+e.headerHeight); console.log('maxHeight:'+e.maxHeight); &#125; &#125; &#125;&lt;/script&gt; try it Restrictions refresh/loading does not support remove action, may support in Weex 0.9. refresh/loading despite setting with display=’hide’, the refresh/loading view will still appear when scrolling due to known issues. it can be fixed with a another display=’hide’ when the refresh/loading should be hidden. refresh/loading can only be hidden or displayed with an attribute display with value of show or hide. And there should be a statement of display=’hide’ when display=’show’ shows up in an event function, or your scroller may not response to user inputs.","type":"references"},{"title":"<scroller>","path":"references/components/scroller.html","permalink":"http://alibaba.github.io/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ A scroller is a component in vertical direction which can have multiple child components in one column. If total height of its child components exceed the height of the scroller, the whole child components will be scrollable. Notes: A can be used as a root element or a embed element. The scroll direction of this component is column, and it can’t be changed. example &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; items: [], triggered:false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onloadmore:function()&#123; if(!this.triggered)&#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123;'item':'onloadmore triggered' + i&#125;); &#125; &#125; this.triggered=true; &#125; &#125; &#125;&lt;/script&gt; try it Child ComponentsScroller supports all kinds of components, such as div, text, etc.And there are two special components that can only be used inside scroller component. refresh 0.6.1 used inside list to add pull-down-to-refresh functionality. loading 0.6.1 used inside list to add pull-up-to-load-more functionality. Attributes show-scrollbar: true/false whether show the scroll bar or not, default value is true scroll-direction: define scroll direction of component, horizontal or vertical loadmoreoffset : default value is 0. The loadmore event will be triggered when the list is loadmoreoffset left to reach the bottom of the list view. e.g. a list has total content length of 1000, and the loadmoreoffset is set to 400, the loadmore event will be triggered when 600 has beed scrolled and there is less than 400 left. loadmoreretry : default value 0，whether to reset loadmore related UI when loadmore failed, will be deprecated in further release. example &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"&#123;&#123;v in items&#125;&#125;\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; items: [], triggered:false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123;'item': 'test data' + i&#125;); &#125; &#125;, methods: &#123; onloadmore:function()&#123; if(!this.triggered)&#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123;'item':'onloadmore triggered' + i&#125;); &#125; &#125; this.triggered=true; &#125; &#125;&#125;&lt;/script&gt; try it Please checkout Scroller Component Attributes to have a look at the inherited attributes from direct parent. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Eventsonloadmore used with loadmoreoffset attribute. if the view has less than loadmoreoffset to scroll down, the onloadmore event will be triggered. common events: check out the common events support onclick event. Check out common events support onappear / ondisappear event. Check out common events RestrictionsNested lists or scrollers within the same direction are not supported. In other words. nested lists/scroller must have different directions.For example, a vertical list nested in a vertical list or scroller is not allowed. However, a vertical list nested in a horizontal list or scroller is legal.","type":"references"},{"title":"<slider>","path":"references/components/slider.html","permalink":"http://alibaba.github.io/references/components/slider.html","text":"&lt;slider&gt;SummaryA slide’s player to show slides (mostly as pictures) one page by another. The default interval between two slides is 3 seconds. Child ComponentsIt supports all kinds of weex components as its slides, especially the indicator component which can be used only as a child component of slider. Attributes auto-play: &lt;boolean&gt; true | false. This value determines whether the slides plays automatically after the page rendering finished. The default value is false. interval: &lt;number&gt; millisecond. This value determines time interval for each page displayed in slider. index: &lt;number&gt; . This value determines the index of current shown slide. The default value is 0. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events change: triggerd when the slide’s index is changed. The event object contains the attribute of index, which is the index number of the currently shown slide. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<switch>","path":"references/components/switch.html","permalink":"http://alibaba.github.io/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ The weex builtin component switch is used to create and manage an IOS styled On/Off buttons, for example, the Airplane mode button in the Settings app is a switch button. example &lt;template&gt; &lt;div&gt; &lt;text&gt;muted:&lt;/text&gt; &lt;switch checked=\"true\" onclick='onclick' onchange='onchange' ondisappear='ondisappear' onappear='onappear'&gt;&lt;/switch&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; methods:&#123; onclick:function(e)&#123; console.log('onclick:' + e.timestamp); &#125;, onchange:function(e)&#123; console.log('onchage, value:' + e.value); &#125;, ondisappear:function(e)&#123; console.log('ondisappear, value:' + e.value); &#125;, onappear:function(e)&#123; console.log('onappear, value:' + e.value); &#125;, &#125; &#125;&lt;/script&gt; try it Child ComponentsThere are no child components for the switch component. Attributes checked &lt;boolean&gt; true|false, default value is false, indicating whether the button is on or not. disabled &lt;boolean&gt; true|false, default value is false, indicating whether the button is enable or not. Other attributes please check out the common attributes. StylesNotes: There are several style properties that you mustn’t use on this component. And here are all the invalid properties: width height min-width min-height margin and margin-xxs padding and padding-xxs border and border-xxs Notes: Specially the width and height related properties is not configurable and the size of this component is fixed to 100x60 (for the design width 750px). common styles: check out common styles for components Events onappear / ondisappear event. check out common events onclick: check out common events onchange: check out common events Parameters of events’ object for onchange event: value: the value of the component who dispatched this event, which is the boolean value true or false. timestamp: the time stamp of the event.","type":"references"},{"title":"<text>","path":"references/components/text.html","permalink":"http://alibaba.github.io/references/components/text.html","text":"&lt;text&gt;The weex builtin component ‘text’ is used to render text with specified style rule. tag can contain text value only. You can use variable interpolation in the text content with the mark {{}}. Child ComponentsThis component supports no child components. Attributes value(string): text value of this component. This is equal to the content of ‘text’. examplevar textComponent = this.$el(&quot;textid&quot;);this.text = textComponent.attr.value; Styles lines: specify the text lines. Default value is 0 for unlimited. text styles: check out text styles support ‘color’ style. support ‘font-size’ style. iOS: default vlaue 32. Android: platform specify. HTML5: default value 32. support ‘font-style’ style. support ‘font-weight’ style. support ‘text-align’ style. support ‘text-decoration’ style. support ‘text-overflow’ style. support ‘line-height’(available from v0.6.1) style. line-height in iOS is different from h5 and Android, text value will be placed at bottom of line box. not support ‘flex-direction, ‘justify-content’, ‘align-items’ which is active for child nodes, and text has no child nodes. common stylescheck out common styles for components support flexbox related styles. support box model related styles. support ‘position’ related styles. support ‘opacity’, ‘background-color’ etc. Eventscommon eventscheck out common events support ‘click’ event. support ‘appear’ / ‘disappear’ event. Example&lt;template&gt; &lt;div&gt; &lt;text&gt;this is text content&lt;/text&gt; &lt;text value=\"this is text value\"&gt;&lt;/text&gt; &lt;text style=\"text\"&gt;&#123;&#123;price1&#125;&#125;&lt;/text&gt; &lt;text id=\"textid\" onclick=&#123;&#123;showtext&#125;&#125;&gt;this is gettext content&lt;/text&gt; &lt;text value=\"&#123;&#123;text&#125;&#125;\"&gt;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text &#123; font-size: 24; text-decoration: underline; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; price1: '99.99', price2: '88.88', text:'' &#125;, methods: &#123; showtext: function(event) &#123; var textComponent = this.$el(\"textid\"); this.text = textComponent.attr.value; &#125; &#125; &#125;;&lt;/script&gt; Try it","type":"references"},{"title":"<textarea>","path":"references/components/textarea.html","permalink":"http://alibaba.github.io/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ SummaryThe weex builtin component textarea is used to create interactive controls to accept data from users. It can be a multi-line input. Notes: &lt;textarea&gt; support all event which &lt;input&gt; had. Child ComponentsThis component supports no child components. attributes value: &lt;string&gt; the value of the control. placeholder: &lt;string&gt; a hint to the user of which can be entered to the control. The placeholder text must have no carriage returns or line-feeds. disabled: &lt;boolean&gt; a boolean attribute indicates that the form control is not available for interaction. In particular, the click event will not be dispatched on disabled controls. autofocus: &lt;boolean&gt; a boolean attribute lets you specify that a form control should have input focus when the page loads. rows:&lt;number&gt; a number which can specify the height of textarea, default is 2. Other attributes please check out the common attributes. Stylestext styles: checkout text styles support color style. support font-size style. support font-style style. support font-weight style. support text-align style. common styles: check out common styles for components support flexbox related styles. support box model related styles. support position related styles. support opacity, background-color etc. Events input: the value of an element changes. change: the change event is fired when a change to the component’s value is commited by the user. It always come after a blur event. focus: a component has received focus. blur: a component has lost focus. common events: check out the common events support appear / disappear event. Check out common events. Notes: &lt;textarea&gt; does not support the common-event click. Please listen to the input or change event instead. Parameters of events’ object for input and change events: value: the value of the component who dispatched this event. timestamp: the time stamp of the event. for focus and blur events: timestamp: the time stamp of the event. Example&lt;div&gt; &lt;textarea autofocus=\"true\" placeholder=\"...\" value=\"I am a multiple input\"&gt; &lt;/textarea&gt;&lt;/div&gt;","type":"references"},{"title":"<video>","path":"references/components/video.html","permalink":"http://alibaba.github.io/references/components/video.html","text":"&lt;video&gt;v0.6.1+ The video component can be used to embed video content in a weex page. example &lt;template&gt; &lt;div&gt; &lt;text&gt;Big Eater!&lt;/text&gt; &lt;video onstart='onstart' onpause='onpause' onfinish='onfinish' onfail='onfail' auto-play=\"false\" play-status=\"pause\" src=\"&#123;&#123;src&#125;&#125;\" style=\"width:750;height:500;\"&gt;&lt;/video&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; data: &#123; src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125;, methods:&#123; onstart:function(e)&#123; console.log('onstart'); console.log(e); &#125;, onpause:function(e)&#123; console.log('onpause'); &#125;, onfinish:function(e)&#123; console.log('onfinish'); &#125;, onfail:function(e)&#123; console.log('onfail'); &#125;, &#125; &#125;&lt;/script&gt; try it Child Components text is the only valid type of child component. Attributes src: &lt;string&gt; The URL of the video to embed. play-status: &lt;boolean&gt; play | pause. Use it to control video’s play/pause status. Default value is pause. auto-play: &lt;boolean&gt; true | false. Use it to control whether it is playing when the page initialization finished. Defalut value is false. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events onstart: triggered when playback state is Playing. onpause: triggered when playback state is Paused. onfinish: triggered when playback state is Finished. onfail: triggered when playback state is Failed.","type":"references"},{"title":"<web>","path":"references/components/web.html","permalink":"http://alibaba.github.io/references/components/web.html","text":"&lt;web&gt;v0.5+ Use web component to display any web content in the weex page. The srcattribute is used to specify a special source. You also can use webview module to control some web operation such as goBack,goForward and reload. see webview module.For example,You can use web component and webview module to assemble a browser. Child ComponentsThis component supports no child components. Attributessrc(string): this attribute specifies the page source to load. Other attributes please check out the common attributes. Styleswidth(float): the width of the component, default value is 0. This style must be specified. height(float): the height of the component, default value is 0. This style must be specifed. common stylescheck out the common styles. support flexbox related stylessupport box model related stylessupport position related styles Eventspagestart: sent after the web component starts loading a page.pagefinish: sent after the web component finishes loading a page.error: sent if the web component failed to load a page. common eventssupport appear / disappear event. Check out common events Notesnot support click event. ExampleWe use a simple Browser Demo to show how to use web component and webview module. Check out webview module. &lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"...\" class=\"textStyle\" value=\"&#123;&#123;input_text&#125;&#125;\" oninput=\"input\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;wxc-button value=\"LoadURL\" class=\"buttonSytle\" size=\"small\" onclick=\"loadURL\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Backward\" class=\"buttonSytle\" size=\"small\" onclick=\"backforward\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Forward\" class=\"buttonSytle\" size=\"small\" onclick=\"forward\"&gt;&lt;/wxc-button&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; width:600; height: 825; background-color:#778899 ; &#125; .textStyle &#123; width:600; height: 50; background-color: #D3D3D3; &#125; .buttonSytle &#123; width:180; height: 50; font-size: 12; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; &#125; .webStyle &#123; width:600; height: 700; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview'); module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", input_text:\"https://www.tmall.com\" &#125;, methods: &#123; loadURL: function (e) &#123; var web_element = this.$el('webview'); var input = this.$el(\"urlInput\"); this.src = this.input_text; web_module.reload(web_element); &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); this.input_text = web_element.attr.src; &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); this.input_text = web_element.attr.src; &#125;, input:function (e) &#123; var input = this.$el(\"urlInput\"); this.input_text = input.attr.value; &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"<wxc-navpage>","path":"references/components/wxc-navpage.html","permalink":"http://alibaba.github.io/references/components/wxc-navpage.html","text":"&lt;wxc-navpage&gt;SummaryThe “wxc-navpage” tag implements a specialized component that contains a navbar at the top of the window and an embed content page. You can customize the navbar as you like. In addition, you can use navigator module to control the page jump, see navigator module. Child ComponentsThis type of component supports all kinds of weex component as its child components. Attributes height: &lt;length&gt; The height of the navbar. Default value is 88. background-color: &lt;color&gt;The backgroudColor of the navbar. Default value is white. title: &lt;string&gt; The title of the navbar. title-color: &lt;color&gt;The color of the navbar title. Default value is black. left-item-title: &lt;string&gt; The title of the leftItem. left-item-color: &lt;color&gt; The color of the leftItem title. Default value is black. right-item-title: &lt;string&gt; The title of the rightItem. right-item-color: &lt;color&gt; The color of the rightItem title. Default value is black. left-item-src: &lt;string&gt; The imageURL of the leftItem you want to set. right-item-src: &lt;string&gt; The imageURL of the rightItem you want to set. Other attributes please check out the common attributes. Stylescommon styles: check out the common styles support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events naviBar.leftItem.click: triggered when the leftItem of navbar is clicked. You need to register the observer in ready or create block. naviBar.rightItem.click: triggered when the rightItem of navbar is clicked. You need to register the observer in ready or create block. common events: check out the common events support click event. Check out common events support appear / disappear event. Check out common events Example&lt;template&gt; &lt;wxc-navpage height=&#123;&#123;...&#125;&#125; background-color=\"...\" title=\"...\" title-color=\"...\" left-item-title=\"...\" left-item-color=\"...\" right-item-src=\"...\"&gt; &lt;content&gt; ...&lt;/content&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; created: function() &#123; this.$on('naviBar.rightItem.click',function(e)&#123; //handle your click event here. &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; //handle your click event here. &#125;); &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<wxc-tabbar>","path":"references/components/wxc-tabbar.html","permalink":"http://alibaba.github.io/references/components/wxc-tabbar.html","text":"&lt;wxc-tabbar&gt;The wxc-tabbar is a custom component, which belongs to the weex-components node package, implements a specialized component that corresponds to the radio-style selection. It displays tabs at the bottom of the window for switching between different tab pages. Usage: You can use this component by a require statement, require(&#39;weex-components&#39;);, in the script tag. e.g. &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); // Other javascript statements.&lt;/script&gt; Before requiring weex-components&#39;, you need to specify weex-components dependency in your project’s package.json file. e.g. \"dependencies\": &#123; \"weex-components\": \"^0.2.0\"&#125; Child Componentswxc-tabbar has no child components. Attributes selected-index : &lt;number&gt; default value is 0 selected-color: &lt;color&gt; The color of the title when it is selected. Default is red color. unselected-color: &lt;color&gt; The color of the title when it is unselected. Default is black color. tab-items This attribute accepts an array of tabitem objects, each of which corresponds to the tab pages. And the order of the items equals to the order of the tab pages onscreen. You can configure the appearance of tabbar by setting the tabitem object’s properties. Each tabitem properties are listed as below: index: &lt;integer&gt; This attribute is required, and it specifies the order of the item. title: &lt;string&gt; The item’s title. and it is optional. The tile will not be displayed if empty or not provided. titleColor: &lt;color&gt;The item’s titleColor. Default is black color. image: &lt;string&gt;The icon displayed when the tabitem is unselected. The image will not be displayed if empty or not provided. selectedImage : &lt;string&gt;The icon displayed when the tabitem is selected. The icon will not be displayed if empty or not provided. src : &lt;string&gt; The weex page for the tab page. visibility: &lt;string&gt;visible | hidden. This attribute specifies display status of the tab page. Default value is visible. Other attributes please check out the common attributes. Stylescommon styles: check out common styles for components support flexbox related styles support box model related styles support position related styles support opacity, background-color etc. Events tabBar.onClick: triggered when the tabitem is selected. You need to register the observer in ready or create block.e.g. &lt;template&amp;gt; &lt;div style=\"flex-direction: column;\"&amp;gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&amp;gt;&lt;/wxc-tabbar&amp;gt; &lt;/div&amp;gt;&lt;/template&amp;gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; &#125;, methods: &#123; ready: function (e) &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var index = e.detail.index; &#125;); &#125;, &#125; &#125;&lt;/script&gt; ExampleYou should checkout the playground’s tabbar example.","type":"references"},{"title":"animation","path":"references/modules/animation.html","permalink":"http://alibaba.github.io/references/modules/animation.html","text":"animationSmooth and meaningful animation is very effective for enhancing the user experience of mobile application, you can use the animation module to perform animation on components. A animation can perform a series of simple transformations (position, size, rotation, background color, and opacity) on the component. So, if you have a image component, you can move, rotate, grow, or shrink it. APItransition(node, options, callback)example Argumentsnodetype: node position: An element that will be animated, normally you can get this by calling this.$el(id). optionstype: object position: Transition options. duration (number): Specifies the number of milliseconds of animation execution, the default value is 0, means that no animation will occur. delay (number): Specifies the amount of milliseconds to wait between a change being requested to a property that is to be transitioned and the start of the transition effect. The default value is 0. timingFunction (string): Used to describe how the intermediate values of the styles being affected by a transition effect are calculated, default value is linear, the allowed attributes are listed in the following table: name description example linear Specifies a transition effect with the same speed from start to end example ease-in Specifies a transition effect with a slow start example ease-out Specifies a transition effect with a slow end example ease-in-out Specifies a transition effect with a slow start and end example cubic-bezier(x1, y1, x2, y2) Define your own values in the cubic-bezier function. Possible values are parameter values from 0 to 1. More information about cubic-bezier please visit cubic-bezier and Bézier curve. example styles (object): Specify the names and values of styles to which a transition effect should be applied. The allowed attributes are listed in the following table: name description value type default value example width The width applied to the component after the animation finished. length none example height The height applied to the component after the animation finished. length none example backgroundColor The background color applied to the component after the animation finished. string none example opacity The opacity applied to the component after the animation finished. number between 0 to 1 1 example transformOrigin The povit of transition. The possible values for x-aris are left/center/right/length or percent, and possible values of y-axis are top/center/bottom/ length or percent x-axis y-axis center center example transform Transform function to be applied to the element. The properties in the following table are supported object none example properties of transform: name description value type default value example translate/translateX/translateY Specifies the location of which the element will be translated. pixel or percent none example rotate Specifies the angle of which the element will be rotated, the unit is degree. number none example scale/scaleX/scaleY Stretch or shrink the element. number none example callbacktype: function position: Callback which is called after the completion of transition.","type":"references"},{"title":"clipboard","path":"references/modules/clipboard.html","permalink":"http://alibaba.github.io/references/modules/clipboard.html","text":"clipboardv0.8+ (developing) clipboard allows you to getString() or setString() from the system clipboard. Not long ago, We’re still suffering from such a situation that we got a verification code sent by SMS, and we had no way to get the code from the SMS text but to typed it by our hands. How frustrated it is! But now you can enable your app to get the code from the system clipboard by calling clipboard.getString() . Caution only support text. only works on Android and iOS. NOT works for html5, for web security reason. APIgetString(callback)reads from clipboard. Argumentscallback(function): the callback function after executing this action. data is the return value. Example var clipboard = require('@weex-module/clipboard');clipboard.getString(function(ret) &#123; // callback. 'ret' is an object that contains 'result' and 'data'. // use 'ret.data' to fetch the value. console.log(\"read from clipboard is \" + ret.data);&#125;); setString(text)sets the text to clipboard, having the same effect as copying manually. Argumentstext(string): the text copied to clipboard.Example var clipboard = require('@weex-module/clipboard');clipboard.setString(\"SomeStringHere\");","type":"references"},{"title":"dom","path":"references/modules/dom.html","permalink":"http://alibaba.github.io/references/modules/dom.html","text":"domSummaryA series of dom apis that sending virtual-dom’s messages to the native renderer to update the dom tree. The only API for developers to use in a .we file is scrollToElement which you can use by calling the $scrollTo method. Other APIs mentioned on this page should only be used through the native renderer in the callNative process. APIscrollToElement(node, options)Scroll the page to the specified node. This API should only be used on the element in the scroller or list component. This API can be used by calling the VM’s method $scrollTo (deprecated). You can use require(&#39;@weex-module/dom&#39;).scrollToElement to call this API in your .we file. Arguments node(Node): an element that scrolled into the view. options(object): some options. offset(number): An offset to the visible position, default is 0. Examplevar dom = require('@weex-module/dom');dom.scrollToElement(this.$el('someId'), &#123;offset: 10&#125;); createBody(element)Create the body for the whole dom tree. Element type should only be the ones that can be used as roots (div, scroller and list). Arguments element(object): a object that specified the body node info like ref, type, children, etc. addElement(parentNode, element, index)Add a element into the dom tree. Arguments parentNode(Node): specify the element’s parent node. element(object): a object that specified the config info for the node to be added. index(number): insert the element to the specified position. removeElement(node)Remove a node in the dom tree. Arguments node(Node): the node to be removed. moveElement(node, parentNode, index)Move a exsited node into another parent (or the same parent) before the specified position. Arguments node(Node): the node to be moved. parentNode(Node): the parent node to move into. index(number):: according to the specified position index, will the node be inserted into. addEvent(node, type)Inform the renderer that there are listeners for a specified event type. Arguments node(Node): the node to be listened on. type(string): which type of events the node should be listened for. removeEvent(node, type)Remove event listeners on the specified node for the specified event type. Arguments node(Node): on which node should the listeners to be removed type(string): specify the event type. updateAttrs(node, attr)Update attrbutes of the specified node. Arguments node(Node): the node to be updated. attr(object): the attributes object with the attribute items to be updated. updateStyle(node, style)Update styles of the specified node. Arguments node(Node): the node to be updated. style(object): the style object with the style rules to be updated. createFinish()Notify native renders that the series of messages for updating the native dom tree have reached a end. refreshFinish()Notify native renders that the series of messages for refreshing a native dom tree have reached a end.","type":"references"},{"title":"globalEvent","path":"references/modules/globalevent.html","permalink":"http://alibaba.github.io/references/modules/globalevent.html","text":"globalEventv0.8+ (developing) SummaryglobalEvent are used to listen for persistent events, such as changes in positioning information, gyroscopes, and so on. A global event is a secondary API that requires additional APIs to work with. You can register events via addEventListener, which can be removed by removingEventListener when you do not need to listen for globalEvent. AUCTION Only instance level is not application level . How to make your Module support global eventsAPI development is complete, when the event needs to be sent, the need through the following methods: /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); How to dispatch a global event in a weex-html5 component or module ? Just dispatch the event on the document element: var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) ExampleAndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)register global event. Arguments eventName(string): The name of the event you want to listen to. callback(function): the callback function after executing this action. Examplevar globalEvent = require('@weex-module/globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123;2console.log(\"get geolocation\")2&#125;); removeEventListener(String eventName)remove global event Arguments eventName(string): You no longer need to listen for event names. Examplevar globalEvent = require('@weex-module/globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"Built-in Modules","path":"references/modules/index.html","permalink":"http://alibaba.github.io/references/modules/index.html","text":"Built-in ModulesHow to useYou can use a simply way like require(&#39;@weex-module/name&#39;) to access the apis of module. e.g. &lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123;&#125;, created: function () &#123; dom.scrollToElement(this.$el('someIdForElement'), &#123; offset: 0 &#125;) &#125;&#125;&lt;/script&gt;","type":"references"},{"title":"modal","path":"references/modules/modal.html","permalink":"http://alibaba.github.io/references/modules/modal.html","text":"modalWeex provides a series of message boxes: toast, alert, confirm and prompt. APItoast(options)A toast provides simple feedback about an operation in a small popup. For example, navigating away from an email before you send it triggers a “Draft saved” toast to let you know that you can continue editing later. Toasts automatically disappear after a timeout. Arguments options (object): toast options. message (string): the text message that the toast shows. duration (number): the duration(seconds) that the toast shows. Example: &lt;template&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Toast&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); modal.toast(&#123; 'message': 'I am a toast', 'duration': 3 &#125;); &#125; &#125; &#125;&lt;/script&gt;``` ### alert(options, callback) An alert box is often used if you want to make sure information comes through to the user. When an alert box pops up, the user will have to click \"OK\" to proceed. #### Arguments - `options` (object): alert box options. - `message` (string): the text message that the alert shows. - `okTitle` (string): the text of positive button, default is 'OK'. - `callback` (function): callback when complete. This method has a callback function whose arguments will be: - `result` (string): the title text of the confirm button that clicked by user.**Example:**```html&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Alert&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.alert(&#123; 'message': 'I am alert message', 'okTitle' : 'YES' &#125;, function (result) &#123; self.params = String(result) &#125;); &#125; &#125; &#125;&lt;/script&gt; confirm(options, callback)A confirm box is often used if you want the user to verify or accept something. When a confirm box pops up, the user will have to click either confirm or cancel button to proceed. Arguments options (object): confirm box options. message (string): the message that the confirm shows. okTitle (string): the title of confirm button, default is ‘OK’. cancelTitle (string): the title of cancel button, default is ‘Cancel’. callback (function): callback when complete. This method has a callback function whose arguments will be: result(string): the title text of the button that clicked by user.Example: &lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Confirm&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.confirm(&#123; 'message': 'I have read and accept the terms.', 'okTitle' : 'YES', 'cancelTitle' : 'NO' &#125;, function (e) &#123; self.params = String(e) &#125;); &#125; &#125; &#125;&lt;/script&gt;``` ### prompt(options, callback) A prompt box is often used if you want the user to input a value before entering a page. When a prompt box pops up, the user will have to click either confirm or cancel button to proceed after entering an input value. #### Arguments - `options` (object): some options. - `message` (string): the message that the prompt shows. - `okTitle` (string): the title text of confirm button, default is 'OK'. - `cancelTitle` (string): the title text of cancel button, default is 'Cancel'.- `callback` (function): callback when complete. This method has a callback function whose arguments will be: - `ret` (object): the argument will be a object, which has attributes `result` and `data`, like `&#123; result: 'OK', data: 'hello world' &#125;` - `result` (string): the title of the button that clicked by user. - `data` (string): the value of the text that entered by user. **Example:** ```html&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Prompt&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.prompt(&#123; 'message': 'I am a prompt', 'okTitle' : 'YES', 'cancelTitle' : 'NO' &#125;, function (e) &#123; self.params = JSON.stringify(e) &#125;); &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"navigator","path":"references/modules/navigator.html","permalink":"http://alibaba.github.io/references/modules/navigator.html","text":"Navigatorv0.6.1+ As it’s known to all that, we can navigate back and forth in the web browser using the navigation bar.And The navigator module mimics the same behaviors in the iOS/Android application. Without such an ability, We will have to stay in the same page forever, so it is very important. Besides the navigation, the module can let us to specify whether to apply animation or not during the transition. example &lt;template&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;click me! &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; data:&#123; message:\"\" &#125;, methods:&#123; onItemClick:function(e)&#123; var navigator = require('@weex-module/navigator'); var params = &#123;'url':'http://weex.alibaba-inc.com/raw/html5/3d2996653c1d129603f9c935b895e998.js','animated':true&#125;; navigator.push(params, function(e) &#123; console.log('i am the callback.') &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text&#123; width: 750; height: 90; &#125;&lt;/style&gt; try it APIpush(options, callback)push a weex page onto the navigator stack, you can specify whether apply animation when pushing. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. url(stirng): The URL of the weex page to push. animated(string): true, if the weex page is push through animation, otherwise, false. Default value is true. callback(object): the callback function to be called after executing this action. var params = &#123; 'url': 'navigator-demo.js', 'animated' : 'true',&#125;var navigator = require('@weex-module/navigator');navigator.push(params, function(e) &#123; //callback&#125;); pop(options, callback)pop a weex page onto the navigator stack, you can specify whether apply animation when popping. And you can also specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true if the weex page is pop through animation; otherwise, false. Default value is true. callback(object): the callback function after executing this action. example var params = &#123; 'animated' : 'true',&#125;var navigator = require('@weex-module/navigator');navigator.pop(params, function(e) &#123; //callback&#125;); close(options, callback)close a weex page, you can specify a callback function to be executed after the operation is over. parameters options(object): some options. animated(string): true, should animation be applied when closing. Default value is true. callback(object): the callback function after executing this action. setNavBarBackgroundColor(params, callback)set color for the navigation bar’s background color, you can specify a callback function to be executed after the operation is over. parameters params(object): some parameters. backgroundColor(string): it’s a required param, no default value provided. callback(object): the callback function after executing this action. setNavBarLeftItem(params,callback)set left item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty, titleColor depends on title. And If title and icon are provided, only the title and its titleColor will be used. That’s to say, icon will only be used when title is not present. title(string): the title for the bar button. titleColor (string): the title color. icon (string): the icon for the bar button, should be an an downloadable image. callback(object): the callback function after executing this action. clearNavBarLeftItem(callback)clear left item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters callback(object): the callback function after executing this action. setNavBarRightItem(params,callback)set the right item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty, titleColor depends on title. And If title and icon are provided, only the title and its titleColor will be used. That’s to say, icon will be used when title is not present. title(string): the title for the bar button. titleColor (string): the title color. icon (string): the icon for the bar button, should be an an downloadable image. callback(object): the callback function after executing this action. clearNavBarRightItem(params, callback)clear the right item for the navigation bar, you can specify a callback function to be executed after the operation is over.parameters params(object): optional. callback(object): the callback function after executing this action. setNavBarMoreItem(params,callback)set the more item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters Actually, the function does nothing. params(object): optional. callback(object): the callback function after executing this action. clearNavBarMoreItem(params, callback)clear the more item for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters Actually, the function does nothing. params(object): optional. callback(object): the callback function after executing this action. setNavBarTitle(params,callback)set the title for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): parameters can not be empty. title(string): the title for the bar button. callback(object): the callback function after executing this action. clearNavBarTitle(params,callback)clear the title for the navigation bar, you can specify a callback function to be executed after the operation is over. parameters params(object): optional. callback(object): the callback function after executing this action.","type":"references"},{"title":"storage","path":"references/modules/storage.html","permalink":"http://alibaba.github.io/references/modules/storage.html","text":"storagev0.7+ Summarystorage is a series of apis, allowing you to for example add, modify or delete stored data items. APIsetItem(key, value, callback)When passed a key name and value, will add that key to the storage,or update that key’s value if it already exists. Arguments key(string): the name of the key you want to store. “” or null is not allowed. value(string): the name of the value you want to store.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.setItem('bar', 'bar-value', function(e) &#123; // callback.'e' is an object that contains 'result' and 'data'. e.result indicate whether `setItem` is succeed. // e.data will return 'undefined' if success or 'invalid_param' if your key/value is \"\"/null.&#125;); getItem(key, callback)When passed a key name, will return that key’s value. Arguments key(string): the name of the key you want to retrieve the value of.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.getItem('foo', function(e) &#123; //callback.'e' is an object that contains 'result' and 'data'. // use 'e.data' to fetch the value of the key,if not found,'undefined' will return.&#125;); removeItem(key, callback)When passed a key name, will remove that key from the storage. Arguments key(string): the name of the key you want to remove.”” or null is not allowed. callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.removeItem('foo', function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. // e.result will return 'success' or 'failed' according to the executing result. // e.data will always return 'undefined' in this function if success.&#125;); length(callback)Returns an integer representing the number of data items stored in the Storage object. Arguments callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.length(function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. //e.data will return that number.&#125;); getAllKeys(callback)Returns an array that contains all keys stored in Storage object. Arguments callback(object): the callback function after executing this action. Examplevar storage = require('@weex-module/storage');storage.getAllKeys(function(e) &#123; // callback. 'e' is an object that contains 'result' and 'data'. //e.data will return that array of keys.&#125;);","type":"references"},{"title":"stream","path":"references/modules/stream.html","permalink":"http://alibaba.github.io/references/modules/stream.html","text":"streamA series of stream api. It provides a network request. APIfetch(options, callback,progressCallback)Start a network request, use two callbacks to receive server’s response data. Arguments options(object): the request options, key value style dictionary. method(string): the HTTP method GET or POST. url(string): the request url. headers(string): the HTTP request headers. type(string): request type, ‘json’,’text’ or ‘jsonp’(same as ‘json’ in native implementation) body(string): the HTTP body. callback(function): A callback function whose argument is the response object of the request. Callback function will receive a response object. status(number): response status code. ok(boolean): true if status code is bewteen 200～299. statusText(string): status text data(string): response data. It’s a object if request option is json/jsonp, or (string) in other type value. headers(object): response headers progressCallback(function): A progress callback. This callback will be invoked before request finished. readyState(number): Current request state.’1’:request connection opened;’2’:response headers received.;’3’:response data is loading; status(number): response status code. length(number): bytes of data have received. You can read full length of response from ‘headers’. statusText(string): status text. headers(object): response headers. Example&lt;template&gt; &lt;div&gt; &lt;text onclick=\"startStream\"&gt;click here to start stream&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; startStream: function () &#123; var stream_module = require('@weex-module/stream'); stream_module.fetch(&#123; method: 'GET', url: \"http://httpbin.org/get\", type:'json' &#125;, function(response) &#123; //finished response console.log(\"all received:\",response); &#125;,function(response)&#123; //progress response console.log(\"current bytes received:\",response.length); &#125;); &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"Timer","path":"references/modules/timer.html","permalink":"http://alibaba.github.io/references/modules/timer.html","text":"TimerWeex encapsulates a series of APIs in order to start/stop a one-time task or a repeated task at a fixed delay. Please note that this module don’t provide an accuracy delay. It provides best-effort delivery, but the actual delay may still exceed the delay user wants if the corresponding thread is busy.Actually, this module is made for the polyfill of HTML5 timer APIs, developers should not use this module directly unless they know exactly what they are doing. APIAll timeout or interval in this module are measured in milliseconds.Also, timeout and interval should be a non-negative integer(the max of integer is 0x7FFFFFFF). If timeout or interval is negative, then it will be reset to zero, e.g. the task will be put in the task queue immediately. setTimeout(fn, timeout)The setTimeout() method calls a function after a specified number of milliseconds. Use the clearTimeout() method to prevent the function from running. The function is only executed once. If you need to repeat execution, use the setInterval() method. Arguments fn (function): The function that will be executed timeout (number): The number of milliseconds to wait before executing the function Return valueA Number, representing the fnId value of the timer that is set. Use this value with the clearTimeout() method to cancel the timer. setInterval(fn, interval)The setInterval() method calls a function at specified intervals (in milliseconds), and it will continue calling the function until clearInterval() is called. The fnId value returned by setInterval() is used as the parameter for the clearInterval() method. Arguments fn (function): The function that will be executed interval (number): The intervals (in milliseconds) on how often to execute the function Return valueA Number, representing the fnId value of the timer that is set. Use this value with the clearInterval() method to cancel the timer clearTimeout(fnId)The clearTimeout() method clears a timer set with the setTimeout() method. The fnId value returned by setTimeout() is used as the parameter for the clearTimeout() method. If the function has not already been executed, you will be able to stop the execution by calling the clearTimeout() method, otherwise, this method has no influence on the task. Arguments fnId (number): The fnId value of the timer returned by the setTimeout() method clearInterval(fnId)The clearInterval() method clears a timer set with the setInterval() method. The fnId value returned by setInterval() is used as the parameter for the clearInterval() method. Arguments fnId (number): The fnId of the timer returned by the setInterval() method Try it","type":"references"},{"title":"webview","path":"references/modules/webview.html","permalink":"http://alibaba.github.io/references/modules/webview.html","text":"webviewA series of web operation api like goBack, goForward, and reload. ‘webview’ module used with the web component. APIgoBack(webElement)Loads the previous location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goBack(webElement); goForward(webElement)Loads the next location in the history stack. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.goForward(webElement); reload(webElement)Reloads the current web page. Arguments webElement(web): the element of the web component. Examplevar webview = require(&apos;@weex-module/webview&apos;);var webElement = this.$el(&apos;webview&apos;);webview.reload(webElement.ref); Example&lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"...\" class=\"textStyle\" value=\"&#123;&#123;input_text&#125;&#125;\" oninput=\"input\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;wxc-button value=\"LoadURL\" class=\"buttonSytle\" size=\"small\" onclick=\"loadURL\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Backward\" class=\"buttonSytle\" size=\"small\" onclick=\"backforward\"&gt;&lt;/wxc-button&gt; &lt;wxc-button value=\"Forward\" class=\"buttonSytle\" size=\"small\" onclick=\"forward\"&gt;&lt;/wxc-button&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; width:600; height: 825; background-color:#778899 ; &#125; .textStyle &#123; width:600; height: 50; background-color: #D3D3D3; &#125; .buttonSytle &#123; width:180; height: 50; font-size: 12; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; &#125; .webStyle &#123; width:600; height: 700; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview'); module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", input_text:\"https://www.tmall.com\" &#125;, methods: &#123; loadURL: function (e) &#123; var web_element = this.$el('webview'); var input = this.$el(\"urlInput\"); this.src = this.input_text; web_module.reload(web_element); &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); this.input_text = web_element.attr.src; &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); this.input_text = web_element.attr.src; &#125;, input:function (e) &#123; var input = this.$el(\"urlInput\"); this.input_text = input.attr.value; &#125; &#125; &#125;&lt;/script&gt; Try it","type":"references"},{"title":"JS Bundle format","path":"references/specs/index.html","permalink":"http://alibaba.github.io/references/specs/index.html","text":"JS Bundle formatJS Bundle Version: v0.3.0 v0.5.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is used to define some custom components for the instance and bootstrap the instance with certain name, config and data. Developers could use all kinds of JS code packager like webpack, browserify, requirejs to organize your whole instance code. Meta InfoThe JS Bundle Must begin with a comment line which is a JSON object like: // &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125; This JSON object as least contains: property framework must be &quot;Weex&quot; property version should be corresponded with the JS Bundle format version Global Members __weex_define__(name, options) __weex_bootstrap__(name, config, data) __weex_document__ __weex_require__(name) __weex_define__(name:string, options: object)Define a custom component named name for current instance with options. example: __weex_define__('rmb', &#123; template: &#123; type: 'div', style: &#123;flexDirection: 'row'&#125;, children: [ &#123;type: 'text', attr: &#123;value: '￥'&#125;&#125;, &#123;type: 'text', attr: &#123;value: this.value&#125;&#125; ] &#125;, data: function () &#123; return &#123; value: '0' &#125; &#125;, methods: &#123;...&#125;&#125;) The enabled component options contains: template: just the same as v0.3.0 style: just the same as v0.3.0 data: a function which return a plain object to observe by the ViewModel methods: a function map to proxy to the ViewModel computed: a map of several computed keys for the ViewModel init, created, ready: lifecycle methods events: event handlers for the ViewModel The enabled ViewModel APIs contains: $el(id): Element: find element by id in current ViewModel scope $vm(id): ViewModel: find sub ViewModel by id $getConfig(): object: get instance config info $broadcast/$emit/$dispatch/$on/$off: listen and fire component events $transition (experimental): animation transition (see more in animation native module) __weex_require__(name: string): objectGet a Weex native module with several native APIs. example: var modal = __weex_require__('modal')modal.toast(&#123; message: 'Hey!', duration: 2&#125;) polyfill for v0.3.0 function __weex_require__(name) &#123; var result define('__weex_require__', function (r, e, m) &#123; result = r('@weex-module/' + name) &#125;) return result&#125; __weex_bootstrap__(nameOrOptions: string|object, config: object?, data: object?): AppInstance | ErrorStart to render by a certain component name or a direct component options as the root element, and some instance config and instance data. If everything fine, it will returns the root app instance. Otherwise it will return an Error instance which describes something wrong. example: __weex_bootstrap__( 'root', &#123; // format 1: // downgrade: &#123; appVersion: '&gt;= 0.5.0' &#125;, // format 2: // downgrade: function (config) &#123; return true &#125; &#125;, &#123; // external data // value: '12345' &#125;) The instance config now only support downgrade property which allows two format: an object like { osVersion, appVersion, weexVersion, deviceModel } a function like function (config) { return true } to return a boolean value. true means normal and false means downgrade. The instance data will merge to root component data. So the root component is also easy to reuse and the instance data is easy to customize. __weex_document__An virtual-DOM Document instance. Also the host of virtual-DOM APIs. Every Weex instance has and must have just one Document instance. Preserved Global Variablesdefine, bootstrap, module, exports, document, require, register, render A whole example// &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125;var modal = __weex_require__('modal')__weex_define__('item', &#123; template: &#123; type: 'div', style: &#123; flexDirection: 'row' &#125;, event: &#123; click: function (e) &#123; this.update(e) &#125; &#125;, children: [ &#123; type: 'image', attr: &#123; src: this.imageUrl &#125;, ...&#125;, &#123; type: 'text', attr: &#123; value: this.title &#125;, ...&#125; ] &#125;, data: function () &#123; return &#123; imageUrl: '', title: '' &#125; &#125;, methods: &#123; update: function (e) &#123; modal.toast(&#123; message: this.title &#125;) &#125; &#125;&#125;)__weex_define__('app', &#123; template: &#123; type: 'div', children: [ &#123; type: 'item', repeat: &#123; expression: function () &#123; return this.list &#125;, key: '$index', value: '$value'&#125; &#125;, attr: &#123; imageUrl: function () &#123; return this.$value.imageUrl &#125;, title: function () &#123; return this.$value.title &#125; &#125; &#125; ] &#125;, data: function () &#123; return &#123; list: [ &#123; imageUrl: 'xxx', title: '111' &#125;, &#123; imageUrl: 'yyy', title: '222' &#125;, &#123; imageUrl: 'zzz', title: '333' &#125; ] &#125; &#125;&#125;)__weex_bootstrap__('app') v0.3.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is organized by several modules with AMD-like format: define('moduleName1', function (require, exports, module) &#123; // content of module1&#125;)define('moduleName2', function (require, exports, module) &#123; // content of module2&#125;)... A whole Weex JS Bundle is concatenated by these modules and last a bootstrap(rootComponentName, optionalConfig, optionalExternalData) function call. define('@weex-component/a', function (require, exports, module) &#123; // content of composed component &lt;a&gt;&#125;)define('@weex-component/b', function (require, exports, module) &#123; // content of composed component &lt;b&gt;&#125;)bootstrap('@weex-component/b') As the sample above, the component name should be hyphenated (a-z, 0-9, “-“). Other characters are not allowed. And, the method call bootstrap() allows 1~3 parameters: root module name (String), config info (optional JSON) and external data (optional JSON). Content of Composed ComponentsA module of composed component contains 3 parts: whole options definition, additional template option definition and additional style option definition. whole options is a piece of JavaScript code to put component options (except template option and style option) into module.exports template option is a piece of JSON-like object assigned to module.exports.template which describes the display structure of this component style option is a piece of JSON object assigned to module.exports.style which describes the reusable styles in this component The template option is required and appeared only once, and the style option and whole options definition are optional. These options are defined and transformed by Transformer. Actually you can also ignore all the format limitation and write options to module.exports as the same result if you are not going to use Transformer. But that’s not recommended. Details of template option definitionsA piece of multi-level embedded JSON-like object which describes the view structure. Every level JSON-like object has these members below: type: a required string, component name/type component: an optional boolean, whether this component is composed or native attr: an optional k-v pairs which contains all attributes of an element, the value could be a string, number, boolean or a function that bind some data value style: an optional k-v pairs which contains all styles of an element, just the same format as the attr classList: an optional array of strings which contains class names for styling. events: an optional k-v pairs whose keys are event type and values are corresponding method names children: an optional array of child components info append: an optional string which determines a compiling workflow strategy: append node-by-node singly or a whole node tree just one time. the default value is node and another supported value is tree. shown: a optional function which returns a boolean value to determine whether this component should be displayed repeat: a optional function which returns a list data to displays components with each Corresponding Keys to Weex Transformer: tag name in Weex file corresponds to type attr if in Weex file corresponds to shown attr repeat in Weex file corresponds to repeat attr append in Weex file corresponds to append attr style in Weex file with CSS syntax corresponds to style attr class in Weex file with class names separated by blanks corresponds to classList attr on*** in Weex file with prefix on corresponds to a k-v pair in events other attributes in Weex file corresponds to attr Child nodes in Weex file corresponds to children All tag names, attr names are case-insensitive and transformed to lower-cased. But the attr values are case-sensitive. Details of style option definitionsJust a two-levels JSON object. The first levels are class names. The second levels are k-v pairs which describes style names &amp; properties for each class name. Corresponding Keys to Weex Transformer: class name corresponds to first level keys prop name corresponds to second level keys prop value corresponds to second level values","type":"references"},{"title":"JS Framework APIs","path":"references/specs/js-framework-apis.html","permalink":"http://alibaba.github.io/references/specs/js-framework-apis.html","text":"JS Framework APIs0.4 Intro about JS RuntimeThese APIs are designed for JS Framework and Native Engine working together. Considering the limitation of mobile phone resource, Weex runs only one JS runtime to handle all Weex instances. So it need a multi-instance management layer in JavaScript. These JS Framework APIs are just designed to do the management job. First, each Weex instance have a lifecycle, from createInstance to destroyInstance. During this period, we can import some extra data by refreshInstance. To communicate with Native Engine, we have a couple of APIs: sendTasks and receiveTasks. They are used to call each other by some commands and messages. And when JS runtime start at the beginning of the app launching, we need something initialized and configured. So we supply some APIs like registerComponents, registerModules. The last API is just for debugging, we supply an API named getRoot to return the whole virtual-DOM data for developers. If any of these API calls failed, an Error object should be returned. Called by native and supplied from JS FrameworkcreateInstance(instanceId, code, options, data)Create a Weex instance from Native Engine instanceId: The unique id for a Weex instance, generated by Native Engine. code: The JS bundle code send from Native Engine. It will be executed by new Function(code) in JS Framework. The code format depends on JS Bundle Foramt options: Optional. An options object. Currently it supports debug flag which enable printing log and bundleUrl flag which the url of bundle. data: Optional. It’s an chance to supply external data instead of the original data in JS bundle. Example: createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')createInstance('x', '...', &#123; bundleUrl, debug, ... &#125;, &#123; a: 1, b: 2 &#125;&#125;) destroyInstance(instanceId)Destroy an existed Weex instance by id from Native Engine refreshInstance(instanceId, data)Refresh data to an existed Weex instance with certain external data from Native Engine Example: refreshInstance('x', &#123;a: 100, b: 200&#125;) registerComponents(components)Register all native components components: A array of whose items are component options that are force part to use. Currently it supports append attribute which forces the appending mechanism (tree or node) when first time rendering. Example: registerComponents([ &#123; type: 'container' &#125;, &#123; type: 'text' &#125;, &#123; type: 'image' &#125;, &#123; type: 'slider', append: 'tree' &#125;, &#123; type: 'list' &#125;, &#123; type: 'cell', append: 'tree' &#125;, ...]) registerModules(modules)Register the name, methods and args format of each module modules: A map that collects all native module definitions. Each module definition is an array which has several API definitions. Each API definition has a name string and an args array which contains a list of each parameter’s type. NOTE: the node type data will actually return its ref property. And the function type data will actually return a unique function id referring to it. Example: registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ], ...&#125;) receiveTasks(instanceId, tasks)Fire events or callbacks to an existed Weex instance from Native Engine tasks[]: A task list. Each task has a method=&quot;fireEvent|callback&quot; property and a list of args. In fireEvent method, the args is ref of the target, event type, event data and domChanges description in order. Note: if some event make virtual-DOM data changed (e.g. value changed in &lt;input&gt; or current index changed in &lt;slider&gt;), the changing of the target element will be passed as domChanges. In callback method, the args is funcId of a handler, data and ifKeepAlive which describes whether this callback handler should be keeping called. (Each callback handler is matched with a funcId when the original call happens.) Example: receiveTasks('x', [&#123;method: 'fireEvent', args: ['x', '13', 'click', &#123;a: 100, b: 200&#125;]&#125;])receiveTasks('x', [&#123;method: 'callback', args: ['x', '7', &#123;a: 100, b: 200&#125;, true]&#125;]) getRoot(instanceId)Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging Example: getRoot('x')// &#123;ref: '_root', type: 'container', attr: &#123;...&#125;, style: &#123;...&#125;, children: [...]&#125; Called from JavaScript and implemented with native codesendTasks(instanceId, tasks)Make native calls from JS Framework tasks[]: A task list. Each task has a module name, a method name, and a args[] list. Example: sendTasks('x', [ &#123;module: 'dom', method: 'addElement', args: ['_root', &#123;ref: '1', type: 'container'&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '2', type: 'text', ...&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '3', type: 'image', ...&#125;, -1]&#125;, ...]) Supporting other JS Framework (experimental)Register a new JS Framework// lib/frameworks/index.jsimport Vue from '...'import React from '...'import Angular from '...'export const frameworks = &#123; Vue, React, Angular&#125; Expose JS Framework APIs// 3rd-party-framework.jsexport function createInstance (id, code, config, data) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; The virtual-DOM tasks should follow virtual-DOM spec. Framework HelperYou can import lib/runtime/helper.js to get two important things: Document class, see virtual-DOM spec for more. sendTasks method. JS Bundle formatYou must ensure the JS Bundle has its first line of code like this: // &#123; \"framework\": \"Vue\" &#125;... to allow JS Runtime to detect which JS Framework it should be opened by. If no valid annotation found. The JS Bundle will be opened by default JS Framework of Weex.","type":"references"},{"title":"JS Bundle format","path":"references/specs/js-bundle-format.html","permalink":"http://alibaba.github.io/references/specs/js-bundle-format.html","text":"JS Bundle formatJS Bundle Version: v0.3.0 v0.5.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is used to define some custom components for the instance and bootstrap the instance with certain name, config and data. Developers could use all kinds of JS code packager like webpack, browserify, requirejs to organize your whole instance code. Meta InfoThe JS Bundle Must begin with a comment line which is a JSON object like: // &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125; This JSON object as least contains: property framework must be &quot;Weex&quot; property version should be corresponded with the JS Bundle format version Global Members __weex_define__(name, options) __weex_bootstrap__(name, config, data) __weex_document__ __weex_require__(name) __weex_define__(name:string, options: object)Define a custom component named name for current instance with options. example: __weex_define__('rmb', &#123; template: &#123; type: 'div', style: &#123;flexDirection: 'row'&#125;, children: [ &#123;type: 'text', attr: &#123;value: '￥'&#125;&#125;, &#123;type: 'text', attr: &#123;value: this.value&#125;&#125; ] &#125;, data: function () &#123; return &#123; value: '0' &#125; &#125;, methods: &#123;...&#125;&#125;) The enabled component options contains: template: just the same as v0.3.0 style: just the same as v0.3.0 data: a function which return a plain object to observe by the ViewModel methods: a function map to proxy to the ViewModel computed: a map of several computed keys for the ViewModel init, created, ready: lifecycle methods events: event handlers for the ViewModel The enabled ViewModel APIs contains: $el(id): Element: find element by id in current ViewModel scope $vm(id): ViewModel: find sub ViewModel by id $getConfig(): object: get instance config info $broadcast/$emit/$dispatch/$on/$off: listen and fire component events $transition (experimental): animation transition (see more in animation native module) __weex_require__(name: string): objectGet a Weex native module with several native APIs. example: var modal = __weex_require__('modal')modal.toast(&#123; message: 'Hey!', duration: 2&#125;) polyfill for v0.3.0 function __weex_require__(name) &#123; var result define('__weex_require__', function (r, e, m) &#123; result = r('@weex-module/' + name) &#125;) return result&#125; __weex_bootstrap__(nameOrOptions: string|object, config: object?, data: object?): AppInstance | ErrorStart to render by a certain component name or a direct component options as the root element, and some instance config and instance data. If everything fine, it will returns the root app instance. Otherwise it will return an Error instance which describes something wrong. example: __weex_bootstrap__( 'root', &#123; // format 1: // downgrade: &#123; appVersion: '&gt;= 0.5.0' &#125;, // format 2: // downgrade: function (config) &#123; return true &#125; &#125;, &#123; // external data // value: '12345' &#125;) The instance config now only support downgrade property which allows two format: an object like { osVersion, appVersion, weexVersion, deviceModel } a function like function (config) { return true } to return a boolean value. true means normal and false means downgrade. The instance data will merge to root component data. So the root component is also easy to reuse and the instance data is easy to customize. __weex_document__An virtual-DOM Document instance. Also the host of virtual-DOM APIs. Every Weex instance has and must have just one Document instance. Preserved Global Variablesdefine, bootstrap, module, exports, document, require, register, render A whole example// &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125;var modal = __weex_require__('modal')__weex_define__('item', &#123; template: &#123; type: 'div', style: &#123; flexDirection: 'row' &#125;, event: &#123; click: function (e) &#123; this.update(e) &#125; &#125;, children: [ &#123; type: 'image', attr: &#123; src: this.imageUrl &#125;, ...&#125;, &#123; type: 'text', attr: &#123; value: this.title &#125;, ...&#125; ] &#125;, data: function () &#123; return &#123; imageUrl: '', title: '' &#125; &#125;, methods: &#123; update: function (e) &#123; modal.toast(&#123; message: this.title &#125;) &#125; &#125;&#125;)__weex_define__('app', &#123; template: &#123; type: 'div', children: [ &#123; type: 'item', repeat: &#123; expression: function () &#123; return this.list &#125;, key: '$index', value: '$value'&#125; &#125;, attr: &#123; imageUrl: function () &#123; return this.$value.imageUrl &#125;, title: function () &#123; return this.$value.title &#125; &#125; &#125; ] &#125;, data: function () &#123; return &#123; list: [ &#123; imageUrl: 'xxx', title: '111' &#125;, &#123; imageUrl: 'yyy', title: '222' &#125;, &#123; imageUrl: 'zzz', title: '333' &#125; ] &#125; &#125;&#125;)__weex_bootstrap__('app') v0.3.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is organized by several modules with AMD-like format: define('moduleName1', function (require, exports, module) &#123; // content of module1&#125;)define('moduleName2', function (require, exports, module) &#123; // content of module2&#125;)... A whole Weex JS Bundle is concatenated by these modules and last a bootstrap(rootComponentName, optionalConfig, optionalExternalData) function call. define('@weex-component/a', function (require, exports, module) &#123; // content of composed component &lt;a&gt;&#125;)define('@weex-component/b', function (require, exports, module) &#123; // content of composed component &lt;b&gt;&#125;)bootstrap('@weex-component/b') As the sample above, the component name should be hyphenated (a-z, 0-9, “-“). Other characters are not allowed. And, the method call bootstrap() allows 1~3 parameters: root module name (String), config info (optional JSON) and external data (optional JSON). Content of Composed ComponentsA module of composed component contains 3 parts: whole options definition, additional template option definition and additional style option definition. whole options is a piece of JavaScript code to put component options (except template option and style option) into module.exports template option is a piece of JSON-like object assigned to module.exports.template which describes the display structure of this component style option is a piece of JSON object assigned to module.exports.style which describes the reusable styles in this component The template option is required and appeared only once, and the style option and whole options definition are optional. These options are defined and transformed by Transformer. Actually you can also ignore all the format limitation and write options to module.exports as the same result if you are not going to use Transformer. But that’s not recommended. Details of template option definitionsA piece of multi-level embedded JSON-like object which describes the view structure. Every level JSON-like object has these members below: type: a required string, component name/type component: an optional boolean, whether this component is composed or native attr: an optional k-v pairs which contains all attributes of an element, the value could be a string, number, boolean or a function that bind some data value style: an optional k-v pairs which contains all styles of an element, just the same format as the attr classList: an optional array of strings which contains class names for styling. events: an optional k-v pairs whose keys are event type and values are corresponding method names children: an optional array of child components info append: an optional string which determines a compiling workflow strategy: append node-by-node singly or a whole node tree just one time. the default value is node and another supported value is tree. shown: a optional function which returns a boolean value to determine whether this component should be displayed repeat: a optional function which returns a list data to displays components with each Corresponding Keys to Weex Transformer: tag name in Weex file corresponds to type attr if in Weex file corresponds to shown attr repeat in Weex file corresponds to repeat attr append in Weex file corresponds to append attr style in Weex file with CSS syntax corresponds to style attr class in Weex file with class names separated by blanks corresponds to classList attr on*** in Weex file with prefix on corresponds to a k-v pair in events other attributes in Weex file corresponds to attr Child nodes in Weex file corresponds to children All tag names, attr names are case-insensitive and transformed to lower-cased. But the attr values are case-sensitive. Details of style option definitionsJust a two-levels JSON object. The first levels are class names. The second levels are k-v pairs which describes style names &amp; properties for each class name. Corresponding Keys to Weex Transformer: class name corresponds to first level keys prop name corresponds to second level keys prop value corresponds to second level values","type":"references"},{"title":"Virtual DOM APIs","path":"references/specs/virtual-dom-apis.html","permalink":"http://alibaba.github.io/references/specs/virtual-dom-apis.html","text":"Virtual DOM APIs0.4 DocumentEach instance has a corresponding document with the instance id. A document has many nodes which compose a node tree. Constructornew Document(id: string, url: string?)MemberscreateElement(tagName: string, props: Object?): ElementCreate a certain type Element. And the props may contain attr object and style object. e.g. createBody(&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}}) createComment(text: string): CommentCreate a Comment with a certain comment text. open()Set a flag which means init rendering start, so each dom update will be called immediately close()Set a flag which means init rendering finished, so the dom updates later will be batched in each task. fireEvent(el: Element, type: string, e: Object?, domChanges: Object?)Fire an certain type of event on a certain element with an event object. When the event leads to some dom changes, the fourth parameter will describe the change just like props parameter in createElement method. Read-only &amp; Gettersid: stringURL: string?body: Elementbody element documentElement: Elementdocument element getRef(ref: string): Node?Get node by ref from the internal node map Note: the documentElement will be generated automatically when a document created, and the body should to be created manually and appended to documentElement to work. The type of a body must be one of div, list or scroller. NodeConstructornew Node()Membersdestroy()Read-only &amp; Gettersref: stringnextSibling: Node?previousSibling: Node?parentNode: Node?Element extends NodeConstructornew Element(type: string, props: Object?, ownerDocument: Document)Create an element and the props may contain attr object and style object. MembersDOM TreeappendChild(node: Node)insertBefore(node: Node, before: Node?)insertAfter(node: Node, after: Node?)removeChild(node: Node, preserved: boolean?)Removes a child. The parameter preserved means whether destroy the removed node immediately or preserve it. clear()DOM propssetAttr(key: string, value: string, silent: boolean?)If silent is true, it won’t cause native calls. Used for handling event with virtual-DOM changes. setStyle(key: string, value: string, silent: boolean?)The silent parameter is just same as setAttr method. setClassStyle(classStyle: Object)The specificity of class style is lower than normal style. In another way the normal style will override the same name value in class style. addEvent(type: string, handler: Function)removeEvent(type: string)fireEvent(type: string, e: any)Read-only &amp; GetterstoJSON(): ObjectFormat of {ref: string, type: string, attr: Object, style: Object, event: Array(string), children: Array} Comment extends NodeComment won’t be passed to the rendering engine. So it’s very useful as a assistant placeholder sometimes. Constructornew Comment(value: string)MembersRead-only &amp; Getterstype: stringReturns &#39;comment&#39; value: string","type":"references"},{"title":"在浏览器中调试","path":"cn/guide/how-to/debug-with-html5.html","permalink":"http://alibaba.github.io/cn/guide/how-to/debug-with-html5.html","text":"如何在浏览器中调试？由于 weex-html5 可以在现代移动浏览器上运行，因此自然支持在浏览器的开发工具中调试 weex-html5 代码。下面将介绍如何使用浏览器的 devTools 调试和分析 weex-html5 程序。以chrome的调试工具为例： Elements使用 Elements 面板来检查 weex-html5 页面的布局和设计，并操纵 DOM 和 CSS 来自由地做一些开发实验。 Console您可以使用 console.log 在控制台上记录信息。 断点您可以设置断点来调试代码，断点是调试代码的最有效的方法之一。断点使您能够暂停脚本执行，然后查看该时刻的调用堆栈变量值。 手动断点是您在特定代码行上设置的各个断点。您可以通过 Chrome DevTools GUI 或在代码中插入 debugger 关键字来设置这些断点。 找出 bug 的精确位置一般来说，有三个可能发生错误的地方：渲染器（weex-html5），js 框架（weex-js框架）和变压器（gulp-weex）。 这里有一些方便以找出错误建议，以便你可以快速识别哪个是哪个地方的错误： 请检查控制台是否有错误。在调试模式如果有一个错误出现，将会在 console 中打印有关于它的信息。 在 bridge/receiver.js，查看是否调用了 callNative 函数。 是否被认为是 API 的方法被执行。 是否调用用于事件触发或执行回调的 callJS 方法。 其他更多关于如何调试 H5 页面的信息请查看 chrome’s devTools docs","type":"guide"},{"title":"使用 Devtools 调试 Weex 页面","path":"cn/guide/how-to/index.html","permalink":"http://alibaba.github.io/cn/guide/how-to/index.html","text":"如何使用 Devtools 调试 Weex 页面Weex Devtools 是为 Weex 开发者服务的一款调试工具，能够审查 Weex app 运行时属性，可对 .we 代码及 JavaScript 代码断点调试，支持 iOS 和 Android 两个平台。 Weex Devtools 基于 Chrome devtools 实现了 Chrome Debugging Protocol，能够使用 Chrome devtools 调试 Weex 项目，其主要功能分为两大部分—— Debugger 和 Inspector。 Devtools 主要功能一览连接设备devtools 可以动态检测客户端的连接绑定请求，同时连接／调试多个 device（或者模拟器）是很容易的事情，连接到 Devtools 的客户端显示在 “Device List” 界面。如下图所示。 点击对应设备的 Debugger 按钮即开始调试流程，并弹出JS断点调试的页面；随后点击 Inspector 按钮可弹出调试 DOM 的页面。 Debugger这个是用来调试 Weex 的 JSBundle 代码的页面，“Sources” tab 能够显示所有 JS 源码，包括 Weex JSFramework 和 JSBundle 代码。可以设置断点、查看调用栈，与 Chrome 浏览器调试类似。“Console” 控制台显示前端的 Log 信息，并能根据级别（info/warn/error等）和关键字过滤。 断点调试 InspectorInspector 功能丰富，能够用来查看 Element \\ Network \\ Console log \\ Screencast \\ BoxModel \\ Native View 等。 Device Screencast &amp; View Inspect如下图所示，通过 Inspector 页面的两个开关，点击右侧 Icon 可以打开设备投屏，然后点击左侧 Icon 再在投屏上点选元素则可以自动在 DOM tree 中定位并审查该元素。 Elements这里展示的是在 Android／iOS 上的 native DOM 树，及其 style 属性和 layout 图。鼠标在 DOM 树移动时，在 device（或模拟器）上对应节点会高亮显示，有助于 native 开发者定位和发现节点。 注意：screencast 只是对屏幕图像拷贝，在远程调试时能看到远程设备界面，数据网络下 screencast 也将有较大流量花销，如果设备就在手头儿则建议关掉。 Elements 审查有两种模式分别是：native 和 vdom。其中，native 模式下展示的是 Weex 所映射的 native view 的结构，它更接近实现本质；vdom 模式则对应 .we 文件中定义的 dom 结构，主要用来审查 .we 文件编译为 JSBundle 之后对应的 dom tree 的逻辑构成。 native view element weex dom element Network这里展示的是 JSBundle 资源加载网络访问的性能。所以如果 JSBundle 资源在设备本地，Network 是没有数据的。 查看网络请求的总耗时和延时 查看网络请求的header和response 控制台这里显示的是 Android／iOS 上的 native log，并不是 JS log（JS log 显示在 Debugger 页面）。同样 native log 也有对应级别–warn/error 等和关键字过滤，native 开发查询很方便。 资源（Android Only）远端访问的资源文件会显示在这里，这里不是查看源码的最佳方式。在 Debugger 页面，“Sources” 里已经有源码并可以断点调试。如果你的应用里有 SQLITE 数据库文件，在这里无需 root 便可以查看和更新，对于 mock 数据来说比较便利。 远程控制 (Android Only)Android 版本支持在 screencast 上进行远程控制，能够通过鼠标模拟在手机的输入事件，方便手机不在本地的用户进行远程调试。 如何安装和启动devtools无论是跑在 iOS 或者 Android 端，weex-devtool 都是必需的，用来启动服务器和 Chrome 页面。 安装如果你已经在前面的教程中安装过 weex-toolkit，就无需再次安装了。 $ npm install -g weex-toolkit 用法 weex debug [options] [we_file|bundles_dir] 选项: -h, --help 显示帮助 -V, --verbose 显示debug服务器运行时的各种log -v, --version 显示版本 -p, --port [port] 设置debug服务器端口号 默认为8088 -e, --entry [entry] debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码) -m, --mode [mode] 设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer 如何在设备或者模拟器上调试weex调试初体验之playground如果你是一名 Weex 调试的新手，那么推荐你先下载 Playground 体验一下 Devtools 调试 JSBundle 的基础流程. 前提: 安装 weex-toolkit，内含调试命令 weex debug android／iOS 设备与 PC 在同一局域网，若位于不同网段请确保防火墙可访问性 Inspector 功能演示 Debugger功能演示 调试步骤: 启动 debug server 执行命令 weex debug 将启动 debug server。如果启动成功将会在 Chrome 打开一个 welcome 页面，在网页下方有一个二维码。 启动 Playground 并扫码 点击启首页左上角的扫码按钮扫码上一步中网页下方的二维码。此时 welcome 页面将会出现你的设备信息。Playground 进入 loading 页面，等待你的下一步操作。 点击网页上的 Debugger 按钮 app 结束 loading 进入 debugging 状态。同时 Chrome 将会打开 Debugger 页面。按照页面提示打开该页的 JavaScript 控制台并进入 source tab。 设置断点刷新当前页 点击 Playground 首页 list 中的任意项将打开一个 Weex 页面，此时在 Sources 里会出现相应的 JSBundle 文件，设置断点并刷新 Playground 即可调试。 点击网页上的 Inspector 按钮 Chrome 会打开 inspector页面，可以查看Element， Console， Network状态。 Weex调试初体验之应用如果是接入 Weex 的应用想调试自己的 Weex 代码，有以下几个方式： 借助 Playground 扫码调试 先确定 Playground 已经是可调试状态 使用命令行工具打开调试功能 weex debug，用 Playground 扫浏览器打开的页面中的二维码 用 Playground 扫描 JSBundle 二维码 手机上即显示 Weex 页面的结果。相应在 “Debugger” 和 “Inspector” 页面调试。 为应用接入 Devtools 接口 Android sdk接入指南 iOS sdk接入指南 有任何问题或者建议，请提交这里，会很快得到解答。 更详细的视频讲解 第一集 devtools简介http://cloud.video.taobao.com/play/u/1955166971/p/1/e/1/t/1/45796387.swf 第二集 inspector功能演示http://cloud.video.taobao.com/play/u/1955166971/p/1/e/1/t/1/45803002.swf 第三集 debugger功能演示http://cloud.video.taobao.com/play/u/1955166971/p/1/e/1/t/1/45803641.swf 第四集 native 与 weex 联调http://cloud.video.taobao.com/play/u/1955166971/p/1/e/1/t/1/45804472.swf 第五集 第三方App接入指南http://cloud.video.taobao.com/play/u/1955166971/p/1/e/1/t/1/45805276.swf","type":"guide"},{"title":"如何引入第三方库","path":"cn/guide/how-to/require-3rd-party-libs.html","permalink":"http://alibaba.github.io/cn/guide/how-to/require-3rd-party-libs.html","text":"如何引入第三方库0.4 在 Get started 中，我们学习了知道可以在 &lt;script&gt; 标签中编写 JavaScript 代码。但是在项目中常用的功能或模块，例如解析url参数，将属性从一些对象扩展到另一个对象等等，在每个组件中复制和粘贴这些代码是一个糟糕的做法，因此迫切需要通过 require 的方式对可复用的代码进行管理。Weex 为开发人员提供了 CommonJS 风格的 require 语法。 我们以 extend 作为例子。 引入本地 JS Modules下面是 extend 最简单的实现，并将其放在 ./common/utils.js 路径中。 function extend(dest, src) &#123; for (var key in src) &#123; dest[key] = src[key] &#125;&#125;exports.extend = extend 在 .we 文件中，extend 可以与require一起使用： &lt;script&gt; var utils = require('./common/utils') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; utils.extend(obj1, obj2) // obj1 =&gt; &#123;a: 1, b: 2&#125;&lt;/script&gt; 引入已经安装的 Node.js Modulesunderscore 是一个 JavaScript 库，它提供了一整套函数式编程的实用功能，而不扩展任何 JavaScript 内置对象。它提供了一个更具稳健性的 extend。 我们可以使用 underscore 的 extend，而不是我们自己实现的版本。首先，在项目中安装 underscore，然后我们便可以将 underscore reuqire 进来并使用它。 npm install underscore &lt;script&gt; var _ = require('underscore') var obj1 = &#123;a: 1&#125; var obj2 = &#123;b: 2&#125; var obj3 = &#123;c: 3&#125; var ret = _.extend(obj1, obj2, obj3) // ret =&gt; &#123;a: 1, b: 2, c: 3&#125;&lt;/script&gt;","type":"guide"},{"title":"将 `.we` 源代码转换成 JS Bundle","path":"cn/guide/how-to/transform-code-into-js-bundle.html","permalink":"http://alibaba.github.io/cn/guide/how-to/transform-code-into-js-bundle.html","text":"将 .we 源代码转换成 JS Bundle0.4 在前面的章节中你已经了解到如何编写及组织 Weex 代码，如果你还有疑问，可参考 语法 及 手册。 但是，Weex 语法的代码必须转换为 JSBundle，以便 Weex JSFramework 可以在 iOS，Android 和浏览器端解析和执行。了解更多信息，可参考 Weex 工作原理 和 JS Bundle 格式 现在，回到将 .we 源代码转换成 JS Bundle 的主题。有几种方法来实现这一目标。 使用 weex-toolkit如果你已经有了 node.js 开发环境，可以直接使用以下命令。关于 node.js 及其他依赖安装可参考安装依赖$npm install -g weex-toolkit 将 .we 文件转换为 JS Bundle$ weex your_best_weex.we -o . your_best_weex.we 将会被转换为 your_best_weex.js 并保存在当前目录。 将 .we 文件转换为 JS Bundle 并开启 watch 功能，实时自动转换$ weex your_best_weex.we -o . --watch 将所有 .we 文件转换到一个目录中$ weex we/file/storage/path -o outputpath we/file/storage/path 目录下的每个 .we 文件都会被转换为 JS Bundle 并保存到 outputpath 目录。 请访问 npmjs.com 了解更多关于 weex-toolkit。 transformernpm install weex-transformer CLI ToolUsage: transformer [options] &lt;file...&gt;Options: -h, --help output usage information -V, --version output the version number -l, --oldFormat [value] whether to transform to old format (default: false) -e, --isEntry [value] whether is an entry module which has `bootstrap` (default: true) -o, --output [path] the output file dirname API transform(name, code, path, elements, config) var transformer = require('weex-transformer')var output = transformer.transform('foo', '/* code here */', '.', &#123;&#125;) 参数： name {string}：当前 bundle 文件名 code {string}：源码 path {string}： 可选，当在某个路径中查找自定义组件时很有用 elements {Object}：可选，存在的自定义组件映射 config {Object}：可选 oldFormat {boolean}：是否转换为旧格式 （默认：false） isEntry {boolean}：是否是具有 bootstrap 的入口模块 （默认：true） 返回值: 一个对象： result {string}：所有自定义组件的 define() 方法和最终的 bootstrap() logs {Array}：相应的警告和错误日志 gulp weexnpm install gulp-weex var gulp = require('gulp')var weex = require('gulp-weex')gulp.task('default', function () &#123; return gulp.src('src/*.html') .pipe(weex(&#123;&#125;)) .pipe(gulp.dest('./dest'))&#125;) 参数: oldFormat {boolean}：是否转换为旧格式 （默认：false） isEntry {boolean}：是否是具有 bootstrap 的入口模块 （默认：true）","type":"guide"},{"title":"组件通信","path":"cn/guide/syntax/comm.html","permalink":"http://alibaba.github.io/cn/guide/syntax/comm.html","text":"组件间通信自定义事件Weex 支持自定义事件，这里有两个相关的设计：1，监听自定义事件；2，创建自定义事件。 监听自定义事件每个 Weex 的 ViewModel 都支持 this.$on(type, handler) 和 this.$off(type[, handler]) 的 API。type 是监听的自定义事件类型，handler 是事件处理函数。 当 handler 被触发时，会有一个事件对象 event 作为第一个参数被传入，事件对象的数据格式基于事件机制中提到的事件描述对象。 创建自定义事件每个 Weex 的 ViewModel 都支持 this.$emit(type, detail) 的 API，可以在当前 ViewModel 中产生一个自定义事件。type 是自定义事件的类型，detail 则是一个对该事件细节补充描述的 JSON 对象，会以 event.detail 的形式出现在处理此事件的函数中。 从子组件向父组件通信首先父组件要监听特定类型的自定义事件，而子组件可以使用 this._parent 找到父组件，然后再调用 this._parent.$emit(type, detail) 方法，即可实现自下而上的通信。例如： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"thumb\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .thumb &#123; width: 200; height: 200; &#125; &lt;/style&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; // Emit notify to parent this._parent.$emit('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo title=\"Hello\" image-url=\"https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png\"&gt;&lt;/foo&gt; &lt;text if=\"eventType\"&gt;event: &#123;&#123;eventType&#125;&#125; - &#123;&#123;eventDetail&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; eventType: '', eventDetail: &#123;&#125; &#125;, created: function () &#123; this.$on('notify', function(event) &#123; // When a notify comes, this handler will be run. // `event.detail` will be `&#123;a: 1&#125;` this.eventType = event.type this.eventDetail = JSON.stringify(event.detail) &#125;) &#125; &#125;&lt;/script&gt; 体验一下 从父组件向子组件通信同理，首先子组件要监听特定类型的自定义事件，而父组件可以使用 this.$vm(id) 找到父组件，然后再调用 this.$vm(id).$emit(type, detail) 方法，即可实现自上而下的通信。例如： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image if=\"imageUrl\" src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"thumb\"&gt;&lt;/image&gt; &lt;text&gt;Foo&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .thumb &#123; width: 200; height: 200; &#125; &lt;/style&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; this.$on('changeImage', function (e) &#123; this.imageUrl = e.detail &#125;.bind(this)) &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo id=\"sub\"&gt;&lt;/foo&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$vm('sub').$emit( 'changeImage', 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png' ) &#125; &#125; &#125;&lt;/script&gt; 体验一下 下一节：页面整体配置","type":"guide"},{"title":"组件封装","path":"cn/guide/syntax/composed-component.html","permalink":"http://alibaba.github.io/cn/guide/syntax/composed-component.html","text":"组件封装经常我们会发现 Weex 的 &lt;template&gt; 中有很多可复用的部分，这时候我们可以将其封装成上层的自定义组件并重用。例如我们可以直接创建一个名为 foo.we 的文件，&lt;foo&gt; 就是自定义组件的组件名称： &lt;!-- foo.we --&gt;&lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var env = 'foo' module.exports = &#123; data: &#123; title: null, image: null &#125; &#125;&lt;/script&gt; foo.we 的也包含 &lt;template&gt;，&lt;style&gt; 和 &lt;script&gt;，定义好了后，直接用 &lt;foo&gt; 标签即可将其引入到其它组件的 &lt;template&gt; 中，并且在 &lt;foo&gt; 标签上设置其 data 同名的特性会将这个值赋给 &lt;foo&gt; 的上下文： 注意事项：由于 HTML 语法中特性名是不区分大小写的，所以您无法直接用驼峰命名，我们提供了 hyphenated 语法，在解析之后这些名称会自动转换为驼峰命名 (比如在 &lt;template&gt; 的组件特性里用 aaa-bbb-ccc 表示其 data 或上下文里的 aaaBbbCcc)。 &lt;!-- bar.we --&gt;&lt;template&gt; &lt;foo title=\"...\" image=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; var env = 'bar'&lt;/script&gt; 注意事项：这里 bar.we 和 foo.we 必须在同目录下才能自动建立依赖关系。 注意事项：foo.we 文件的 &lt;script&gt; 具有相对独立的作用域，不会和 bar.we 中的 &lt;script&gt; 产生干扰。同时 &lt;foo&gt; 对象具有相对独立的子组件上下文，即 this，也包括其定义的完全不同的数据和方法。 组件嵌套自定义组件也支持嵌套，如下： &lt;!-- somepath/foo.we --&gt;&lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;image src=\"&#123;&#123;image&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; // These keys must be declared explicitly here // or data-binding will not work from its parent. title: null, image: null &#125; &#125;&lt;/script&gt; &lt;!-- samepath/foo.list.we --&gt;&lt;template&gt; &lt;div&gt; &lt;text&gt;&#123;&#123;description&#125;&#125;&lt;/text&gt; &lt;foo repeat=\"item in list\" title=\"&#123;&#123;item.text&#125;&#125;\" image=\"&#123;&#123;item.img&#125;&#125;\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; description: '', // This key must be declared explicitly here // or data-binding will not work from its parent. list: [] &#125; &#125;&lt;/script&gt; &lt;!-- samepath/main.we --&gt;&lt;template&gt; &lt;foo-list list=\"&#123;&#123;list&#125;&#125;\"&gt;&lt;/foo-list&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: [ &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, &#123;text: '...', img: '...'&#125;, ... ] &#125; &#125;&lt;/script&gt; 这里的 main.we 嵌套了 &lt;foo-list&gt;，&lt;foo-list&gt; 嵌套了 &lt;foo&gt;，同时组件可以正常的配合数据绑定、repeat 特性等使用。 更多子组件的定义和书写方式除了在主文件同目录下创建和被封装组件同名的 we 文件之外，Weex 还支持另外几种子组件的书写方式： 在 &lt;script&gt; 中通过 require 其它目录的 we 文件定义同名组件 在主文件下新增 &lt;element name=&quot;xxx&quot;&gt; 标签，name 特性的值为新创建的组件名，其 &lt;element&gt; 内部的内容是定义该组件的代码 比如： &lt;!-- path-a/main.we --&gt;&lt;element name=\"foo\"&gt; &lt;text&gt;Foo&lt;/text&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('path-b/bar.we')&lt;/script&gt; &lt;!-- path-b/bar.we --&gt;&lt;template&gt; &lt;text&gt;Bar&lt;/text&gt;&lt;/template&gt; 这样的话，path-a/main.we 最终展示的结果是“Foo”和“Bar”两段文本。 注意事项 组件各自的 &lt;style&gt; 是相互独立的，不会担心不同组件中相同的 class name 相互干扰。 如果自定义组件在父组件中有 id 特性，则可以在父组件上下文中通过 this.$vm(id) 接口来访问该自定义组件的上下文，也可以通过 this.$el(id) 来找到其背后真实的原生组件。更多详见获取子组件信息 自定义组件之间通信的问题可以参考组件间通信 不论通过父组件把数据传递进来还是在当前组件内部对数据发起修改，只有在组件的 data 选项中明确写明的字段才会被正常的监听。 任何组件目前均不支持自闭合标签的写法，请勿使用。 下一节：获取子组件信息","type":"guide"},{"title":"页面配置和页面数据","path":"cn/guide/syntax/config-n-data.html","permalink":"http://alibaba.github.io/cn/guide/syntax/config-n-data.html","text":"页面配置和页面数据在 Weex 中，你可以通过一些特殊的 &lt;script&gt; 进行页面整体配置。 注意事项：这些配置会代表页面整体，所以写在自定义子组件中是无效的，只有写在顶级 ViewModel 的 &lt;sctipt&gt; 中才会生效。 先举个例子： &lt;!-- definition of sub components --&gt;&lt;element name=\"sub-component-a\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-b\"&gt;...&lt;/element&gt;&lt;element name=\"sub-component-c\"&gt;...&lt;/element&gt;&lt;!-- definition of top-level component --&gt;&lt;template&gt;...&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; x: 1, y: 2 &#125; &#125;&lt;/script&gt;&lt;!-- config and data --&gt;&lt;script type=\"config\"&gt; downgrade: &#123; ios: &#123; os: '9', // all of 9.x.x app: '~5.3.2', framework: '^1.3', // all of 1.3.x deviceModel: ['AAAA', 'BBBB'] &#125;, android: &#123; os: '*', // all of version app: '^5', framework: '', deviceModel: '' &#125; &#125;&lt;/script&gt;&lt;script type=\"data\"&gt; &#123; y: 200 &#125;&lt;/script&gt; &lt;script type=&quot;config&quot;&gt;开发者可以在顶级 ViewModel 中加入这样一段 &lt;script&gt;，以 JSON 格式描述页面整体的配置信息。 目前支持的配置信息只有 downgrade：用来从平台、应用等维度描述页面的降级规则。这样设计对于产品迭代最大的帮助是可以在高版本中使用 Weex，而在低版本中使用之前已有的渲染方式，这部分控制降级的细节需要 native 接入的时候进行相应的识别和具体操作。 未来这里会有更多的配置项出现在这里。 &lt;script type=&quot;data&quot;&gt;开发者可以在顶级 ViewModel 中加入这样一段 &lt;script&gt;，以 JSON 格式额外配置顶级 ViewModel 的数据，它会覆盖顶级 ViewModel 数据中相应的字段。比如上述例子中，最终的顶级 ViewModel 中的数据为 { x: 1, y: 200 }。 总结至此，Weex 基本的语法已经全部介绍过了。相信您对 Weex 的使用方式和开发方式有了更多的了解。 接下来我们推荐您阅读： 最佳实践 Weex 手册","type":"guide"},{"title":"数据绑定","path":"cn/guide/syntax/data-binding.html","permalink":"http://alibaba.github.io/cn/guide/syntax/data-binding.html","text":"数据绑定Weex使用 mustache 的语法 ({{...}}) 来对 &lt;template&gt; 中的模板和 &lt;script&gt; 里的数据进行绑定. 一旦数据额模板绑定了, 数据上的修改会实时的在模板内容中生效。 数据绑定路径&lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;\"&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 48, title: 'Alibaba Weex Team' &#125; &#125;&lt;/script&gt; 体验一下 上面的代码会把 title 和 size 的数值绑定到模板内容上。 我们也可以通过 . 符号来绑定数据结构中的字段。看一下下面的代码片段： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;title.size&#125;&#125;\"&gt;&#123;&#123;title.value&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: &#123; size: 48, value: 'Alibaba Weex Team' &#125; &#125; &#125;&lt;/script&gt; 体验一下 数据绑定表达式进行数据绑定时，Weex 支持一些简单的 JavaScript 表达式，例如： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;firstName + ' ' + lastName&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125; &#125;&lt;/script&gt; 体验一下 这些表达式会在当前的上下文中进行运算。 计算属性 v0.5+数据绑定表达式已经非常方便了，但如果希望在模板里实现更复杂的逻辑判断，你也可以使用计算属性。例如： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left: 10;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: function() &#123; return this.firstName + ' ' + this.lastName &#125; &#125;, methods: &#123; changeName: function() &#123; this.firstName = 'Terry' &#125; &#125; &#125;&lt;/script&gt; 体验一下 同样能够达到相同的效果。这里我们引入了一个叫做 fullName 的计算属性，由 firstName 和 lastName 计算而成，在数据绑定的时候，如果 firstName 或 lastName 发生改变，fullName 都会自动重新计算并触发改变。 另外计算属性还支持另外一种写法，就是同时定义一个计算属性的 getter 和 setter，这样的话当下面例子中的 fullName 被赋值时，data 里的 firstName 和 lastName 会被自动改变： &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;fullName&#125;&#125;&lt;/text&gt; &lt;text onclick=\"changeName\" style=\"margin-left: 10;\"&gt;CHANGE NAME&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; firstName: 'John', lastName: 'Smith' &#125;, computed: &#123; fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName &#125;, set: function(v) &#123; var s = v.split(' ') this.firstName = s[0] this.lastName = s[1] &#125; &#125; &#125;, methods: &#123; changeName: function() &#123; this.fullName = 'Terry King' &#125; &#125; &#125;&lt;/script&gt; 体验一下 注意事项：data、methods、computed 中的字段是不能相互重复的，因为它们都会通过组件实例的 this 访问到。 数据绑定在 &lt;template&gt; 中的特殊用法样式: style 或 class组件的样式能够通过 style 特性进行绑定： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;size&#125;&#125;; color: &#123;&#123;color&#125;&#125;;\"&gt;Hello World&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 32, color: '#ff0000' &#125; &#125;&lt;/script&gt; 体验一下 样式也能够通过 class 特性实现样式绑定，多个 class 名通过空格分隔： &lt;template&gt; &lt;div&gt; &lt;text class=\"&#123;&#123;size&#125;&#125;\"&gt;Hello&lt;/text&gt; &lt;text class=\"title &#123;&#123;status&#125;&#125;\"&gt;World&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .large &#123; font-size: 64; &#125; .small &#123; font-size: 32; &#125; .title &#123; font-weight: bold; &#125; .success &#123; color: #00ff00; &#125; .error &#123; color: #ff0000; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; size: 'large', status: 'success' &#125; &#125;&lt;/script&gt; 体验一下 在上面的代码中如果 {{size}} 和 {{status}} 是空值, 就只有 class=&quot;title&quot; 会被解析。 延伸阅读：style 和 class 事件绑定：on...以 on... 开头的就是用于绑定事件的特性，特性名中 on 之后的部分就是事件的类型，特性的值就是处理该事件的函数名。函数名外不需要添加 mustache 语法中的大括号。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: true &#125;, methods: &#123; toggle: function () &#123; this.result = !this.result &#125; &#125; &#125;&lt;/script&gt; 体验一下 除此之外 Weex 还支持更多的事件处理方式。 延伸阅读：事件处理 展示逻辑控制 if &amp; repeatif 特性能够通过特性值的真假来控制组建是否显示，且 mustache 大括号可以省略。例如： &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;text onclick=\"toggle\"&gt;Toggle&lt;/text&gt; &lt;image if=\"&#123;&#123;shown&#125;&#125;\" src=\"&#123;&#123;imageUrl&#125;&#125;\" class=\"logo\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .logo &#123; width: 512; height: 512; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; shown: true, imageUrl: 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png' &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125; &#125;&lt;/script&gt; 体验一下 repeat 特性可以根据一组数组数据重复生成相同或相似的顺序排列的界面。例如： &lt;template&gt; &lt;div&gt; &lt;text repeat=\"(k,v) in list\"&gt;&#123;&#123;k&#125;&#125; - &#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; list: ['a', 'b', 'c'] &#125; &#125;&lt;/script&gt; 体验一下 延伸阅读：展示逻辑控制 静态模板优化 static v0.9.2+static 特性可以一次性把数据设置到模板相应的位置上，但是今后不会随着数据的变化而更新。这样可以减少无谓的数据绑定，有效控制和优化长列表、纯静态页面在运行时的开销。不过你也要小心使用不要导致原本需要更新的视图没有触发更新。 &lt;template&gt; &lt;div static&gt; &lt;text&gt;&#123;&#123; word &#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; ready: function() &#123; this.word = 'Data changes' // UI won't be updated &#125;, data: &#123; word: 'Hello static' &#125; &#125;&lt;/script&gt; 体验一下 如上所示，添加 static 关键字，渲染结果会是“Hello static”字样，相当于渲染一个静态的节点，ready 函数中对数据 word 的改变不会更新到视图。 下一篇：style 和 class","type":"guide"},{"title":"展示逻辑控制","path":"cn/guide/syntax/display-logic.html","permalink":"http://alibaba.github.io/cn/guide/syntax/display-logic.html","text":"展示逻辑控制Weex 支持通过两种特殊的特性 if 和 repeat 确定组件的显示逻辑，这会使得整个界面的展示逻辑控制更加简单灵活。 if通过设置 if 特性值，你可以控制当前组件是否显示。如果值为真，则当前组件会被渲染出来，如果值为假则会被移除。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle Image&lt;/text&gt; &lt;image if=\"shown\" src=\"&#123;&#123;imageUrl&#125;&#125;\" style=\"width: 512; height: 512;\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; imageUrl: 'https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png', shown: true &#125;, methods: &#123; toggle: function () &#123; this.shown = !this.shown &#125; &#125;&#125;&lt;/script&gt; 体验一下 注意事项：if=&quot;condition&quot; 和 if=&quot;{{condition}}&quot; 都是可以的，两者等价使用。 注意事项：if 不能用在 &lt;template&gt; 的根组件上，否则将无法被 Weex 正常的识别和处理。 repeatrepeat 特性用于重复渲染一组相同的组件。它绑定的数据类型必须为数组，数组里的每一项数据可以体现在不同的组件特性、样式、事件绑定等。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 此外，repeat 特性还支持绑定数组中数据项目的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"(index, person) in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 每一个昵称之前都有对应数组项目的索引值。 注意事项：同样的 repeat=&quot;...&quot; 和 repeat=&quot;{{...}}&quot; 都是可以的，两者等价使用。 注意事项：if 不能用在 &lt;template&gt; 的根组件上，否则将无法被 Weex 正常的识别和处理。 注意事项: 当你修改 repeat 中的数组时，在写法上会受到一定的限制，具体如下： 直接通过“角标”修改数组的某个项目 (如 this.items[0] = ...) 是不会触发视图自动更新的。我们在数组的原型上提供了一个额外的方法：this.items.$set(index, item) 来完成相同的事情。 // 和 `this.items[0] = ...` 作用相同，但会自动触发视图更新this.items.$set(0, &#123; childMsg: 'Changed!'&#125;) 直接通过修改 length 来改变数组长度 (如 this.items.length = 0) 也是不会触发视图自动更新的。我们推荐您直接赋值一个新的空数组把旧的替换掉。 // 和 `this.items.length = 0` 作用相同，但会自动触发视图更新this.items = [] repeat 特性中的 $index 形参在 repeat 特性值中，如果没有指定索引值的形参，则可以通过绑定形参 $index 来展示数组项目的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; gender: 'male', nickname: 'Li Lei' &#125;, &#123; gender: 'female', nickname: 'Han Meimei' &#125;, &#123; gender: 'male', nickname: 'Jim Green' &#125; ] &#125;&#125;&lt;/script&gt; 体验一下 渲染效果和上一个例子应该是相同的。 在 repeat 中使用 track-by 特性追踪变化通常情况下，当更新 repeat 中绑定的数组时，所有数组项目关联的组件都会被重新渲染。如果其中部分索引值对应的数据未发生变更，那么最好是让这些组件在渲染层保持原样，仅更新数据有变化的节点。Weex 提供了 track-by 特性来辅助判断哪些数组项目发生了改变。 首先 track-by 特性的值必须是在每一条数组项目中都有且值没有重复的一个字段名，用来区分和追踪每一条数据项增删与否或次序变化与否的关键依据。每当数组发生变化之后，新老数组数据会根据 track-by 特性值所代表的字段重新匹配，然后再决定渲染层应该新建或删除一个组件？还是移动一个组件？还是讲组件保持原来的位置。默认的 track-by 的值就是数组的索引值。例如： &lt;template&gt; &lt;div&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text&gt;----&lt;/text&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\" track-by=\"id\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;text&gt;----&lt;/text&gt; &lt;!-- something wrong here: duplicated track-by value --&gt; &lt;div repeat=\"person in list\" class=\"&#123;&#123;person.gender&#125;&#125;\" track-by=\"nickname\"&gt; &lt;text&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;person.id&#125;&#125; - &#123;&#123;person.nickname&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .male &#123; background-color: #9999ff; &#125; .female &#123; background-color: #ff9999; &#125;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; list: [ &#123; id: 11, gender: 'male', nickname: 'Li Lei' &#125;, &#123; id: 22, gender: 'female', nickname: 'Han Meimei' &#125;, &#123; id: 33, gender: 'male', nickname: 'Jim Green' &#125; ] &#125;, ready: function () &#123; this.list.unshift(&#123; id: 44, gender: 'female', nickname: 'Han Meimei' &#125;) &#125;&#125;&lt;/script&gt; 体验一下 这种情况下，第一个列表的更新策略是： 把第一个 &lt;text&gt; 赋值为 Han Meimei 第二个赋值为 Li Lei 第三个赋值为 Han Meimei 最后新建一个 &lt;text&gt; 并赋值为 Jin Green 第二个列表的更新策略是： 在最前面新建一个 &lt;text&gt; 并赋值为 Han Meimei 第三个列表的更新会遇到问题，因为有两个数组项目的 nickname 值都是 Han Meimei 所以造成意料之外的渲染结果 (只渲染了三个数组项目)。 下一节：渲染过程控制","type":"guide"},{"title":"事件处理","path":"cn/guide/syntax/events.html","permalink":"http://alibaba.github.io/cn/guide/syntax/events.html","text":"事件处理Weex 允许对 &lt;template&gt; 中的元素绑定事件处理函数。 基本语法以 on... 开头的就是用于绑定事件的特性，特性名中 on 之后的部分就是事件的类型，特性的值就是处理该事件的函数名。函数名外不需要添加 mustache 语法中的大括号。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"toggle\"&gt;Toggle: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: true &#125;, methods: &#123; toggle: function () &#123; this.result = !this.result &#125; &#125; &#125;&lt;/script&gt; 体验一下 内联事件处理参数同时我们也支持在事件绑定的特性值中内联写明被传入的参数。例如： &lt;template&gt; &lt;div&gt; &lt;text onclick=\"update(1, 2)\"&gt;Result: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: '&lt;empty&gt;' &#125;, methods: &#123; update: function (x, y) &#123; this.result = x + y &#125; &#125; &#125;&lt;/script&gt; 体验一下 特殊的内联事件处理参数额外的，在这种内联的事件绑定写法中，你可以使用一个特殊的参数 $event，代表事件描述对象，即默认事件处理函数的第一个参数。所以 &lt;template&gt; 中的 onclick=&quot;foo&quot; 和 onclick=&quot;foo($event)&quot; 是等价的，$event 的用法可以更多参考下面的例子 &lt;template&gt; &lt;div&gt; &lt;text onclick=\"update($event, 1, 2)\"&gt;Result: &#123;&#123;result&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; result: '&lt;empty&gt;' &#125;, methods: &#123; update: function (e, x, y) &#123; this.result = e.type + (x + y) &#125; &#125; &#125;&lt;/script&gt; 体验一下 事件描述对象每当一次事件被触发的时候，都会产生一个事件描述对象，该对象会默认作为第一个参数传递给事件处理函数，或以 $event 形参的方式出现在内联事件处理函数中。 每个事件描述对象至少包含以下几个特性： type (string): 事件名称, 如: click target (Element): 目标元素 timestamp (number): 事件触发时的时间戳数字 下一节：展示逻辑控制","type":"guide"},{"title":"语法介绍","path":"cn/guide/syntax/index.html","permalink":"http://alibaba.github.io/cn/guide/syntax/index.html","text":"语法综述Weex 代码由 &lt;template&gt;、&lt;style&gt;、&lt;script&gt; 三个部分构成。 &lt;template&gt;：必须的，使用 HTML 语法描述页面结构，内容由多个标签组成，不同的标签代表不同的组件。 &lt;style&gt;：可选的，使用 CSS 语法描述页面的具体展现形式。 &lt;script&gt;：可选的，使用 JavaScript 描述页面中的数据和页面的行为，Weex 中的数据定义也在 &lt;script&gt; 中进行。 &lt;template&gt; &lt;!-- (required) the structure of page --&gt;&lt;/template&gt;&lt;style&gt; /* (optional) stylesheet */&lt;/style&gt;&lt;script&gt; /* (optional) the definition of data, methods and life-circle */&lt;/script&gt; 这是一个典型的 M-V-VM 架构：通过 ViewModel 把 Model 和 View 建立更直接有效的关系，ViewModel 的实现以 &lt;script&gt; 的内容为主。 &lt;template&gt; 模板&lt;template&gt; 中的标签组织类似如下代码： &lt;template&gt; &lt;div&gt; &lt;image style=\"width: 200; height: 200;\" src=\"https://gtms02.alicdn.com/tps/i2/TB1QHKjMXXXXXadXVXX20ySQVXX-512-512.png\"&gt;&lt;/image&gt; &lt;text&gt;Alibaba Weex Team&lt;/text&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 &lt;div&gt; 标签是一个根节点，里面包含描述图片的 &lt;image&gt; 标签和描述文字的 &lt;text&gt; 标签。 和 HTML 类似，不同标签代表的组件有各自的特性 (attribute)，部分组件可以拥有自己的子组件。 延伸阅读：内置组件列表 根节点：每个 Weex 页面最顶层的节点，我们称为根节点。下面是目前我们支持的三种根节点： &lt;div&gt;：普通根节点，有确定的尺寸，不可滚动。 &lt;scroller&gt;：可滚动根节点，适用于需要全页滚动的场景。 &lt;list&gt;：列表根节点，适用于其中包含重复的子元素的列表场景。 目前 Weex 仅支持以上三种根节点。 注意事项：&lt;template&gt; 只支持一个根节点，多个根节点将无法被 Weex 正常的识别和处理。 &lt;style&gt; 样式我们可以把 Weex 中的样式语法理解为 CSS 的一个子集，两者有一些细微的区别 第一种写法是，你能在标签上，直接通过内联 style 特性编写样式. 第二种写法，通过标签中的 class 特性与 &lt;style&gt; 标签中定义的样式建立对应关系，让 &lt;style&gt; 标签中定义的样式作用于特定标签之上。以下是例子： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: 64;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large\"&gt;Weex Team&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 64;&#125;&lt;/style&gt; 体验一下 上面的两个 &lt;text&gt; 组件都被设置了同样的字体大小，但分别用了两种不同的方式。 延伸阅读：Weex 通用样式 注意：Weex 遵循 HTML 特性 命名规范，所以特性命名时请不要使用陀峰格式 (CamelCase)，采用以“-”分割的 long-name 形式。 &lt;script&gt; 脚本&lt;script&gt; 描述页面中的数据和页面的行为，代码遵循 JavaScript (ES5) 语法 (目前 iOS 端和浏览器端取决于内置 JavaScript 引擎对 ES 版本的支持情况，安卓端能够完整支持 ES5，但不原生支持 ES6，需要用类似 babel 的工具对源代码进行转换)。下面是一个例子： &lt;template&gt; &lt;div&gt; &lt;text&gt;The time is &#123;&#123;datetime&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;getTitle()&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; title: 'Alibaba', datetime: null &#125;, methods: &#123; getTitle: function () &#123; return 'Weex Team' &#125; &#125;, created: function() &#123; this.datetime = new Date().toLocaleString() &#125; &#125;&lt;/script&gt; 体验一下 上面 &lt;script&gt; 标签中定义了被赋值给 module.exports 的对象，这个对象其实就是一个 ViewModel 选项，让三个 &lt;text&gt; 标签显示当前时间、“Alibaba”字样和“Weex Team”字样。 选项中的 data 用于存储数据，这些数据可以通过数据绑定机制和 &lt;template&gt; 标签中的内容绑定起来。当这些数据变更时，被绑定的模板内容也会自动更新。这些数据在 &lt;script&gt; 中的各个方法中可以通过类似 this.x 的方式进行读写操作。 而选项中的 methods 里则列出了当前上下文可执行的各种函数，比如 getTitle()。 选项中最后的 created 是生命周期函数，会在数据初始化之后、界面被绑定数据并渲染之前执行。类似的生命周期函数还有 init、ready 等，在这个例子中，datetime 会在界面渲染之前被更新为当前的时间。 延伸阅读：ViewModel 选项 接下来，我们来详细介绍数据绑定的相关知识。","type":"guide"},{"title":"找节点","path":"cn/guide/syntax/id.html","permalink":"http://alibaba.github.io/cn/guide/syntax/id.html","text":"找节点在 Weex 中，您可以通过在特定的子组件上设置 id 特性，以此在该 &lt;template&gt; 内唯一标识这个组件。 获取子组件您可以在父组件上下文中使用 this.$el(id) 来找到该组件，以运用 scrollToElement() 为例： &lt;template&gt; &lt;div&gt; &lt;text id=\"goto-top\"&gt;Top&lt;/text&gt; &lt;div style=\"height: 10000; background-color: #999999;\"&gt;&lt;/div&gt; &lt;text onclick=\"back2Top\"&gt;Back to Top&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') module.exports = &#123; methods: &#123; back2Top: function () &#123; var el = this.$el('goto-top') dom.scrollToElement(el, &#123; offset: 10 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 id 和 repeat 特性配合使用id 也可以和 repeat 语法配合使用，关于 repeat 更多详见 展示逻辑控制，但是要确保循环的节点需要用不同的 id，比如： &lt;template&gt; &lt;div&gt; &lt;image repeat=\"image in images\" id=\"img-&#123;&#123;image.id&#125;&#125;\" src=\"&#123;&#123;image.url&#125;&#125;\" onclick=\"getImageId\"&gt;&lt;/image&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; images: [ &#123;id: 1, url: '...'&#125;, &#123;id: 2, url: '...'&#125;, &#123;id: 3, url: '...'&#125;, ... ] &#125;, methods: &#123; getImageId: function(e) &#123; // get e.target.id &#125; &#125;&#125;&lt;/script&gt; 获取自定义子组件的上下文另外，我们还可以通过 this.$vm(id) 方法可以访问自定义子组件的上下文： &lt;element name=\"foo\"&gt; &lt;template&gt; &lt;div style=\"flex-direction: row;\"&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: null &#125;, methods: &#123; setTitle: function (text) &#123; this.title = text &#125; &#125; &#125; &lt;/script&gt;&lt;/element&gt;&lt;template&gt; &lt;div&gt; &lt;foo id=\"sub\" title=\"Hello\"&gt;&lt;/foo&gt; &lt;text onclick=\"update\"&gt;Click Me to Update&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; update: function (e) &#123; this.$vm('sub').setTitle('Updated') &#125; &#125; &#125;&lt;/script&gt; 体验一下 实际上，如上述的例子，我们找到子组件上下文之后，直接在这个上下文中调用子组件方法或修改子组件的数据并不是我们认为最好的方式，我们更倾向于通过一套确定的组件间通信机制来完成这一工作。 获取父级组件或其上下文除了可以自上而下寻找组件或其上下文，Weex 也支持自下而上做相同的事情。当前上下文中的 this._parent 可以获取其父级上下文。除了父级上下文，对于父级组件本身，相关处理也可以基于先获取父级上下文，然后在父级组件内部完成更多更细致的处理。更多内容可以深入了解组件间通信的部分。 _注意事项：在未来的版本中 this._parent 将改为 this.$parent。_ 下一篇： 组件间通信","type":"guide"},{"title":"渲染过程控制","path":"cn/guide/syntax/render-logic.html","permalink":"http://alibaba.github.io/cn/guide/syntax/render-logic.html","text":"渲染过程控制appendappend 特性定义了当前组件的子组件： 以一整棵树的方式一次性添加到视图中 (append=&quot;tree&quot;)，还是 每个子组件都产生一次单独的添加到视图的指令 (append=&quot;node&quot;) &lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;div append=\"node\"&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;div append=\"tree\"&gt; &lt;text&gt;Hello&lt;/text&gt; &lt;text&gt;Weex&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 在上面的代码中，第一组和第二组 &lt;div&gt; 的渲染过程相同，即先添加空的父级 &lt;div&gt;，然后插入第一个 &lt;text&gt; Hello，然后插入第二个 &lt;text&gt; Weex；第三组 &lt;div&gt; 则是连带两个 &lt;text&gt; 子组件一齐传给渲染层进行渲染的。 渲染结果显而易见，前两组渲染方式会使首次绘制的响应速度比后者快些，但是总渲染时间可能比第三组 append=&quot;tree&quot; 更长。开发者可以根据实际界面的情况自行选择合理的渲染过程。 默认情况下，除了 &lt;cell&gt; 组件的默认渲染过程是 tree 模式，其它组件都默认按照 node 模式进行渲染。 下一节：自定义组件","type":"guide"},{"title":"CSS 样式和类","path":"cn/guide/syntax/style-n-class.html","permalink":"http://alibaba.github.io/cn/guide/syntax/style-n-class.html","text":"CSS 样式和类基础语法CSS 样式可以理解为一系列的键值对，其中的每一对描述了一个特定的样式，例如组件的宽或者高。 .div &#123; width: 400; height: 50;&#125; 键值对的形式是 prop-name: prop-value;。键名是 prop-name，键值是 prop-value。 一般情况下，键名按照连接符的方式进行命名，键和值之间由冒号 : 进行分隔，每对键值之间由分号 ; 进行分隔。 在 Weex 页面上样式有两种形式： &lt;template&gt; 中的 style 特性 &lt;style&gt; 样式表 &lt;template&gt; 中的 style 特性在 style 特性中编写样式，例如： &lt;template&gt; &lt;div style=\"width: 400; height: 50;\"&gt; ... &lt;/div&gt;&lt;/template&gt; 这段代码的意思是 &lt;div&gt; 组件的宽和高分别为 400 像素和 50 像素。 &lt;style&gt; 样式表例如: &lt;style&gt; .wrapper &#123; width: 600; &#125; .title &#123; width: 400; height: 50; &#125; .highlight &#123; color: #ff0000; &#125;&lt;/style&gt; 样式表包含了多个样式规则，每条规则有一个对应的类，以及由 {...} 包括的若干条样式。例如： .title &#123; width: 400; height: 50; &#125; class 特性&lt;template&gt; 标签中的 class 特性值用来匹配 &lt;style&gt; 样式表中的一个或多个 class 名，多个 class name 之间由空格分隔。例如： &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;text class=\"title\"&gt;...&lt;/text&gt; &lt;text class=\"title highlight\"&gt;...&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .wrapper &#123; width: 600; &#125; .title &#123; width: 400; height: 50; &#125; .highlight &#123; color: #ff0000; &#125;&lt;/style&gt; 体验一下 这段代码的含义是 &lt;div&gt; 组件的宽度是 600 像素，两个 &lt;text&gt; 组件的尺寸为 400x50，其中第二个文本组件是红色字。 注意事项 为了简化页面设计和实现，屏幕的宽度统一为 750 像素，不同设备屏幕都会按照比例转化为这一尺寸进行长度计算。 标准 CSS 支持很多样式选择器，但 Weex 目前只支持单个 class name 的选择器。 标准 CSS 支持很多的长度单位，但 Weex 目前只支持像素，并且 px 单位可以忽略不写，直接使用对应的数值。更多详情请查看通用样式。 子元素的样式不会继承自父元素，这一点与标准 CSS 不同，比如 color 和 font-size 等样式作用在 &lt;text&gt; 上层的 &lt;div&gt; 上是无效的。 标准 CSS 包含了非常多的样式属性，但 Weex 只支持了其中的一部分，比如盒模型、flexbox、position 等布局属性，以及 font-size、color 等其它样式。 与数据绑定结合请查阅数据绑定中有关 style 和 class 特性的相关部分。这里简单举个例子： &lt;template&gt; &lt;div&gt; &lt;text style=\"font-size: &#123;&#123;fontSize&#125;&#125;;\"&gt;Alibaba&lt;/text&gt; &lt;text class=\"large &#123;&#123;textClass&#125;&#125;\"&gt;Weex Team&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .large &#123;font-size: 32;&#125; .highlight &#123;color: #ff0000;&#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; fontSize: 32, textClass: 'highlight' &#125; &#125;&lt;/script&gt; 体验一下 下一篇：事件处理","type":"guide"},{"title":"<cell>","path":"cn/references/components/cell.html","permalink":"http://alibaba.github.io/cn/references/components/cell.html","text":"&lt;cell&gt;用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能，该组件必须作为&lt;list&gt; 组件的子组件, 这是为了优化滚动时的性能。 子组件支持所有 Weex 的组件作为它的子组件。 样式注意： 你不能给 &lt;cell&gt; 设定flex值。 &lt;cell&gt;的宽度等于父组件 &lt;list&gt; 的宽度，并且 &lt;cell&gt; 高度自适应。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例 &lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.header &#123; padding: 25; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.list &#123; background-color: #ffffff;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; page: 1, loadingDisplay: 'show', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<div>","path":"cn/references/components/div.html","permalink":"http://alibaba.github.io/cn/references/components/div.html","text":"&lt;div&gt;&lt;div&gt; 组件是用于包装其它组件的最基本容器。支持所有的通用样式、特性、flexbox 布局。其类似于 HTML 的 &lt;div&gt; 容器，但不能直接在里面添加文本（字符串），如果要展示文本，应该使用 &lt;text&gt; 组件。历史版本中，&lt;div&gt; 别名是 &lt;container&gt;，目前已经弃用。 注意： &lt;div&gt; 嵌套层级不可过深，否则容易引起性能问题，建议控制在 10 层以内。 一个简单例子： &lt;template&gt; &lt;div&gt; &lt;text class=\"text\"&gt;Hello World!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 子组件&lt;div&gt; 基本容器组件，因此支持包括 &lt;div&gt; 在内的任何组件作为自己的子组件。因此，在写一个组件时，推荐外层使用 &lt;div&gt; 作为根容器。 样式&lt;div&gt; 支持所有通用样式： 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件&lt;div&gt; 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 不能直接在 &lt;div&gt; 中添加文本。 错误示例，“Hello World!” 无法被正常渲染。 &lt;template&gt; &lt;div&gt;Hello World!&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.text &#123; font-size: 70; color: #ff0000&#125;&lt;/style&gt;&lt;script&gt;&lt;/script&gt; 体验一下 &lt;div&gt; 不可滚动，即使显式设置高度也一样。 错误示例 示例 &lt;style&gt;.item &#123; padding: 20; height: 220; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.item-content &#123; flex-direction: row; width: 710; background-color: #ffffff;&#125;.item-imgbox &#123; height: 180; width: 180; margin-right: 20;&#125;.item-img &#123; width: 180; height: 180;&#125;.item-info &#123; height: 180; width: 510; justify-content: center; position: relative;&#125;.item-info-detail &#123; position: relative; color: #A2A2A2;&#125;.desc &#123; lines: 4; text-overflow: ellipsis; font-size: 26; line-height: 30; color: #A2A2A2;&#125;.title &#123; lines: 1; text-overflow: ellipsis; font-size: 32; color: #2D2D2D; line-height: 40;&#125;.detail-info &#123; margin-top: 15;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;scroller&gt; &lt;div class=\"item\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item-content\"&gt; &lt;div class=\"item-imgbox\"&gt; &lt;img class=\"item-img\" src=\"&#123;&#123;item.img&#125;&#125;\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;div class=\"item-info-detail\"&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;div class=\"detail-info\"&gt; &lt;text class=\"desc\"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') || &#123;&#125; module.exports = &#123; data: &#123; items: [&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;] &#125;, created: function () &#123; &#125;, methods: &#123; goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<image>","path":"cn/references/components/image.html","permalink":"http://alibaba.github.io/cn/references/components/image.html","text":"&lt;image&gt;&lt;image&gt; 组件用于渲染图片，并且它不能包含任何子组件。可以用 &lt;img&gt; 作简写。 需要注意的是，需要明确指定 width 和 height，否则图片无法显示。 简单例子： &lt;template&gt; &lt;div&gt; &lt;img style=\"width: 560;height: 560;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/img&gt; &lt;/div&gt;&lt;/template&gt; 体验一下 子组件&lt;image&gt; 组件不支持任何子组件，因此不要尝试在 &lt;image&gt; 组件中添加任何组件。如果需要实现 background-image 的效果，可以使用 &lt;image&gt; 组件和 position 定位来现实，如下面代码。 &lt;template&gt; &lt;div&gt; &lt;img style=\"width:750; height:750;\" src=\"https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg\"&gt;&lt;/img&gt; &lt;div class=\"title\"&gt; &lt;text style=\"font-size:50; color: #ff0000\"&gt;你好，image&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .title&#123; position:absolute; top:50; left:10; &#125;&lt;/style&gt; 体验一下 特性&lt;image&gt; 组件，包含 src 和 resize 两个重要特性。 src {string}：定义图片链接，目前图片暂不支持本地图片。 resize {string}：可以控制图片的拉伸状态，值行为和 W3C 标准一致。 可选值为： stretch：默认值，指定图片按照容器拉伸，有可能使图片产生形变。 cover：指定图片可以被调整到容器，以使图片完全覆盖背景区域，图片有可能被剪裁。 contain：指定可以不用考虑容器的大小，把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 例子： 体验一下 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 load v0.8+：当图片加载完成时触发。目前在 Android、iOS 上支持，H5 暂不支持。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 需要指定宽高； 不支持子组件。 示例我们这里展示了一篇文章，文章标题有一副背景图。 这个效果实现起来非常容易，我们只需要将标题文案通过 position: absolute 进行定位即可。唯一需要注意的一点是，Weex 目前不支持 z-index，因此必须把上层元素放在后。 &lt;style&gt; .page-head &#123; width:750; height:200; &#125; .title-bg &#123; width:750; height:200; &#125; .title-box &#123; width: 750; height: 200; justify-content: center; align-items: center; position: absolute; top: 0; right: 0; bottom: 0; left: 0; &#125; .title &#123; color: #ffffff; font-size: 32; font-weight: bold; &#125; .article &#123; padding: 20; &#125; .paragraph&#123; margin-bottom: 15; &#125;&lt;/style&gt;&lt;template&gt; &lt;scroller class=\"wrapper\" &gt; &lt;div class=\"page-head\" &gt; &lt;image class=\"title-bg\" resize=\"cover\" src=\"https://img.alicdn.com/tps/TB1dX5NOFXXXXc6XFXXXXXXXXXX-750-202.png\"&gt;&lt;/image&gt; &lt;div class=\"title-box\"&gt; &lt;text class=\"title\"&gt;Alan Mathison Turing&lt;/text&gt; &lt;/div&gt; &lt;/image&gt; &lt;div class=\"article\"&gt; &lt;text class=\"paragraph\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;During the Second World War, Turing worked for the Government Code and Cypher School (GC&amp;CS) at Bletchley Park, Britain's codebreaking centre. For a time he led Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for speeding the breaking of German ciphers, including improvements to the pre-war Polish bombe method, an electromechanical machine that could find settings for the Enigma machine. Turing played a pivotal role in cracking intercepted coded messages that enabled the Allies to defeat the Nazis in many crucial engagements, including the Battle of the Atlantic; it has been estimated that this work shortened the war in Europe by more than two years and saved over fourteen million lives.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;After the war, he worked at the National Physical Laboratory, where he designed the ACE, among the first designs for a stored-program computer. In 1948 Turing joined Max Newman's Computing Machine Laboratory at the Victoria University of Manchester, where he helped develop the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov–Zhabotinsky reaction, first observed in the 1960s.&lt;/text&gt; &lt;text class=\"paragraph\"&gt;Turing was prosecuted in 1952 for homosexual acts, when by the Labouchere Amendment, \"gross indecency\" was still criminal in the UK. He accepted chemical castration treatment, with DES, as an alternative to prison. Turing died in 1954, 16 days before his 42nd birthday, from cyanide poisoning. An inquest determined his death as suicide, but it has been noted that the known evidence is also consistent with accidental poisoning. In 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for \"the appalling way he was treated.\" Queen Elizabeth II granted him a posthumous pardon in 2013.&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt; 体验一下","type":"references"},{"title":"<a>","path":"cn/references/components/index.html","permalink":"http://alibaba.github.io/cn/references/components/index.html","text":"&lt;a&gt;&lt;a&gt; 组件定义了指向某个页面的一个超链接. 此组件的作用和用法与HTML5中的 &lt;a&gt; 非常类似，区别在于 Weex 的 &lt;a&gt; 组件不能直接在里面添加文本（字符串），如果要展示文本，应该添加 &lt;text&gt; 组件。 一个简单例子： &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a href=\"http://dotwe.org/raw/dist/a468998152ee680413588c38bd61c29e.js\"&gt; &lt;text&gt;click&lt;/text&gt; &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; text-align: center;&#125;&lt;/style&gt; 体验一下 子组件此组件支持除了自己外的所有 Weex 组件作为子组件。 特性 href {string}：定义了超链接的 URL。 样式&lt;a&gt; 支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式。 事件&lt;a&gt; 支持所有通用事件。 click注意：我们不能保证 click 事件和 href 跳转的执行顺序。建议不要使用 click 事件来处理 href 跳转前的逻辑处理。 longpress appear disappear 查看 通用事件。 约束 不能直接在 &lt;a&gt; 中添加文本。错误示例，“click” 无法被正常渲染。 &lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;a href=\"http://dotwe.org/raw/dist/a468998152ee680413588c38bd61c29e.js\"&gt; click &lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; text-align: center;&#125;&lt;/style&gt; 体验一下 请不要为 &lt;a&gt; 添加 click 事件。我们不能确保 click 事件和 href 跳转的执行顺序。 示例&lt;template&gt; &lt;div&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"lines\"&gt; &lt;text class=\"item\"&gt;Repo name: &lt;/text&gt;&lt;a href=\"&#123;&#123;item.repo_url&#125;&#125;\"&gt;&lt;text class=\"link\"&gt;&#123;&#123;item.full_name&#125;&#125;&lt;/text&gt;&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.header &#123; padding: 25; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.list &#123; background-color: #ffffff;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;.lines &#123; flex-direction: row;&#125;.link &#123; color: #008cff; text-decoration: underline;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc', PAGE_URL = 'http://dotwe.org/raw/dist/f1fa0895d0fa0fd80896e02a589443dd.js'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; var repo_url = results[i].html_url if (repo_url) &#123; results[i].repo_url = self.processUrl(repo_url) &#125; self.items.push(results[i]) &#125; &#125; &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125;, processUrl: function (url) &#123; var platform = this.$getConfig().env.platform.toLowerCase() if (url) &#123; // iOS do not need encode if (platform === 'ios') &#123; return PAGE_URL + '?weburl=' + url &#125; else if (platform === 'web') &#123; return url &#125; else &#123; var encodeUrl = encodeURIComponent(url) return PAGE_URL + '?weburl=' + encodeUrl &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; 体验一下。","type":"references"},{"title":"<indicator>","path":"cn/references/components/indicator.html","permalink":"http://alibaba.github.io/cn/references/components/indicator.html","text":"&lt;indicator&gt;&lt;indicator&gt; 组件用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 子组件&lt;indicator&gt; 组件没有任何子组件。 样式&lt;indicator&gt; 组件有一些私有样式，如下： item-color {color}：设置项的颜色，可以是颜色的名称，例如 red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-selected-color {color}：被选中时的颜色，可以是颜色的名称，red；也可以是 16 进制的颜色，例如 #RRGGBB。 item-size {number}：元素的个数。 通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 注意 1： 这里需要注意一点，&lt;indicator&gt; 的 position 不仅依赖 top、left、bottom 和 right 样式，同时会参考 width和 height 样式。&lt;indicator&gt; 默认的宽高继承于 &lt;slider&gt;，如果 &lt;slider&gt; 未设置宽高，需要显式的给 &lt;indicator&gt; 设置宽高值。 注意 2： background-color 不推荐使用，建议使用 item-color 和 item-selected-color 代替。 事件支持所有通用事件。 click longpress appear disappear 查看 通用事件 约束 不支持子组件。 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<input>","path":"cn/references/components/input.html","permalink":"http://alibaba.github.io/cn/references/components/input.html","text":"&lt;input&gt;Weex 内置的 &lt;input&gt; 组件用来创建接收用户输入字符的输入组件。 &lt;input&gt; 组件的工作方式因 type 属性的值而异，比如 &lt;text&gt;， password，url，email，tel 等。 注意： 此组件不支持 click 事件。请监听 &lt;input&gt; 或 change 来代替 click 事件。 子组件不支持子组件。 特性 type {string}：控件的类型，默认值是 &lt;text&gt;。type 值可以是 text，password，url，email，tel 。每个 type 值都符合 W3C 标准。 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：布尔类型的数据，表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：布尔类型的数据，表示是否在页面加载时控件自动获得输入焦点。 maxlength {nubmer}：v0.7一个数值类型的值，表示输入的最大长度。 样式 placeholder-color {color}：placeholder 字符颜色。默认值是 #999999。 text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 约束目前不支持 this.$el(id).value = &#39;&#39; 这种方式改写 input value。只支持在 &lt;input&gt; 组件的 input、change 事件中改写。 示例&lt;template&gt; &lt;div&gt; &lt;input type=\"text\" placeholder=\"Input Something\" class=\"input\" autofocus=\"true\" value=\"\" onchange=\"onchange\" oninput=\"oninput\" /&gt; &lt;text&gt;oninput: &#123;&#123;txtInput&#125;&#125;&lt;/text&gt; &lt;text&gt;onchange: &#123;&#123;txtChange&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .input &#123; font-size: 60; height: 80; width: 400; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; txtInput: '', txtChange: '' &#125;, methods: &#123; onchange: function(event) &#123; this.txtChange = event.value; console.log('onchange', event.value); &#125;, oninput: function(event) &#123; this.txtInput = event.value; console.log('oninput', event.value); &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<loading>","path":"cn/references/components/loading.html","permalink":"http://alibaba.github.io/cn/references/components/loading.html","text":"&lt;loading&gt;v0.6.1+ &lt;loading&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供上拉加载功能。用法与特性与 &lt;refresh&gt; 类似， 是 &lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loading：加载时被触发。 约束 &lt;loading&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，loading 事件仍会被触发。 如果需要 &lt;loading&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 loading 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/loading&gt; &lt;cell class=\"row\" repeat=\"i in staffs\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;i.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onloading:function(e)&#123; console.log('onloading...'); this.staffs.push(&#123;name:'onloading'&#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<refresh>","path":"cn/references/components/refresh.html","permalink":"http://alibaba.github.io/cn/references/components/refresh.html","text":"&lt;refresh&gt;v0.6.1+ &lt;refresh&gt; 为 &lt;scroller&gt; 和 &lt;list&gt; 提供下拉加载功能。用法与特性与 &lt;loading&gt; 类似，&lt;scroller&gt; 和 &lt;list&gt; 的子组件，且只能在被 &lt;scroller&gt; 和 &lt;list&gt; 包含时才能被正确的渲染。 一个简单例子： &lt;template&gt; &lt;list&gt; &lt;header&gt; &lt;div class=\"center\"&gt; &lt;text style=\"text-align:center\"&gt;I am the header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;refresh onpullingdown='onpullingdown' onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\" style=\"width:750;flex-direction: row;justify-content: center;\"&gt; &lt;loading-indicator style=\"height:160;width:160;color:#3192e1\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"i in staffs\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item\"&gt; &lt;text&gt;&#123;&#123;i.name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt; .row &#123; width: 750; &#125; .item &#123; justify-content: center; border-bottom-width: 2; border-bottom-color: #c0c0c0; height: 100; padding:20; &#125; .center &#123; border-bottom-width: 2; border-bottom-color: #cccccc; height: 100; padding:20; background-color:#FFFFFF; justify-content: center; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; staffs:[], refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh' &#125;, created:function() &#123; this.refreshDisplay='show' this.staffs=[&#123;name:'inns'&#125;,&#123;name:'connon'&#125;,&#123;name:'baos'&#125;,&#123;name:'anna'&#125;,&#123;name:'dolley'&#125;,&#123;name:'lucy'&#125;,&#123;name:'john'&#125;, &#123;name:'lily'&#125;,&#123;name:'locke'&#125;,&#123;name:'jack'&#125;,&#123;name:'danny'&#125;,&#123;name:'rose'&#125;,&#123;name:'harris'&#125;,&#123;name:'lotus'&#125;,&#123;name:'louis'&#125;]; &#125;, methods:&#123; onrefresh:function(e)&#123; this.refreshDisplay='show'; this.staffs=[&#123;name:'anna'&#125;,&#123;name:'baos'&#125;,&#123;name:'connon'&#125;,&#123;name:'inns'&#125;]; this.refreshDisplay='hide' &#125;, onpullingdown:function(e)&#123; console.log('onpullingdown triggered.'); console.log('dy:'+e.dy); console.log('headerHeight:'+e.headerHeight); console.log('maxHeight:'+e.maxHeight); &#125; &#125; &#125;&lt;/script&gt; 体验一下 子组件 &lt;text&gt; &lt;image&gt; &lt;loading-indicator&gt;: &lt;refresh&gt; 和 &lt;loading&gt; 组件的子组件，拥有默认的动画效果的实现。 特性 display {string}：可选值为 show 或者 hide，仅隐藏 &lt;indicator&gt;，&lt;loading&gt; 其他子组件依然可见，&lt;loading&gt; 事件仍会被触发。 样式支持所有通用样式。 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 refresh： 当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发。 pullingdown：仅在 Android 支持。当 &lt;scroller&gt;/&lt;list&gt; 被下拉时触发，可以从事件的参数对象中获取 dy，headerHeight，maxHeight 约束 &lt;refresh&gt; 不支持 remove，v0.9 版本会修复。 display 值为 show 或 hide。仅隐藏 &lt;indicator&gt;，&lt;refresh&gt; 其他子组件依然可见，refresh 事件仍会被触发。 如果需要 &lt;refresh&gt; hide 时隐藏文案并不再触发事件，有两种解决方法： 修改提示文案，并在 refresh 事件中添加判断逻辑； v0.9+ 可通过 remove 解决。 只能通过 display 特性进行展示和隐藏，且必须成对出现，即设置 display=&quot;show&quot;,必须有对应的 display=&quot;hide&quot;。 示例&lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"1000\"&gt; &lt;refresh onrefresh=\"onrefresh\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text id=\"refreshText\"&gt;&#123;&#123;refreshText&#125;&#125;&lt;/text&gt; &lt;/refresh&gt; &lt;div repeat=\"v in items\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;loading onloading=\"onloading\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text id=\"loadingText\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; refreshDisplay: 'show', loadingDisplay: 'show', loadingText: 'pull up to load more', refreshText: 'pull down to refresh', items: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 30; i++) &#123; this.items.push(&#123; 'item': 'test data' + i &#125;); &#125; &#125;, methods: &#123; onrefresh: function () &#123; var vm = this; vm.refreshDisplay = 'show' if (vm.items.length &gt; 50) &#123; vm.refreshText = \"no more data!\" vm.refreshDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.unshift(&#123; 'item': 'test data ' + i &#125;); &#125; vm.refreshDisplay = 'hide' &#125;, onloading: function () &#123; var vm = this; vm.loadingDisplay = 'show' if (vm.items.length &gt; 30) &#123; vm.loadingText = \"no more data!\" vm.loadingDisplay = 'hide' return; &#125; var len = vm.items.length; for (var i = len; i &lt; (len + 20); i++) &#123; vm.items.push(&#123; 'item': 'test data ' + i &#125;); &#125; vm.loadingDisplay = 'hide' &#125;, onloadmore: function () &#123; console.log(\"into--[onloadmore]\") &#125; &#125; &#125;&lt;/script&gt; 体验一下 更多示例可查看 &lt;list&gt;","type":"references"},{"title":"<list>","path":"cn/references/components/list.html","permalink":"http://alibaba.github.io/cn/references/components/list.html","text":"&lt;list&gt;&lt;list&gt; 组件是提供垂直列表功能的核心组件，拥有平滑的滚动和高效的内存管理，非常适合用于长列表的展示。最简单的使用方法是在 &lt;list&gt; 标签内使用一组由简单数组 repeat 生成的 &lt;cell&gt; 标签填充。 一个最简例子： &lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell class=\"row\" repeat=\"item in rows\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 体验一下 子组件&lt;list&gt; 组件支持更多高级功能，由以下子组件提供： &lt;cell&gt; 用于定义列表中的子列表项，类似于 HTML 中的 ul 之于 li。Weex 会对 &lt;cell&gt; 进行高效的内存回收以达到更好的性能。 使用文档请查看 &lt;cell&gt;。 header 0.6.1+ 当 &lt;header&gt; 到达屏幕顶部时，吸附在屏幕顶部。 &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 注意： &lt;list&gt; 的子组件只能包括以上四种组件或是 fix 定位的组件，其他形式的组件将不能被正确的渲染。 一个错误的示范，此例子无法在客户端正常渲染，因为 &lt;list&gt; 子组件是 &lt;div&gt;： &lt;template&gt; &lt;list class=\"list\"&gt; &lt;div class=\"row\" repeat=\"item in rows\" index=\"&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/list&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;module.exports = &#123; data: &#123; rows:[ &#123;id: 1&#125;, &#123;id: 2&#125;, &#123;id: 3&#125;, &#123;id: 4&#125;, &#123;id: 5&#125; ] &#125;&#125;&lt;/script&gt; 特性 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与 &lt;list&gt; 底部之间的距离）。当 &lt;list&gt; 的滚动条滚动到足够接近 &lt;list&gt; 底部时将会触发 loadmore 这个事件。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore 0.5+：如果列表滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 体验一下 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是 0 示例&lt;template&gt; &lt;list class=\"list\"&gt; &lt;cell&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;cell class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下 约束 不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 list 或者 &lt;scroller&gt; 中的。 &lt;list&gt; 为根节点时无需设置高度，但是内嵌 &lt;list&gt; 高度必须可计算，你可以使用 flex 或 postion 将 &lt;list&gt; 设为一个响应式高度（例如全屏显示）, 也可以显式设置 &lt;list&gt; 组件的 height 样式。 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<scroller>","path":"cn/references/components/scroller.html","permalink":"http://alibaba.github.io/cn/references/components/scroller.html","text":"&lt;scroller&gt;v0.6.1+ &lt;scroller&gt; 是一个竖直的，可以容纳多个排成一列的子组件的滚动器。如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 注意： &lt;scroller&gt; 可以当作根元素或者嵌套元素使用。此组件的滚动方向是垂直方向的形式。 一个简单例子： &lt;template&gt; &lt;scroller onloadmore=\"onloadmore\" loadmoreoffset=\"100\"&gt; &lt;div repeat=\"v in items\"&gt; &lt;text style=\"font-size: 40; color: #000000\"&gt;&#123;&#123;v.item&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; items: [], triggered: false &#125;, created: function () &#123; for (var i = 0; i &lt; 50; i++) &#123; this.items.push(&#123; 'item': 'test data' + i &#125;); &#125; &#125;, methods: &#123; onloadmore: function () &#123; if (!this.triggered) &#123; for (var i = 100; i &gt;= 50; i--) &#123; this.items.push(&#123; 'item': 'onloadmore triggered' + i &#125;); &#125; &#125; this.triggered = true; &#125; &#125; &#125;&lt;/script&gt; 体验一下 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下两个特殊组件作为子组件： &lt;refresh&gt; 用于给列表添加下拉刷新的功能。 使用文档请查看 &lt;refresh&gt; &lt;loading&gt; &lt;loading&gt; 用法与特性和 &lt;refresh&gt; 类似，用于给列表添加上拉加载更多的功能。 使用文档请查看 &lt;loading&gt; 特性 show-scrollbar {boolean}：可选值为 true/ false，默认值为 true。控制是否出现滚动条。 scroll-direction {string}：可选为 horizontal 或者 vertical，默认值为 vertical 。定义滚动的方向。 loadmoreoffset {number}：默认值为 0，触发 loadmore 事件所需要的垂直偏移距离（设备屏幕底部与页面底部之间的距离）。当页面的滚动条滚动到足够接近页面底部时将会触发 loadmore 这个事件。 loadmoreretry {number}：默认值为 0，当 loadmore 失败时是否重置 loadmore 相关的 UI，值不一样就会重置。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 loadmore v0.5+：如果滚动到底部将会立即触发这个事件，你可以在这个事件的处理函数中加载下一页的列表项。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 扩展scrollToElement(node, options)滚动到列表某个指定项是常见需求，&lt;list&gt; 拓展了该功能支持滚动到指定 &lt;cell&gt;。通过 dom module 访问，更多信息可参考 dom module 。 参数 node {node}：指定目标节点。 options {Object}： offset {number}：一个到其可见位置的偏移距离，默认是0 示例&lt;template&gt; &lt;scroller&gt; &lt;div class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 体验一下 约束不允许相同方向的 &lt;list&gt; 或者 &lt;scroller&gt; 互相嵌套，换句话说就是嵌套的 &lt;list&gt;/&lt;scroller&gt; 必须是不同的方向。 举个例子，不允许一个垂直方向的 &lt;list&gt; 嵌套的一个垂直方向的 &lt;scroller&gt; 中，但是一个垂直方向的 &lt;list&gt; 是可以嵌套的一个水平方向的 &lt;list&gt; 或者 &lt;scroller&gt; 中的。 示例 &lt;style&gt;.item &#123; padding: 20; height: 220; border-bottom-width: 1; border-bottom-style: solid; border-bottom-color: #efefef;&#125;.item-content &#123; flex-direction: row; width: 710; background-color: #ffffff;&#125;.item-imgbox &#123; height: 180; width: 180; margin-right: 20;&#125;.item-img &#123; width: 180; height: 180;&#125;.item-info &#123; height: 180; width: 510; justify-content: center; position: relative;&#125;.item-info-detail &#123; position: relative; color: #A2A2A2;&#125;.desc &#123; lines: 4; text-overflow: ellipsis; font-size: 26; line-height: 30; color: #A2A2A2;&#125;.title &#123; lines: 1; text-overflow: ellipsis; font-size: 32; color: #2D2D2D; line-height: 40;&#125;.detail-info &#123; margin-top: 15;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;template&gt; &lt;div&gt; &lt;scroller&gt; &lt;div class=\"item\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div class=\"item-content\"&gt; &lt;div class=\"item-imgbox\"&gt; &lt;img class=\"item-img\" src=\"&#123;&#123;item.img&#125;&#125;\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item-info\"&gt; &lt;div class=\"item-info-detail\"&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;div class=\"detail-info\"&gt; &lt;text class=\"desc\"&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var dom = require('@weex-module/dom') || &#123;&#125; module.exports = &#123; data: &#123; items: [&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;,&#123; img: 'https://img.alicdn.com/tps/TB1z.55OFXXXXcLXXXXXXXXXXXX-560-560.jpg', title: 'Who is Alan Mathison Turing?', desc: 'Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.' &#125;] &#125;, created: function () &#123; &#125;, methods: &#123; goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: 0 &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<switch>","path":"cn/references/components/switch.html","permalink":"http://alibaba.github.io/cn/references/components/switch.html","text":"&lt;switch&gt;v0.6.1+ &lt;switch&gt; 是 Weex 的内置组件，用来创建与 iOS 一致样式的按钮。例如，在 iPhone 中的设置应用中的飞行模式按钮就是一个 switch 按钮。 子组件&lt;switch&gt; 组件不支持任何子组件。 特性 checked {boolean}：默认值为 false，表明按钮是否开启 is on or not. disabled {boolean}：默认值为 false，表明是否激活按钮 样式值得注意的是，在这个组件上，有些样式组件属性不能使用，它们是： width height min-width min-height margin padding border 注意： 由于设计宽度为 750px，宽度和高度相关的属性不能配置，组件的尺寸限定在 100x60。 通用样式 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change：改变开关状态时触发该事件。 事件中 event 对象属性： value: 组件布尔值真或假。 timestamp: 事件的时间戳。 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;muted:&lt;/text&gt; &lt;switch checked=\"true\" onclick='onclick' onchange='onchange' ondisappear='ondisappear' onappear='onappear'&gt;&lt;/switch&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports =&#123; methods:&#123; onclick:function(e)&#123; console.log('onclick:' + e.timestamp); &#125;, onchange:function(e)&#123; console.log('onchage, value:' + e.value); &#125;, ondisappear:function(e)&#123; console.log('ondisappear, value:' + e.value); &#125;, onappear:function(e)&#123; console.log('onappear, value:' + e.value); &#125;, &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<slider>","path":"cn/references/components/slider.html","permalink":"http://alibaba.github.io/cn/references/components/slider.html","text":"&lt;slider&gt;&lt;slider&gt; 组件用于在一个页面中展示多个图片，在前端，这种效果被称为 轮播图。 子组件支持任意类型的 Weex 组件作为其子组件。 其中，还支持以下组件作为子组件展示特殊效果： &lt;indicator&gt;：用于显示轮播图指示器效果，必须充当 &lt;slider&gt; 组件的子组件使用。 特性 auto-play {boolean}：可选值为 true/false，默认的是 false。 该值决定是否自动播放轮播。重置 loadmore 相关的 UI，值不一样就会重置。 interval {number}：值为毫秒数，此值设定 slider 切换时间间隔。当 auto-play 值为 true 时生效。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 change: 当轮播索引改变时，触发该事件。 事件中 event 对象属性： index：展示的图片索引 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;slider class=\"slider\" interval=\"3000\" auto-play=\"true\"&gt; &lt;div class=\"slider-pages\" repeat=\"item in itemList\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.pictureUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text class=\"title\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;indicator class=\"indicator\"&gt;&lt;/indicator&gt; &lt;/slider&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .img &#123; width: 714; height: 150; &#125; .title &#123; position: absolute; top: 20; left: 20; color: #ff0000; font-size: 48; font-weight: bold; background-color: #eeeeee; &#125; .slider &#123; flex-direction: row; margin: 18; width: 714; height: 230; &#125; .slider-pages &#123; flex-direction: row; width: 714; height: 200; &#125; .indicator &#123; width:714; height:200; position:absolute; top:1; left:1; item-color: red; item-selectedColor: blue; item-size: 20; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; itemList: [ &#123;itemId: '520421163634', title: 'item1', pictureUrl: 'https://gd2.alicdn.com/bao/uploaded/i2/T14H1LFwBcXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'item2', pictureUrl: 'https://gd1.alicdn.com/bao/uploaded/i1/TB1PXJCJFXXXXciXFXXXXXXXXXX_!!0-item_pic.jpg'&#125;, &#123;itemId: '522076777462', title: 'iten3', pictureUrl: 'https://gd3.alicdn.com/bao/uploaded/i3/TB1x6hYLXXXXXazXVXXXXXXXXXX_!!0-item_pic.jpg'&#125; ] &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<text>","path":"cn/references/components/text.html","permalink":"http://alibaba.github.io/cn/references/components/text.html","text":"&lt;text&gt;&lt;text&gt; 是 Weex 内置的组件，用来将文本按照指定的样式渲染出来。&lt;text&gt; 只能包含文本值，你可以使用 {{}} 标记插入变量值作为文本内容。 子组件此组件不支持子组件。 特性 value {string}: 组件的值，与 &lt;text&gt; 标签中的文本内容相同。 样式 lines {number}: 指定文本行数。默认值是 0 代表不限制行数。 text styles: 查看 文本样式 支持 color 样式. 支持 font-size 样式. iOS默认值：32，Android：不同设备不同，H5 默认值：32. 支持 font-style 样式. 支持 font-weight 样式. 支持 text-align 样式. 支持 text-decoration 样式. 支持 text-overflow 样式. 支持 line-height样式0.6.1+ 。line-height 在 iOS 中与 H5 和 Android 中不同， 文本值将放置在框的底部。 不支持 flex-direction, justify-content, align-items 这些为子节点设置的属性，并且&lt;text&gt;没有子节点。 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 约束 &lt;text&gt; 里直接写文本头尾空白会被过滤，如果需要保留头尾空白，暂时只能通过数据绑定写头尾空格。 &lt;template&gt; &lt;div&gt; &lt;text&gt; 测试1，直接放置头尾用空白的文本 &lt;/text&gt; &lt;text&gt;&#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: &#123; msg: ' 测试2，使用数据绑定 ' &#125;&#125;&lt;/script&gt; 体验一下 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;this is text content&lt;/text&gt; &lt;text value=\"this is text value\"&gt;&lt;/text&gt; &lt;text id=\"textid\" onclick=&#123;&#123;showtext&#125;&#125;&gt;this is gettext content&lt;/text&gt; &lt;text value=\"&#123;&#123;text&#125;&#125;\"&gt;&lt;/text&gt; &lt;text style=\"lines: 3;\"&gt;Alan Mathison Turing ( 23 June 1912 – 7 June 1954) was an English computer scientist, mathematician, logician, cryptanalyst and theoretical biologist. He was highly influential in the development of theoretical computer science, providing a formalisation of the concepts of algorithm and computation with the Turing machine, which can be considered a model of a general purpose computer.Turing is widely considered to be the father of theoretical computer science and artificial intelligence.&lt;/text&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt; .text &#123; font-size: 24; text-decoration: underline; &#125;&lt;/style&gt;&lt;script&gt; module.exports = &#123; data: &#123; price1: '99.99', price2: '88.88', text:'' &#125;, methods: &#123; showtext: function(event) &#123; var textComponent = this.$el(\"textid\"); this.text = textComponent.attr.value; &#125; &#125; &#125;;&lt;/script&gt; 体验一下","type":"references"},{"title":"<textarea>","path":"cn/references/components/textarea.html","permalink":"http://alibaba.github.io/cn/references/components/textarea.html","text":"&lt;textarea&gt;v0.8+ textarea 是 Weex 内置的一个组件，用于用户交互，接受用户输入数据。 可以认为是允许多行的 &lt;input&gt; Notes: &lt;textarea&gt;支持 &lt;input&gt; 支持的所有的事件。 子组件textarea 组件不支持子组件。 特性 value {string}：组件的接收到的输入字符。 placeholder {string}：提示用户可以输入什么。 提示文本不能有回车或换行。 disabled {boolean}：表示是否支持输入。通常 click 事件在 disabled 控件上是失效的。 autofocus {boolean}：表示是否在页面加载时控件自动获得输入焦点。 rows {number}：接收 number 类型的数据，指定组件的高度，默认值是 2 样式 text styles 支持 color 支持 font-size 支持 font-style 支持 font-weight 支持 text-align 查看 文本样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 input: 输入字符的值更改。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 change: 当用户输入完成时触发。通常在 blur 事件之后。 事件中 event 对象属性： value: 触发事件的组件； timestamp: 事件发生时的时间戳。 focus: 组件获得输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 blur: 组件失去输入焦点。 事件中 event 对象属性： timestamp: 事件发生时的时间戳。 通用事件 注意：不支持 click 事件。 请监听 input 或 change 事件代替。 支持以下通用事件： longpress appear disappear 查看 通用事件 示例&lt;template&gt; &lt;div&gt; &lt;textarea class=\"textarea\" autofocus=\"true\" placeholder=\"...\" value=\"我是一个多行版本的input组件\"&gt; &lt;/textarea&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .textarea &#123; margin: 20; border-width: 2; border-style: solid; border-color: #efefef; border-radius: 5; &#125;&lt;/style&gt; 体验一下","type":"references"},{"title":"<web>","path":"cn/references/components/web.html","permalink":"http://alibaba.github.io/cn/references/components/web.html","text":"&lt;web&gt;v0.5+ 使用 &lt;web&gt; 组件在 Weex 页面中嵌入一张网页内容。src 属性用来指定资源地址。你也可以使用 webview module 来控制 web 的行为，比如前进、后退和重载。可以在这里查看 webview module。 子组件不支持子组件。 特性 src {string}：此特性指定嵌入的 web 页面 url。 样式 通用样式：不支持部分盒模型样式，支持列表如下： width 组件的宽度，默认值是0。这个样式定义必须指定数值。 height 组件的高度，默认值是0。这个样式定义必须指定数值。 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 pagestart: &lt;web&gt; 组件开始加载时发送此事件消息。 pagefinish: &lt;web&gt; 组件完成加载时发送此事件消息。 error: \b如果 &lt;web&gt; 组件加载出现错误，会发送此事件消息。 通用事件 支持以下通用事件： appear disappear 查看 通用事件 注意： 不支持 click 事件。 示例我们用一个简易浏览器示例，来展示如何使用 &lt;web&gt; 组件和 webview module。 查看 webview module。 &lt;template&gt; &lt;div class=\"browserStyle\"&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;input id=\"urlInput\" type=\"url\" autofocus=\"false\" placeholder=\"input url\" onchange=\"change\" oninput=\"input\" class=\"textStyle\" value=\"https://www.baidu.com\"&gt; &lt;/input&gt; &lt;/div&gt; &lt;div style=\"flex-direction: row\"&gt; &lt;text class=\"buttonSytle\" onclick=\"loadURL\"&gt;LoadURL&lt;/text&gt; &lt;text class=\"buttonSytle\" onclick=\"backforward\"&gt;Backward&lt;/text&gt; &lt;text class=\"buttonSytle\" onclick=\"forward\"&gt;Forward&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;web id=\"webview\" src=\"&#123;&#123;src&#125;&#125;\" class=\"webStyle\"&gt;&lt;/web&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .browserStyle &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color:#778899 ; &#125; .textStyle &#123; width: 750; height: 50; background-color: #D3D3D3; font-size: 30; &#125; .buttonSytle &#123; width:200; height: 50; background-color: #D3D3D3; margin:10; padding-left: 5; padding-right: 5; font-size: 30; &#125; .webStyle &#123; width: 750; height: 800; background-color: #8B0000; &#125;&lt;/style&gt;&lt;script&gt; var web_module = require('@weex-module/webview') module.exports = &#123; data: &#123; src : \"https://h5.m.taobao.com\", &#125;, methods: &#123; loadURL: function (e) &#123; var input = this.$el(\"urlInput\"); this.src = input.attr.value; &#125;, backforward: function (e) &#123; var web_element = this.$el('webview'); web_module.goBack(web_element); &#125;, forward: function (e) &#123; var web_element = this.$el('webview'); web_module.goForward(web_element); &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"<video>","path":"cn/references/components/video.html","permalink":"http://alibaba.github.io/cn/references/components/video.html","text":"&lt;video&gt;v0.6.1+ &lt;video&gt; 组件可以让我们在 Weex 页面中嵌入视频内容。 子组件 &lt;text&gt; 是唯一合法的子组件。 特性 src {string}：内嵌的视频指向的URL play-status {string}：可选值为 play | pause，用来控制视频的播放状态，play 或者 pause，默认值是 pause。 auto-play {boolean}：可选值为 true | false，当页面加载初始化完成后，用来控制视频是否立即播放，默认值是 false。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 start：当 playback 的状态是 Playing 时触发 pause：当 playback 的状态是 Paused 时触发 finish：当 playback 的状态是 Finished 时触发 fail：当 playback 状态是 Failed 时触发 示例&lt;template&gt; &lt;div&gt; &lt;text&gt;Big Eater!&lt;/text&gt; &lt;video class=\"video\" onstart=\"onstart\" onpause=\"onpause\" onfinish=\"onfinish\" onfail=\"onfail\" auto-play=\"false\" play-status=\"pause\" src=\"&#123;&#123;src&#125;&#125;\" style=\"width:750;height:500;\"&gt;&lt;/video&gt; &lt;text&gt;state: &#123;&#123;msg&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt; module.exports =&#123; data: &#123; msg: '', src:'http://flv2.bn.netease.com/videolib3/1611/01/XGqSL5981/SD/XGqSL5981-mobile.mp4' &#125;, methods:&#123; onstart:function(e)&#123; this.msg = 'onstart' &#125;, onpause:function(e)&#123; this.msg = 'onpause' &#125;, onfinish:function(e)&#123; this.msg = 'onfinish' &#125;, onfail:function(e)&#123; this.msg = 'onfinish' &#125;, &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"animation","path":"cn/references/modules/animation.html","permalink":"http://alibaba.github.io/cn/references/modules/animation.html","text":"animation 动画流畅且有意义的动画是一个十分有效的提升移动应用用户体验的手段，animation 模块被用于在组件上执行动画。动画可以对组件执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和不透明度)。举个例子，如果有一个 &lt;image&gt; 组件，通过动画你可以对其进行移动、旋转、拉伸或收缩等动作。 示例&lt;template&gt; &lt;div&gt; &lt;div id=\"test\" class=\"test\" onclick=\"run\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .test &#123; background-color: #6666ff; width: 200; height: 200; &#125;&lt;/style&gt;&lt;script&gt; var animation = require('@weex-module/animation') module.exports = &#123; methods: &#123; run: function () &#123; var testEl = this.$el('test') animation.transition(testEl, &#123; styles: &#123; backgroundColor: '#FF0000', transform: 'translate(100px, 100px)' &#125;, duration: 0, //ms timingFunction: 'ease', 'transform-origin': 'center center', delay: 0 //ms &#125;, function () &#123; console.log('animation finished.') &#125;) &#125; &#125; &#125;&lt;/script&gt; 体验一下 APItransition(el, options, callback)example 参数 el {Element}：将要执行动画的元素，通常可以通过调用 this.$el(id) 来获取元素的引用。 options {Object}：描述动画过程的对象。 options.duration {number}：指定动画的持续时间 (单位是毫秒)，默认值是 0，表示没有动画效果。 options.delay {number}：指定请求动画操作到执行动画之间的时间间隔 (单位是毫秒)，默认值是 0，表示没有延迟，在请求后立即执行动画。 options.timingFunction {string}：描述动画执行的速度曲线，用于使动画变化更为平滑。默认值是 linear，表示动画从开始到结束都拥有同样的速度。下表列出了所有合法的属性： 属性名 描述 示例 linear 动画从头到尾的速度是相同的 example ease-in 动画速度由慢到快 example ease-out 动画速度由快到慢 example ease-in-out 动画先加速到达中间点后减速到达终点 example cubic-bezier(x1, y1, x2, y2) 在三次贝塞尔函数中定义变化过程，函数的参数值必须处于 0 到 1 之间。更多关于三次贝塞尔的信息请参阅 cubic-bezier 和 Bézier curve. example options.styles {Object}：设置不同样式过渡效果的键值对，下表列出了所有合法的参数： 参数名 描述 值类型 默认值 示例 width 动画执行后应用到组件上的宽度值 length 无 example height 动画执行后应用到组件上的高度值 length 无 example backgroundColor 动画执行后应用到组件上的背景颜色 string none example opacity 动画执行后应用到组件上的不透明度值 介于 0 到 1 间的数值 1 example transformOrigin 定义变化过程的中心点. 参数 x-aris 可能的值为 left、center、right、长度值或百分比值, 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比值 x-axis y-axis center center example transform 定义应用在元素上的变换类型，支持下表列出的属性 object 无 example transform属性的合法值: 名称 描述 值类型 默认值 示例 translate/translateX/translateY 指定元素将已被移动到的新位置 像素值或百分比 无 example rotate 指定元素将被旋转的角度，单位是度 number 无 example scale/scaleX/scaleY 按比例放大或缩小元素 number 无 example callback {Function}：动画执行完毕之后的回调","type":"references"},{"title":"dom","path":"cn/references/modules/dom.html","permalink":"http://alibaba.github.io/cn/references/modules/dom.html","text":"dom包含如下可以更新 dom 树的 dom API。 这部分API是通过把 virtual-dom 的消息发送到 native 渲染器来做到的。 开发者在日常开发中，唯一可在 .we 文件中使用的是 scrollToElement。你也可以调用 $scrollTo 方法来使用它 这个页面提及的其他的 API，只在 callNative 进程中的 native 渲染器用。（关于 callNative 进程的进一步介绍，可以在 How it works中的 JS Framework 部分看到 ） APIscrollToElement(node, options)让页面滚动到那个对应的节点，这个API只能在 &lt;scroller&gt; 和 &lt;list&gt; 组件中用。 这个API也能通过调用VM的方法 $scrollTo 来使用（已弃用） 要在你的 .we 文件中使用这个 API，可以使用 require(&#39;@weex-module/dom&#39;).scrollToElement。 参数 node {Node}：你要滚动到的那个节点 options {Object}：如下选项 offset {number}：一个到其可见位置的偏移距离，默认是 0 示例&lt;template&gt; &lt;scroller&gt; &lt;div class=\"row\" repeat=\"item in rows\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;text class=\"item-title\"&gt;row &#123;&#123;item.id&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div onclick=\"go\" style=\"width: 750;height: 50; position: fixed; left: 0; right: 0; bottom: 0; background-color: #eeeeee;\"&gt; &lt;text style=\"text-align: center;\"&gt; Go to 50th line. &lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/template&gt;&lt;script&gt;var dom = require('@weex-module/dom')module.exports = &#123; data: &#123; rows: [] &#125;, created: function () &#123; for (var i = 0; i &lt; 100; i++) &#123; this.rows.push(&#123; id: i &#125;) &#125; &#125;, methods: &#123; go: function () &#123; var el = this.$el('item-49') dom.scrollToElement(el, &#123; offset: 0 &#125;) &#125; &#125;&#125;&lt;/script&gt; 其他dom 还有一些底层接口用于创建 Weex 实例时调用，比如 createBody、updateAttrs 等，但并未开放供外部使用。","type":"references"},{"title":"clipboard","path":"cn/references/modules/clipboard.html","permalink":"http://alibaba.github.io/cn/references/modules/clipboard.html","text":"clipboard 剪切板v0.8+ 我们可以通过 clipboard 模块的 getString()、setString() 接口从系统的粘贴板获取内容或者设置内容。 以前当我们收到一条短信验证码信息时，除了人肉拷贝，我们无法获取拷贝短信的内容。这是非常苦恼的。但是现在我们可以通过简单的调用 clipboard.getString() 接口来获取短信内容了。 示例&lt;template&gt; &lt;div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;hello &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"setContent\"&gt;click me to set: &#123;&#123;tobecopied&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var clipboard = require('@weex-module/clipboard'); module.exports =&#123; data:&#123; tobecopied:'yay!', message:\"nothing.\" &#125;, methods:&#123; setContent:function(e)&#123; clipboard.setString(this.tobecopied); &#125;, onItemClick:function(e)&#123; this.message='clicked! '; clipboard.getString(function(ret) &#123; this.message = 'text from clipboard:'+ ret; &#125;.bind(this)); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text &#123; width: 750; height: 90; &#125;&lt;/style&gt; 体验一下 注意 仅支持文本拷贝 出于安全考虑和平台限制，只支持 Android 和 iOS，不支持 html5。 APIgetString(callback)从系统粘贴板读取内容。 参数 callback {function (ret)}：执行完读取操作后的回调函数。ret {Object} 为 callback 函数的参数，有两个属性： ret.data：获取到的文本内容； ret.result：返回状态，可能为 success 或 fail。 示例var clipboard = require('@weex-module/clipboard');clipboard.getString(function(ret) &#123; console.log(\"text from clipboard： \" + ret.data);&#125;); setString(text)将一段文本复制到剪切板，相当于手动复制文本。 参数 text {string}：要复制到剪切板的字符串。 示例var clipboard = require('@weex-module/clipboard');clipboard.setString(\"SomeStringHere\");","type":"references"},{"title":"内建模块","path":"cn/references/modules/index.html","permalink":"http://alibaba.github.io/cn/references/modules/index.html","text":"内建模块如何使用你可以简单的通过类似 require(&#39;@weex-module/name&#39;) 这样的语法获取一个模块的 API，比如： var dom = require('@weex-module/dom')dom.scrollToElement(this.$el('someIdForElement'), &#123; offset: 0&#125;)","type":"references"},{"title":"globalEvent","path":"cn/references/modules/globalevent.html","permalink":"http://alibaba.github.io/cn/references/modules/globalevent.html","text":"全局事件0.8 (开发中) globalEvent 用于监听持久性事件，例如定位信息，陀螺仪等的变化。全局事件是需要额外 APIs 处理的次要 API。你能通过 addEventListener 注册事件监听，当你不再需要的时候，也可以通过 removingEventListener 取消事件监听。 提醒 这是一个实例级别的事件，而非应用级别。 如何让你的模块支持全局事件API 开发完成后，当需要发送事件时，需要通过以下方法： /** * * @param eventName eventName * @param params event params */instance.fireGlobalEventCallback(eventName,params); 如何在 weex-html5 组件或模块中分发全局事件？只需在文档元素上分派事件： var evt = new Event('some-type')evt.data = &#123; foo: 'bar' &#125;document.dispatchEvent(evt) 示例 AndroidMap&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(\"key\",\"value\");mWXSDKInstance.fireGlobalEventCallback(\"geolocation\",params); iOS[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; APIaddEventListener(String eventName, String callback)注册全局事件。 参数 eventName {string}：需要监听的事件名称。 callback {Function}：触发事件后的回调函数。 示例var globalEvent = require('@weex-module/globalEvent');globalEvent.addEventListener(\"geolocation\", function (e) &#123; console.log(\"get geolocation\")&#125;); removeEventListener(String eventName)取消事件监听。 参数 eventName {string}：需要取消的事件名称。 示例var globalEvent = require('@weex-module/globalEvent');globalEvent.removeEventListener(\"geolocation\");","type":"references"},{"title":"modal","path":"cn/references/modules/modal.html","permalink":"http://alibaba.github.io/cn/references/modules/modal.html","text":"modal 模态modal 模块提供了以下展示消息框的 API：toast、alert、confirm 和 prompt。 APItoast(options)toast() 会在一个小浮层里展示关于某个操作的简单反馈。例如，在邮件发送前离开邮编编辑界面，可以触发一个“草稿已保存”的 toast，告知用户以后可以继续编辑。toast 会在显示一段时间之后自动消失。 参数 options {Object}：相关选项 message {string}：展示的内容 duration {number}：展示的持续时间（以秒为单位） 示例&lt;template&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Toast&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); modal.toast(&#123; 'message': 'I am a toast', 'duration': 3 &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 alert(options, callback)警告框经常用于确保用户可以得到某些信息。当警告框出现后，用户需要点击确定按钮才能继续进行操作。 参数 options {Object}：alert选项 message {string}：警告框内显示的文字信息 okTitle {string}：确定按钮上显示的文字信息，默认是“OK” callback {Function}：用户操作完成后的回调 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Alert&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.alert(&#123; 'message': 'I am alert message', 'okTitle': 'YES' &#125;, function (result) &#123; self.params = String(result) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 confirm(options, callback)确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。 参数 options {object}：confirm 选项 message {string}：确认框内显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (result)}：用户操作完成后的回调，回调函数的参数 result 是确定按钮上的文字信息字符串 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Confirm&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.confirm(&#123; 'message': 'I have read and accept the terms.', 'okTitle': 'YES', 'cancelTitle': 'NO' &#125;, function (e) &#123; self.params = String(e) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下 prompt(options, callback)提示框经常用于提示用户在进入页面前输入某个值。当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作。 参数 options {object}：prompt 选项 message {string}：提示框内要显示的文字信息 okTitle {string}：确认按钮上显示的文字信息，默认是 OK cancelTitle {string}：取消按钮上显示的文字信息，默认是 Cancel callback {function (ret)}：用户操作完成后的回调，回调函数的参数 ret 格式形如 { result: &#39;OK&#39;, data: &#39;hello world&#39; }，如下 result {string}：用户按下的按钮上的文字信息 data {string}：用户输入的文字信息 示例&lt;template&gt; &lt;div&gt; &lt;div style=\"height: 200px; width: 400px; background-color: #00bfff; justify-content: center; align-items: center\" onclick=\"&#123;&#123;perform&#125;&#125;\"&gt; &lt;text style=\"font-size: 60px; color: #ffffff\"&gt;Prompt&lt;/text&gt; &lt;/div&gt; &lt;text&gt;&#123;&#123;params&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; params: '' &#125;, methods: &#123; perform: function () &#123; var modal = require('@weex-module/modal'); var self = this; modal.prompt(&#123; 'message': 'I am a prompt', 'okTitle': 'YES', 'cancelTitle': 'NO' &#125;, function (e) &#123; self.params = JSON.stringify(e) &#125;); &#125; &#125; &#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"navigator","path":"cn/references/modules/navigator.html","permalink":"http://alibaba.github.io/cn/references/modules/navigator.html","text":"navigator 导航控制v0.6.1+ 众所周知，在浏览器里，我们可以通过前进或者回退按钮来切换页面，iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果。 示例&lt;template&gt; &lt;div class=\"div\"&gt; &lt;text class=\"text\" onclick=\"onItemClick\"&gt;click me! &#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var navigator = require('@weex-module/navigator') var nextUrl = 'http://dotwe.org/raw/dist/6cd1703a45d7b2752cf05303069ce881.js' module.exports =&#123; data:&#123; message:'' &#125;, methods:&#123; onItemClick:function(e)&#123; var params = &#123;'url':nextUrl,'animated':'true'&#125; navigator.push(params, function(e) &#123; console.log('i am the callback.') &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .div &#123; flex-direction: row; justify-content: space-between; align-items: center; width: 750; height: 90; padding-left:30; padding-right:30; border-bottom-width: 1; border-style: solid; border-color: #dddddd; &#125; .text&#123; width: 750; height: 90; &#125;&lt;/style&gt; 体验一下 APIpush(options, callback)把一个weex页面URL压入导航堆栈中，可指定在页面跳转时是否需要动画，以及操作完成后需要执行的回调函数 参数 options {Object}：选项参数 url {stirng}：要压入的 Weex 页面的 URL animated {string}：&quot;true&quot; 示意为页面压入时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {Function}：执行完该操作后的回调函数 示例var navigator = require('@weex-module/navigator')var params = &#123; url: 'navigator-demo.js', animated: 'true'&#125;navigator.push(params, function () &#123; // callback&#125;) pop(options, callback)把一个 Weex 页面 URL 弹出导航堆栈中，可指定在页面弹出时是否需要动画，以及操作完成后需要执行的回调函数。 参数 options {object}：选项参数对象 animated {string}：&quot;true&quot; 示意为弹出页面时需要动画效果，&quot;false&quot; 则不需要，默认值为 &quot;true&quot; callback {function}：执行完该操作后的回调函数 示例var navigator = require('@weex-module/navigator')var params = &#123; animated: 'true'&#125;navigator.pop(params, function () &#123; // callback&#125;) 注意事项：animated 二级参数目前仅支持字符串的 &quot;true&quot; 和 &quot;false&quot;，传入布尔值类型会导致程序崩溃，未来版本会修复这个问题","type":"references"},{"title":"storage","path":"cn/references/modules/storage.html","permalink":"http://alibaba.github.io/cn/references/modules/storage.html","text":"storage 本地存储v0.7+ 备注：0.7及以上版本可用 storage 是一个在前端比较常用的模块，可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态。 这里，我们简单模拟“搜索”记录的场景。在搜索的时候写入，然后读取出来展示成列表。 &lt;template&gt; &lt;div style=\"background-color:#F6F6F6;\"&gt; &lt;div class=\"search_view\"&gt; &lt;input class=\"search\" placeholder=\"Please input\" onchange=\"change\"/&gt; &lt;text class=\"btn\" onclick=\"search\"&gt;Search&lt;/text&gt; &lt;/div&gt; &lt;text class=\"item\"&gt;History&lt;/text&gt; &lt;list&gt; &lt;cell repeat=\"(i, v) in items\"&gt; &lt;text class=\"item\"&gt;&#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .search_view&#123; height:70; margin-top:20; margin-left:10; margin-right:10; flex-direction:row; &#125; .search&#123; height:70; border-width:1; border-color:#dddddd; padding-left:10; font-size:28; flex:1; &#125; .btn&#123; width:80; text-align:center; justify-content:center; font-size:28; background-color:#1A89EA; color:#ffffff; &#125; .item&#123; text-align:center; font-size:25; height:50; margin-top:10; color:#5E5E5E; border-bottom-width:1; border-bottom-color:#dddddd; justify-content:center; &#125;&lt;/style&gt;&lt;script&gt; var storage = require('@weex-module/storage'); module.exports = &#123; data: &#123; items: [], keywords:'' &#125;, created: function()&#123; var that = this; storage.getAllKeys(function(e) &#123; if(e.result == 'success' &amp;&amp; e.data.length)&#123; e.data.forEach(function(item)&#123; if(item.indexOf('search_') &gt; -1)&#123; that.items.push(item.split('search_')[1]); &#125; &#125;); &#125; &#125;); &#125;, methods:&#123; search: function()&#123; var that = this; if(!this.keywords) return; storage.setItem('search_' + this.keywords, this.keywords, function(e) &#123; that.items.push(that.keywords);22 &#125;); &#125;, change: function(e)&#123; if(!e.value) return; this.keywords = e.value; &#125; &#125; &#125;;&lt;/script&gt; 体验一下 这里，逐一解释下上面的代码。input 组件监听了 change 事件，可以保存用户输入的搜索关键字。如果用户点击了搜索按钮，则将关键字存储到 storage。这里，使用了 search_ 作为 storage key 的前缀。因此，我们在页面加载时，在 created 生命周期中可以先使用 storage.getAllKeys 获取所有的 key。如果 key 包含了 search_，则说明是搜索记录。因此，将该记录压入数组 items 中，于是界面就会展示出搜索记录的列表。 APIstorage 提供了一系列的 API 供我们调用。我们只需要引入该模块，然后调用对应的 API 即可。 setItem(key, value, callback)该方法可以通过键值对的形式将数据存储到本地。同时可以通过该方法，更新已有的数据。 参数 key {string}：要存储的键，不允许是 &quot;&quot; 或 null value {string}：要存储的值，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示设置成功，invalid_param 表示 key/value 为 &quot;&quot; 或者 null 示例var storage = require('@weex-module/storage')storage.setItem('bar', 'bar-value', function (e) &#123; e.result e.data&#125;) 这里，对返回值做一个简单的介绍： e 包含两个属性：e.result 和 e.data。如果 e.result 返回值是 “success”，则说明成功。e.data 返回 undefined 表示设置成功，返回 invalid_param 表示key/value 为 “” 或者 null。因此，你可以判断两个返回判断是否插入成功。 getItem(key, callback)传入键名返回对应的键值 参数 key {string}：要获取的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：获取对应的键值字符串，如果没有找到则返回 undefined 示例var storage = require('@weex-module/storage')storage.getItem('foo', function (e) &#123; e.data&#125;); removeItem(key, callback)传入一个键名将会删除本地存储中对应的键值 参数 key {string}：要删除的值的名称，不允许是 &quot;&quot; 或 null callback {function (e)}：执行操作成功后的回调. e.result：表示删除是否成功，如果成功返回 &quot;success&quot; e.data：undefined 表示删除成功 示例var storage = require('@weex-module/storage')storage.removeItem('foo', function (e) &#123; e.result e.data&#125;) length(callback)返回本地存储的数据中所有存储项数量的整数 参数 callback {function (e)}：执行操作成功后的回调 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：当前已存储项的数量 示例var storage = require('@weex-module/storage')storage.length(function (e) &#123; e.result e.data&#125;) getAllKeys(callback)返回一个包含全部已存储项键名的数组 参数 callback {function (e)}：执行操作成功后的回调。 e.result：表示设置是否成功，如果成功返回 &quot;success&quot; e.data：所有键名组成的数组 示例var storage = require('@weex-module/storage')storage.getAllKeys(function (e) &#123; e.result e.data&#125;) 其它参考 W3school: html5 localStorage storage 模块完整的 Demo","type":"references"},{"title":"stream","path":"cn/references/modules/stream.html","permalink":"http://alibaba.github.io/cn/references/modules/stream.html","text":"stream概述以下为 stream 相关的 API，用于实现网络请求。 APIfetch(options, callback[,progressCallback])发起网络请求 参数 options {Object}：请求的一些选项 method {string}：HTTP 方法 GET 或是 POST url {string}：请求的 URL headers {Object}：HTTP 请求头 type {string}：请求类型, json,text 或是 jsonp {在原生实现中其实与 json 相同) body {string}：HTTP 请求体。 注意： body 参数仅支持 string 类型的参数，请勿直接传递 JSON，必须先将其转为字符串。 GET 请求不支持 body 方式传递参数，请使用 url 传参。 callback {Function}：响应结果回调，回调函数将收到如下的 response 对象： status {number}：返回的状态码 ok {boolean}：如果状态码在 200~299 之间就为真。 statusText {string}：状态描述文本 data {Object | string}: 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，如果不是，则它就是一个 string。 headers {Object}：响应头 progressCallback {Function}：关于请求状态的回调。 这个回调函数将在请求完成后就被调用: readyState {number}：当前状态state:’1’: 请求连接中opened:’2’: 返回响应头中received:’3’: 正在加载返回数据 status {number}：响应状态码. length {number}：已经接受到的数据长度. 你可以从响应头中获取总长度 statusText {string}：状态文本 headers {Object}：响应头 示例&lt;template&gt; &lt;div class=\"wrapper\"&gt; &lt;list class=\"list\"&gt; &lt;header class=\"header\"&gt; &lt;text class=\"title\"&gt;Search Results&lt;/text&gt; &lt;/header&gt; &lt;refresh style=\"width: 750; padding: 30;\" onrefresh=\"refreshData\" display=\"&#123;&#123;refreshDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt; ↓ Pull to refresh &lt;/text&gt; &lt;loading-indicator class=\"indicator\"&gt;&lt;/loading-indicator&gt; &lt;/refresh&gt; &lt;cell class=\"row\" repeat=\"item in items\" id=\"item-&#123;&#123;$index&#125;&#125;\"&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo name: &#123;&#123;item.full_name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;text class=\"item\"&gt;Repo star: &#123;&#123;item.stargazers_count&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;loading onloading=\"loadingData\" style=\"width: 750; padding: 30;\" display=\"&#123;&#123;loadingDisplay&#125;&#125;\"&gt; &lt;text class=\"text\"&gt;&#123;&#123;loadingText&#125;&#125;&lt;/text&gt; &lt;/loading&gt; &lt;/list&gt; &lt;div class=\"up\" onclick=\"goToTop\"&gt; &lt;img class=\"img\" src=\"https://img.alicdn.com/tps/TB1ZVOEOpXXXXcQaXXXXXXXXXXX-200-200.png\"&gt;&lt;/img&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.wrapper &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0;&#125;.list&#123; background-color: #ffffff; flex: 1;&#125;.header &#123; height: 80; align-items: center; justify-content: center; background-color: #efefef; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.title &#123; text-align: center;&#125;.text &#123; text-align: center;&#125;.row &#123; padding: 20; border-bottom-color: #eeeeee; border-bottom-width: 2; border-bottom-style: solid;&#125;.up &#123; width: 70; height: 70; position: fixed; right: 20; bottom: 20;&#125;.img &#123; width: 70; height: 70;&#125;&lt;/style&gt;&lt;script&gt;var dom = require('@weex-module/dom') || &#123;&#125;var stream = require('@weex-module/stream') || &#123;&#125;var modal = require('@weex-module/modal') || &#123;&#125;var SEARCH_URL = 'https://api.github.com/search/repositories?q=language:javascript&amp;sort=stars&amp;order=desc'module.exports = &#123; data: &#123; isLoaded: true, page: 1, loadingDisplay: 'hide', refreshDisplay: 'hide', loadingText: 'Loading...', items:[] &#125;, created: function () &#123; var url = SEARCH_URL + '&amp;page=' + this.page this.renderData(url) this.page++ &#125;, methods: &#123; renderData: function (url) &#123; var self = this stream.fetch(&#123; method: 'GET', url: url, type:'json' &#125;, function(res) &#123; self.refreshDisplay = 'hide' self.loadingDisplay = 'hide' try &#123; var results = res.data.items || [] if (Array.isArray(results)) &#123; for(var i = 0; i &lt; results.length; i++) &#123; self.items.push(results[i]) &#125; &#125; self.isLoaded = true &#125; catch(e) &#123;&#125; &#125;,function(res)&#123; &#125;) &#125;, loadingData: function (e) &#123; var url = SEARCH_URL + '&amp;page=' + this.page var self = this if (self.isLoaded === false) return self.loadingDisplay = 'show' if (self.page &lt;=10 ) &#123; self.renderData(url) self.page++ &#125; else &#123; self.loadingDisplay = 'hide' self.loadingText = 'NO MORE!' &#125; &#125;, goToTop: function (e) &#123; dom.scrollToElement(this.$el('item-0'), &#123; offset: -100 &#125;) &#125;, refreshData: function (e) &#123; var url = SEARCH_URL + '&amp;page=1' if (this.isLoaded === false) return this.refreshDisplay = 'show' modal.toast(&#123; 'message': 'Refreshing...', 'duration': 1 &#125;) this.items = [] this.page = 1 this.renderData(url) this.refreshDisplay = 'hide' &#125; &#125;&#125;&lt;/script&gt; 体验一下","type":"references"},{"title":"webview","path":"cn/references/modules/webview.html","permalink":"http://alibaba.github.io/cn/references/modules/webview.html","text":"webview一系列的 &lt;web&gt; 组件操作接口。 比如 goBack、goForward、和 reload。webview module 与 &lt;web&gt; 组件共用。 示例查看 简单浏览器 ，一个结合 &lt;web&gt; 组件和 webview module 的示例。 APIgoBack(webElement)加载历史记录里的前一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.goBack(webElement) goForward(webElement)加载历史记录里的下一个资源地址。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.goForward(webElement) reload(webElement)刷新当前页面。 参数 webElement {Element}：&lt;web&gt; 组件对象。 示例var webview = require('@weex-module/webview')var webElement = this.$el('webview')webview.reload(webElement.ref) 注意事项：未来 &lt;web&gt; 组件的 Element 对象将会支持直接这些方法，届时 webview module 将不再需要","type":"references"},{"title":"JS Bundle format (英)","path":"cn/references/specs/index.html","permalink":"http://alibaba.github.io/cn/references/specs/index.html","text":"JS Bundle formatJS Bundle Version: v0.3.0 v0.5.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is used to define some custom components for the instance and bootstrap the instance with certain name, config and data. Developers could use all kinds of JS code packager like webpack, browserify, requirejs to organize your whole instance code. Meta InfoThe JS Bundle Must begin with a comment line which is a JSON object like: // &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125; This JSON object as least contains: property framework must be &quot;Weex&quot; property version should be corresponded with the JS Bundle format version Global Members __weex_define__(name, options) __weex_bootstrap__(name, config, data) __weex_document__ __weex_require__(name) __weex_define__(name:string, options: object)Define a custom component named name for current instance with options. example: __weex_define__('rmb', &#123; template: &#123; type: 'div', style: &#123;flexDirection: 'row'&#125;, children: [ &#123;type: 'text', attr: &#123;value: '￥'&#125;&#125;, &#123;type: 'text', attr: &#123;value: this.value&#125;&#125; ] &#125;, data: function () &#123; return &#123; value: '0' &#125; &#125;, methods: &#123;...&#125;&#125;) The enabled component options contains: template: just the same as v0.3.0 style: just the same as v0.3.0 data: a function which return a plain object to observe by the ViewModel methods: a function map to proxy to the ViewModel computed: a map of several computed keys for the ViewModel init, created, ready: lifecycle methods events: event handlers for the ViewModel The enabled ViewModel APIs contains: $el(id): Element: find element by id in current ViewModel scope $vm(id): ViewModel: find sub ViewModel by id $getConfig(): object: get instance config info $broadcast/$emit/$dispatch/$on/$off: listen and fire component events $transition (experimental): animation transition (see more in animation native module) __weex_require__(name: string): objectGet a Weex native module with several native APIs. example: var modal = __weex_require__('modal')modal.toast(&#123; message: 'Hey!', duration: 2&#125;) polyfill for v0.3.0 function __weex_require__(name) &#123; var result define('__weex_require__', function (r, e, m) &#123; result = r('@weex-module/' + name) &#125;) return result&#125; __weex_bootstrap__(nameOrOptions: string|object, config: object?, data: object?): AppInstance | ErrorStart to render by a certain component name or a direct component options as the root element, and some instance config and instance data. If everything fine, it will returns the root app instance. Otherwise it will return an Error instance which describes something wrong. example: __weex_bootstrap__( 'root', &#123; // format 1: // downgrade: &#123; appVersion: '&gt;= 0.5.0' &#125;, // format 2: // downgrade: function (config) &#123; return true &#125; &#125;, &#123; // external data // value: '12345' &#125;) The instance config now only support downgrade property which allows two format: an object like { osVersion, appVersion, weexVersion, deviceModel } a function like function (config) { return true } to return a boolean value. true means normal and false means downgrade. The instance data will merge to root component data. So the root component is also easy to reuse and the instance data is easy to customize. __weex_document__An virtual-DOM Document instance. Also the host of virtual-DOM APIs. Every Weex instance has and must have just one Document instance. Preserved Global Variablesdefine, bootstrap, module, exports, document, require, register, render A whole example// &#123; \"framework\": \"Weex\", \"version\": \"0.5.0\" &#125;var modal = __weex_require__('modal')__weex_define__('item', &#123; template: &#123; type: 'div', style: &#123; flexDirection: 'row' &#125;, event: &#123; click: function (e) &#123; this.update(e) &#125; &#125;, children: [ &#123; type: 'image', attr: &#123; src: this.imageUrl &#125;, ...&#125;, &#123; type: 'text', attr: &#123; value: this.title &#125;, ...&#125; ] &#125;, data: function () &#123; return &#123; imageUrl: '', title: '' &#125; &#125;, methods: &#123; update: function (e) &#123; modal.toast(&#123; message: this.title &#125;) &#125; &#125;&#125;)__weex_define__('app', &#123; template: &#123; type: 'div', children: [ &#123; type: 'item', repeat: &#123; expression: function () &#123; return this.list &#125;, key: '$index', value: '$value'&#125; &#125;, attr: &#123; imageUrl: function () &#123; return this.$value.imageUrl &#125;, title: function () &#123; return this.$value.title &#125; &#125; &#125; ] &#125;, data: function () &#123; return &#123; list: [ &#123; imageUrl: 'xxx', title: '111' &#125;, &#123; imageUrl: 'yyy', title: '222' &#125;, &#123; imageUrl: 'zzz', title: '333' &#125; ] &#125; &#125;&#125;)__weex_bootstrap__('app') v0.3.0Whole Syntax and StructureA JS Bundle is actually a JavaScript file which follows ES5 standard. The code is organized by several modules with AMD-like format: define('moduleName1', function (require, exports, module) &#123; // content of module1&#125;)define('moduleName2', function (require, exports, module) &#123; // content of module2&#125;)... A whole Weex JS Bundle is concatenated by these modules and last a bootstrap(rootComponentName, optionalConfig, optionalExternalData) function call. define('@weex-component/a', function (require, exports, module) &#123; // content of composed component &lt;a&gt;&#125;)define('@weex-component/b', function (require, exports, module) &#123; // content of composed component &lt;b&gt;&#125;)bootstrap('@weex-component/b') As the sample above, the component name should be hyphenated (a-z, 0-9, “-“). Other characters are not allowed. And, the method call bootstrap() allows 1~3 parameters: root module name (String), config info (optional JSON) and external data (optional JSON). Content of Composed ComponentsA module of composed component contains 3 parts: whole options definition, additional template option definition and additional style option definition. whole options is a piece of JavaScript code to put component options (except template option and style option) into module.exports template option is a piece of JSON-like object assigned to module.exports.template which describes the display structure of this component style option is a piece of JSON object assigned to module.exports.style which describes the reusable styles in this component The template option is required and appeared only once, and the style option and whole options definition are optional. These options are defined and transformed by Transformer. Actually you can also ignore all the format limitation and write options to module.exports as the same result if you are not going to use Transformer. But that’s not recommended. Details of template option definitionsA piece of multi-level embedded JSON-like object which describes the view structure. Every level JSON-like object has these members below: type: a required string, component name/type component: an optional boolean, whether this component is composed or native attr: an optional k-v pairs which contains all attributes of an element, the value could be a string, number, boolean or a function that bind some data value style: an optional k-v pairs which contains all styles of an element, just the same format as the attr classList: an optional array of strings which contains class names for styling. events: an optional k-v pairs whose keys are event type and values are corresponding method names children: an optional array of child components info append: an optional string which determines a compiling workflow strategy: append node-by-node singly or a whole node tree just one time. the default value is node and another supported value is tree. shown: a optional function which returns a boolean value to determine whether this component should be displayed repeat: a optional function which returns a list data to displays components with each Corresponding Keys to Weex Transformer: tag name in Weex file corresponds to type attr if in Weex file corresponds to shown attr repeat in Weex file corresponds to repeat attr append in Weex file corresponds to append attr style in Weex file with CSS syntax corresponds to style attr class in Weex file with class names separated by blanks corresponds to classList attr on*** in Weex file with prefix on corresponds to a k-v pair in events other attributes in Weex file corresponds to attr Child nodes in Weex file corresponds to children All tag names, attr names are case-insensitive and transformed to lower-cased. But the attr values are case-sensitive. Details of style option definitionsJust a two-levels JSON object. The first levels are class names. The second levels are k-v pairs which describes style names &amp; properties for each class name. Corresponding Keys to Weex Transformer: class name corresponds to first level keys prop name corresponds to second level keys prop value corresponds to second level values","type":"references"},{"title":"JS Framework APIs (英)","path":"cn/references/specs/js-framework-apis.html","permalink":"http://alibaba.github.io/cn/references/specs/js-framework-apis.html","text":"JS Framework APIsIntro about JS RuntimeThese APIs are designed for JS Framework and Native Engine working together. Considering the limitation of mobile phone resource, Weex runs only one JS runtime to handle all Weex instances. So it need a multi-instance management layer in JavaScript. These JS Framework APIs are just designed to do the management job. First, each Weex instance have a lifecycle, from createInstance to destroyInstance. During this period, we can import some extra data by refreshInstance. To communicate with Native Engine, we have a couple of APIs: sendTasks and receiveTasks. They are used to call each other by some commands and messages. And when JS runtime start at the beginning of the app launching, we need something initialized and configured. So we supply some APIs like registerComponents, registerModules. The last API is just for debugging, we supply an API named getRoot to return the whole virtual-DOM data for developers. If any of these API calls failed, an Error object should be returned. Called by native and supplied from JS FrameworkcreateInstance(instanceId, code, options, data)Create a Weex instance from Native Engine instanceId: The unique id for a Weex instance, generated by Native Engine. code: The JS bundle code send from Native Engine. It will be executed by new Function(code) in JS Framework. The code format depends on JS Bundle Foramt options: Optional. An options object. Currently it supports debug flag which enable printing log and bundleUrl flag which the url of bundle. data: Optional. It’s an chance to supply external data instead of the original data in JS bundle. Example: createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')createInstance('x', '...', &#123; bundleUrl, debug, ... &#125;, &#123; a: 1, b: 2 &#125;&#125;) destroyInstance(instanceId)Destroy an existed Weex instance by id from Native Engine refreshInstance(instanceId, data)Refresh data to an existed Weex instance with certain external data from Native Engine Example: refreshInstance('x', &#123;a: 100, b: 200&#125;) registerComponents(components)Register all native components components: A array of whose items are component options that are force part to use. Currently it supports append attribute which forces the appending mechanism (tree or node) when first time rendering. Example: registerComponents([ &#123; type: 'container' &#125;, &#123; type: 'text' &#125;, &#123; type: 'image' &#125;, &#123; type: 'slider', append: 'tree' &#125;, &#123; type: 'list' &#125;, &#123; type: 'cell', append: 'tree' &#125;, ...]) registerModules(modules)Register the name, methods and args format of each module modules: A map that collects all native module definitions. Each module definition is an array which has several API definitions. Each API definition has a name string and an args array which contains a list of each parameter’s type. NOTE: the node type data will actually return its ref property. And the function type data will actually return a unique function id referring to it. Example: registerModules(&#123; event: [ &#123;name: 'openURL', args: ['string']&#125; ], ...&#125;) receiveTasks(instanceId, tasks)Fire events or callbacks to an existed Weex instance from Native Engine tasks[]: A task list. Each task has a method=&quot;fireEvent|callback&quot; property and a list of args. In fireEvent method, the args is ref of the target, event type, event data and domChanges description in order. Note: if some event make virtual-DOM data changed (e.g. value changed in &lt;input&gt; or current index changed in &lt;slider&gt;), the changing of the target element will be passed as domChanges. In callback method, the args is funcId of a handler, data and ifKeepAlive which describes whether this callback handler should be keeping called. (Each callback handler is matched with a funcId when the original call happens.) Example: receiveTasks('x', [&#123;method: 'fireEvent', args: ['x', '13', 'click', &#123;a: 100, b: 200&#125;]&#125;])receiveTasks('x', [&#123;method: 'callback', args: ['x', '7', &#123;a: 100, b: 200&#125;, true]&#125;]) getRoot(instanceId)Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging Example: getRoot('x')// &#123;ref: '_root', type: 'container', attr: &#123;...&#125;, style: &#123;...&#125;, children: [...]&#125; Called from JavaScript and implemented with native codesendTasks(instanceId, tasks)Make native calls from JS Framework tasks[]: A task list. Each task has a module name, a method name, and a args[] list. Example: sendTasks('x', [ &#123;module: 'dom', method: 'addElement', args: ['_root', &#123;ref: '1', type: 'container'&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '2', type: 'text', ...&#125;, -1]&#125;, &#123;module: 'dom', method: 'addElement', args: ['1', &#123;ref: '3', type: 'image', ...&#125;, -1]&#125;, ...]) Supporting other JS Framework (experimental)Register a new JS Framework// lib/frameworks/index.jsimport Vue from '...'import React from '...'import Angular from '...'export const frameworks = &#123; Vue, React, Angular&#125; Expose JS Framework APIs// 3rd-party-framework.jsexport function createInstance (id, code, config, data) &#123; ... &#125;export function destroyInstance (id) &#123; ... &#125;export function refreshInstance (id, data) &#123; ... &#125;export function registerComponents (components) &#123; ... &#125;export function registerModules (modules) &#123; ... &#125;export function recieveTasks (id, tasks) &#123; ... &#125;export function getRoot (id) &#123; ... &#125; The virtual-DOM tasks should follow virtual-DOM spec. Framework HelperYou can import lib/runtime/helper.js to get two important things: Document class, see virtual-DOM spec for more. sendTasks method. JS Bundle formatYou must ensure the JS Bundle has its first line of code like this: // &#123; \"framework\": \"Vue\" &#125;... to allow JS Runtime to detect which JS Framework it should be opened by. If no valid annotation found. The JS Bundle will be opened by default JS Framework of Weex.","type":"references"},{"title":"Virtual DOM APIs","path":"cn/references/specs/virtual-dom-apis.html","permalink":"http://alibaba.github.io/cn/references/specs/virtual-dom-apis.html","text":"Virtual DOM APIsDocument每个实例有一个与实例 id 对应的 document。Document 具有组成一个节点树的多个节点。 构造函数new Document(id: string, url: string?)成员createElement(tagName: string, props: Object?): Element创建一个特定类型 Element 对象。props 对象可能包含一个 attr 对象和一个 style 对象。例如 createBody(&#39;div&#39;, {style: {backgroundColor: &#39;#ffffff&#39;}}) createComment(text: string): Comment创建一个具有一些注释文本的 Comment 对象。 open()初始化渲染开始时设置一个标志，表示初始化渲染开始，每个 DOM 更新将被立即调用。 close()初始化渲染完成时设置一个标志，标识初始化渲染完成，DOM 更新以后将在每个任务中批处理。 fireEvent(el: Element, type: string, e: Object?, domChanges: Object?)在某个元素上触发一个带有特定类型的事件，这个事件带有一个事件对象。当事件导致一些 DOM 的变化，第四个参数将像 createElement 方法里的 props 参数一样描述这些 DOM 变化。 只读属性 &amp; Gettersid: stringURL: string?body: Elementbody 元素 documentElement: Elementdocument 元素 getRef(ref: string): Node?通过内部 node map 的 ref 获取节点。 注意： 在一个 document 被创建时会自动生成一个 documentElement ，并且 body 应该手动创建并添加到 documentElement 才能工作。body 的 type 必须是一个 div，list 或 scroller。 Node构造函数new Node()成员destroy()只读属性 &amp; Gettersref: stringnextSibling: Node?previousSibling: Node?parentNode: Node?Element extends Node构造函数new Element(type: string, props: Object?, ownerDocument: Document)创建一个元素，并且 props 对象可能包含一个 attr 对象和一个 style 对象。 成员DOM 树appendChild(node: Node)insertBefore(node: Node, before: Node?)insertAfter(node: Node, after: Node?)removeChild(node: Node, preserved: boolean?)移除一个子节点。preserved 参数表示是否立即销毁删除该节点或保存它。 clear()DOM propssetAttr(key: string, value: string, silent: boolean?)如果 silent 为 true，也不会调用 native。用于有 virtual-DOM 变化的事件处理。 setStyle(key: string, value: string, silent: boolean?)silent 参数作用与 setAttr 中的一样。 setClassStyle(classStyle: Object)class 样式的 CSS 优先级低于内联样式，当两种样式风格出现时，内联样式的值会覆盖 class 样式的值。 addEvent(type: string, handler: Function)removeEvent(type: string)fireEvent(type: string, e: any)只读属性 &amp; GetterstoJSON(): Object格式化 {ref: string, type: string, attr: Object, style: Object, event: Array(string), children: Array} Comment extends NodeComment 将不被传给渲染引擎。因此，可作为占位符使用。 构造函数new Comment(value: string)成员只读属性 &amp; Getterstype: string返回 &#39;comment&#39; value: string","type":"references"},{"title":"官方扩展组件","path":"cn/references/wxc/index.html","permalink":"http://alibaba.github.io/cn/references/wxc/index.html","text":"官方扩展组件Weex 官方扩展组件指的是以 wxc- 开头的组件，这些组件不属于内建组件的一部分，而是 Weex 团队基于内建组件扩展的一些常用组件。这些组件依赖 weex-components，需要安装依赖后才可使用。 使用方式如下： 安装依赖 需要在工程目录下执行以下命令： npm install weex-components 使用 需要在 &lt;script&gt; 中引入依赖。 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123;&#125;, methods: &#123; // more &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<wxc-navpage>","path":"cn/references/wxc/wxc-navpage.html","permalink":"http://alibaba.github.io/cn/references/wxc/wxc-navpage.html","text":"&lt;wxc-navpage&gt; (v0.5+)&lt;wxc-navpage&gt; 组件是一个包含 navbar 的容器组件，可以根据业务场景定制 navbar 组件。同时，可以使用 navigator 模块控制页面的跳转，具体参考 navigator module。一般情况，都是配合 navbar 组件使用。如果不了解 navigator 相关知识，建议先了解下 iOS 或者 Android 的相关组件。在 H5 上，其实是相当于导航栏。 用法：在 script 标签中通过一个 require 语句引入，即：require(&#39;weex-components&#39;); 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-navpage tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-navpage&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); // more&lt;/script&gt; 在 require(&#39;weex-components&#39;); 之前 ，需要在工程目录下执行以下命令： npm install weex-components 子组件&lt;wxc-navpage&gt; 组件支持任意 Weex 组件。 特性&lt;wxc-navpage&gt; 组件的特性其实是对 navbar 进行功能设置，如下图所示，是 navbar 的一个简单示意。 height {number}：navbar 的高度，默认是 88。 background-color {color}：navbar 的背景颜色，默认是白色。 title {string}：navbar 的标题。 title-color {color}：navbar 标题的颜色，默认黑色。 left-item-title {string}：navbar 左侧按钮的标题。 left-item-color {color}：navbar 左侧按钮标题颜色，默认黑色。 right-item-title {string}：navbar 右侧按钮标题。 right-item-color {color}：navbar 右侧按钮标题颜色，默认黑色。 left-item-src {string}：navbar 左侧按钮的图标。 right-item-src {string}：navbar 右侧按钮的图标。 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件&lt;wxc-navpage&gt; 组件支持左右两项点击事件。 naviBar.leftItem.click: 当 navbar 的左侧按钮被点击时触发事件，需要在 created 时期注册事件。 naviBar.rightItem.click: 当 navbar 的右侧按钮被点击时触发事件，需要在 created 时期注册事件。 示例： &lt;template&gt; &lt;wxc-navpage height=&#123;&#123;...&#125;&#125; background-color=\"...\" title=\"...\" title-color=\"...\" left-item-title=\"...\" left-item-color=\"...\" right-item-src=\"...\"&gt; &lt;content&gt; ...&lt;/content&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; created: function() &#123; this.$on('naviBar.rightItem.click',function(e)&#123; //handle your click event here. &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; //handle your click event here. &#125;); &#125; &#125;&lt;/script&gt; 通用事件 支持所有通用事件： click longpress appear disappear 查看 通用事件 示例注意： dotwe 平台暂不支持 wxc-xxx 类型的组件。 &lt;template&gt; &lt;wxc-navpage data-role=\"none\" height=&#123;&#123;navBarHeight&#125;&#125; background-color=\"#ff5898\" title=&#123;&#123;title&#125;&#125; title-color=\"white\" left-item-title=\"More\" left-item-color=\"white\" right-item-src=\"http://gtms02.alicdn.com/tps/i2/TB1ED7iMpXXXXXEXXXXWA_BHXXX-48-48.png\"&gt; &lt;wxc-panel title=\"push a new page\"&gt; &lt;wxc-button type=\"primary\" size=\"small\" value=\"push\" onclick=\"push\"&gt;&lt;/wxc-button&gt; &lt;/wxc-panel&gt; &lt;wxc-panel title=\"pop to the last page\"&gt; &lt;wxc-button type=\"success\" size=\"small\" value=\"pop\" onclick=\"pop\"&gt;&lt;/wxc-button&gt; &lt;/wxc-panel&gt; &lt;/wxc-navpage&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; navBarHeight: 88, title: 'Navigator', dir: 'examples', baseURL: '', &#125;, created: function() &#123; this.$getConfig(function (config) &#123; var env = config.env; if(env.platform == 'iOS')&#123; var scale = env.scale; var deviceWidth = env.deviceWidth / scale; this.navBarHeight = 64.0 * 750.0 / deviceWidth; &#125; &#125;.bind(this)); this.$on('naviBar.rightItem.click',function(e)&#123; duration = 2; this.$call('modal', 'toast', &#123; 'message': 'naviBar.rightItem.click', 'duration': duration &#125;); &#125;); this.$on('naviBar.leftItem.click',function(e)&#123; duration = 2; this.$call('modal', 'toast', &#123; 'message': 'naviBar.leftItem.click', 'duration': duration &#125;); &#125;); &#125;, methods: &#123; push: function() &#123; var vm = this; var params = &#123; 'url': 'http://dotwe.org/raw/dist/33dfcbe81979c60ba5de72c235d7d0f8.js', 'animated' : 'true', &#125; vm.$call('navigator','push',params, function () &#123;&#125;); &#125;, pop: function() &#123; var vm = this; var params = &#123; 'animated' : 'true', &#125; vm.$call('navigator','pop',params, function () &#123;&#125;); &#125; &#125; &#125;&lt;/script&gt;","type":"references"},{"title":"<wxc-tabbar>","path":"cn/references/wxc/wxc-tabbar.html","permalink":"http://alibaba.github.io/cn/references/wxc/wxc-tabbar.html","text":"&lt;wxc-tabbar&gt;&lt;wxc-tabbar&gt; 是一个名为 weex-components 依赖库的自定义组件。&lt;wxc-tabbar&gt; 能在窗口的底部显示 tab 页面，我们可以在不同的 tab 页面之间切换。 用法：在 script 标签中通过一个 require 语句引入，即：require(&#39;weex-components&#39;); 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items = &#123;&#123;tabItems&#125;&#125;&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123;&#125;, methods: &#123; // more &#125; &#125;&lt;/script&gt; 在 require(&#39;weex-components&#39;); 之前 ，需要在工程目录下执行以下命令： npm install weex-components 子组件该组件不支持子组件。 特性 selected-index {number}：设置默认选中的 tab 索引，默认值为 0（第一个 tab）。 selected-color {color}：设置当标题被选中时标题的颜色，默认为红色。 unselected-color {color}：设置当标题不被选中时标题的颜色，默认为黑色。 tab-items {Array[Object]}：该属性接受一个 tabitems 对象数组, 分别对应到对应的 tab 页面，tab 页面的顺序跟对象数组的位置对应。我们可以通过设置每一项的属性来配置 tabbar 的外观： index {integer}：必填属性，指明了 tabitem 的次序。 title {string}：设置 tabitem 的标题，非必填，当标题为空时，标题将不会被显示 titleColor {color}：设置 tabitem 的标题颜色，默认是黑色 image {string}：当 tab 页面不被选中时显示的 icon，当不提供时，什么也不显示。 selectedImage {string}：设置 tab 页面被选中时显示的图片，不提供图片时，什么也不显示。 src {string}：设置 tab 对应的 Weex 页面的 url，为 http 开头。 visibility {string}：值为 visible | hidden，该属性指明了 tab 页面的显示状态，默认值是 visible 样式 通用样式：支持所有通用样式 盒模型 flexbox 布局 position opacity background-color 查看 组件通用样式 事件 tabBar.onClick：当 tab 页面被选中时触发，需要在 ready 或者 create 生命周期中注册，如： 示例 &lt;template&gt; &lt;div style=\"flex-direction: column;\"&gt; &lt;wxc-tabbar tab-items=\"&#123;&#123;tabItems&#125;&#125;\"&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; // ... &#125;, created: function() &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var detail= e.detail; console.log('tabBar.onClick ' + detail.index); &#125;); &#125;, methods: &#123; &#125; &#125;&lt;/script&gt; 通用事件支持所有通用事件： click longpress appear disappear 查看 通用事件 示例注意： dotwe 平台暂不支持 wxc-xxx 类型的组件。 &lt;template&gt; &lt;div&gt; &lt;wxc-tabbar tab-items=\"&#123;&#123;tabItems&#125;&#125;\"&gt;&lt;/wxc-tabbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; require('weex-components'); module.exports = &#123; data: &#123; dir: 'examples', tabItems: [ &#123; index: 0, title: 'tab1', titleColor: '#000000', icon: '', image: 'http://gtms01.alicdn.com/tps/i1/TB1qw.hMpXXXXagXXXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms04.alicdn.com/tps/i4/TB16jjPMpXXXXazXVXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/ba202bcd277285c7f3cf79f9b1055dce.js?itemId=tab1', visibility: 'visible', &#125;, &#123; index: 1, title: 'tab2', titleColor: '#000000', icon: '', image: 'http://gtms03.alicdn.com/tps/i3/TB1LEn9MpXXXXaUXpXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms02.alicdn.com/tps/i2/TB1qysbMpXXXXcnXXXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/7e24b83c5868dbd4462e30549999245d.js?itemId=tab2', visibility: 'hidden', &#125;, &#123; index: 2, title: 'tab3', titleColor: '#000000', icon: '', image: 'http://gtms01.alicdn.com/tps/i1/TB1B0v5MpXXXXcvXpXX9t7RGVXX-46-46.png', selectedImage: 'http://gtms04.alicdn.com/tps/i4/TB1NxY5MpXXXXcrXpXX9t7RGVXX-46-46.png', src: 'http://dotwe.org/raw/dist/8a8b49b67084423e097a6b7f549f1453.js?itemId=tab3', visibility: 'hidden', &#125; ], &#125;, created: function() &#123; var vm = this; vm.$on('tabBar.onClick',function(e)&#123; var detail= e.detail; console.log('tabBar.onClick ' + detail.index); &#125;); &#125;, methods: &#123;&#125; &#125;&lt;/script&gt;","type":"references"}],"posts":[{"title":"sadfasdfasdf","path":"cn/sadfasdfasdf/","link":"","permalink":"http://alibaba.github.io/weex-website/cn/sadfasdfasdf/","text":"","type":"blog"},{"title":"Child-Parent Communication","path":"en/co/","link":"","permalink":"http://alibaba.github.io/weex-website/en/co/","text":"Hello world0.4 For Child-Parent CommunicationChildren component can use this.$dispatch([String type], [Object detail]) method passing information to parent component. first argument meaning type of message , second argument is the message object. If any parent of the child component register the same type of listener using $on([String type], [Function callback]) method , the callback will be execute with one argument , the message object will be detail property of the the argument. eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; this.$dispatch('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;foo title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; this.$on('notify', function(e) &#123; // when &lt;foo&gt; image tag be clicked ,the function will be executing. // e.detail is `&#123;a: 1&#125;` &#125;) &#125; &#125;&lt;/script&gt; For Parent-Child CommunicationParent component can use this.$vm([String id]) get vm instance of child component. you can access child component information using the vm instance. &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; setTitle: function (t) &#123; this.title = t &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo id=\"fooEl\" title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; var foo = this.$vm('fooEl') foo.setTitle('...') foo.imageUrl = '...' &#125; &#125; &#125;&lt;/script&gt; Parent to Children (multi-child) CommunicationParent can using this.$broadcast([String type], [Object detail]) broadcast message to all of children. eg: &lt;we-element name=\"bar\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; var self = this this.$on('changeImage', function(e) &#123; self.imageUrl = e.detail.imageUrl &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;bar&gt;&lt;/bar&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '' &#125;, created: function() &#123; var self = this this.$on('changeTitle', function(e) &#123; self.title = e.detail.title &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$broadcast('changeTitle', &#123; title: '...' &#125;) this.$broadcast('changeImage', &#123; imageUrl: '...' &#125;) &#125; &#125; &#125;&lt;/script&gt; Siblings Communicationsiblings components can using common parent as bridge for passing information eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; methods: &#123; callbar: function () &#123; this.$dispatch('callbar', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"bar\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; created: function() &#123; this.$on('callbar', function(e) &#123; // e.detail.a &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; var self = this this.$on('callbar', function(e) &#123; self.$broadcast('callbar', e.detail) &#125;) &#125; &#125;&lt;/script&gt; At last, you can learn how to write config &amp; data for a Weex page.","type":"blog"},{"title":"Hello World","path":"en/hello-world/","link":"","permalink":"http://alibaba.github.io/weex-website/en/hello-world/","text":"Hello world0.4 For Child-Parent CommunicationChildren component can use this.$dispatch([String type], [Object detail]) method passing information to parent component. first argument meaning type of message , second argument is the message object. If any parent of the child component register the same type of listener using $on([String type], [Function callback]) method , the callback will be execute with one argument , the message object will be detail property of the the argument. eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\" onclick=\"test\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; test: function () &#123; this.$dispatch('notify', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;foo title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; this.$on('notify', function(e) &#123; // when &lt;foo&gt; image tag be clicked ,the function will be executing. // e.detail is `&#123;a: 1&#125;` &#125;) &#125; &#125;&lt;/script&gt; For Parent-Child CommunicationParent component can use this.$vm([String id]) get vm instance of child component. you can access child component information using the vm instance. &lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '', imageUrl: '' &#125;, methods: &#123; setTitle: function (t) &#123; this.title = t &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo id=\"fooEl\" title=\"...\" image-url=\"...\"&gt;&lt;/foo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; var foo = this.$vm('fooEl') foo.setTitle('...') foo.imageUrl = '...' &#125; &#125; &#125;&lt;/script&gt; Parent to Children (multi-child) CommunicationParent can using this.$broadcast([String type], [Object detail]) broadcast message to all of children. eg: &lt;we-element name=\"bar\"&gt; &lt;template&gt; &lt;div&gt; &lt;image src=\"&#123;&#123;imageUrl&#125;&#125;\"&gt;&lt;/image&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; imageUrl: '' &#125;, created: function() &#123; var self = this this.$on('changeImage', function(e) &#123; self.imageUrl = e.detail.imageUrl &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"foo\"&gt; &lt;template&gt; &lt;div&gt; &lt;bar&gt;&lt;/bar&gt; &lt;text&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = &#123; data: &#123; title: '' &#125;, created: function() &#123; var self = this this.$on('changeTitle', function(e) &#123; self.title = e.detail.title &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;text onclick=\"test\"&gt;click to update foo&lt;/text&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; methods: &#123; test: function (e) &#123; this.$broadcast('changeTitle', &#123; title: '...' &#125;) this.$broadcast('changeImage', &#123; imageUrl: '...' &#125;) &#125; &#125; &#125;&lt;/script&gt; Siblings Communicationsiblings components can using common parent as bridge for passing information eg: &lt;we-element name=\"foo\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; methods: &#123; callbar: function () &#123; this.$dispatch('callbar', &#123;a: 1&#125;) &#125; &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;we-element name=\"bar\"&gt; &lt;template&gt;...&lt;/template&gt; &lt;script&gt; module.exports = &#123; created: function() &#123; this.$on('callbar', function(e) &#123; // e.detail.a &#125;) &#125; &#125; &lt;/script&gt;&lt;/we-element&gt;&lt;template&gt; &lt;div&gt; &lt;foo&gt;&lt;/foo&gt; &lt;bar&gt;&lt;/bar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; created: function () &#123; var self = this this.$on('callbar', function(e) &#123; self.$broadcast('callbar', e.detail) &#125;) &#125; &#125;&lt;/script&gt; At last, you can learn how to write config &amp; data for a Weex page.","type":"blog"}]}